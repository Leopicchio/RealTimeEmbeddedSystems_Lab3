
CPU1_lab3_1.elf:     file format elf32-littlenios2
CPU1_lab3_1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x20020244

Program Header:
    LOAD off    0x00001000 vaddr 0x20020000 paddr 0x20020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x20020020 paddr 0x20020020 align 2**12
         filesz 0x0000b15c memsz 0x0000b15c flags r-x
    LOAD off    0x0000c17c vaddr 0x2002b17c paddr 0x2002c878 align 2**12
         filesz 0x000016fc memsz 0x000016fc flags rw-
    LOAD off    0x0000df74 vaddr 0x2002df74 paddr 0x2002df74 align 2**12
         filesz 0x00000000 memsz 0x00003bb4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  20020000  20020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  20020020  20020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000adac  20020244  20020244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000018c  2002aff0  2002aff0  0000bff0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000016fc  2002b17c  2002c878  0000c17c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00003bb4  2002df74  2002df74  0000df74  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller 00000000  10000000  10000000  0000d878  2**0
                  CONTENTS
  7 .CPU_1_0_onchip_memory2_0 00000000  20031b28  20031b28  0000d878  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000d878  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000007b8  00000000  00000000  0000d8a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00012285  00000000  00000000  0000e058  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00004b9c  00000000  00000000  000202dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000566e  00000000  00000000  00024e79  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001df8  00000000  00000000  0002a4e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00002f46  00000000  00000000  0002c2e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00000de4  00000000  00000000  0002f226  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  0003000c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000001e8  00000000  00000000  00030040  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  000339a2  2**0
                  CONTENTS, READONLY
 19 .cpu          00000014  00000000  00000000  000339a8  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  000339bc  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  000339bd  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  000339be  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  000339c2  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  000339c6  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000013  00000000  00000000  000339ca  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000013  00000000  00000000  000339dd  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000013  00000000  00000000  000339f0  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 0000000b  00000000  00000000  00033a03  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000041  00000000  00000000  00033a0e  2**0
                  CONTENTS, READONLY
 30 .jdi          0000d028  00000000  00000000  00033a4f  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000b40c7  00000000  00000000  00040a77  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
20020000 l    d  .entry	00000000 .entry
20020020 l    d  .exceptions	00000000 .exceptions
20020244 l    d  .text	00000000 .text
2002aff0 l    d  .rodata	00000000 .rodata
2002b17c l    d  .rwdata	00000000 .rwdata
2002df74 l    d  .bss	00000000 .bss
10000000 l    d  .sdram_controller	00000000 .sdram_controller
20031b28 l    d  .CPU_1_0_onchip_memory2_0	00000000 .CPU_1_0_onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../CPU1_lab3_1_bsp//obj/HAL/src/crt0.o
2002028c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 CPU1_main.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
200206c0 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_env_lock.c
2002c7cc l     O .rwdata	00000004 lockid
2002df90 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
2002c7d0 l     O .rwdata	00000004 lockid
2002df98 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
20022164 l     F .text	00000048 OS_InitMisc
200221ac l     F .text	0000006c OS_InitRdyList
20022318 l     F .text	000000e4 OS_InitTCBList
20022084 l     F .text	000000e0 OS_InitEventList
20022218 l     F .text	00000080 OS_InitTaskIdle
20022298 l     F .text	00000080 OS_InitTaskStat
20022588 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
20024298 l     F .text	000000f4 OS_FlagTaskRdy
20024058 l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
2002833c l     F .text	00000034 alt_dev_reg
20028370 l     F .text	0000003c alt_get_errno
200283ac l     F .text	000000a8 alt_avalon_mutex_reg
2002b17c l     O .rwdata	0000106c CPU_1_0_jtag_uart_0
2002c1e8 l     O .rwdata	00000014 mutex_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
200287a8 l     F .text	000002a4 altera_avalon_jtag_uart_irq
20028a4c l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mutex.c
20029228 l     F .text	0000003c alt_get_errno
20029264 l     F .text	0000007c alt_mutex_trylock
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
20029574 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
20029794 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
200298e8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
20029914 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
20029c14 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
20029d54 l     F .text	0000003c alt_get_errno
20029d90 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
2002c3a4 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_exit.c
2002dff4 g     O .bss	00000004 alt_instruction_exception_handler
2002c81e g     O .rwdata	00000002 OSTaskNameSize
200207ac g     F .text	000000bc alt_main
2002e804 g     O .bss	00000100 alt_irq
20024ab8 g     F .text	000000cc OS_MemInit
2002c878 g       *ABS*	00000000 __flash_rwdata_start
200282dc g     F .text	00000060 OSTimeSet
2002df78 g     O .bss	00000001 time_elapsed
20020dd8 g     F .text	00000610 OSEventPendMulti
2002a400 g     F .text	00000024 OSTaskCreateHook
2002c7f6 g     O .rwdata	00000002 OSMboxEn
20021440 g     F .text	0000004c OSIntEnter
2002c806 g     O .rwdata	00000002 OSQEn
20020aac g     F .text	000000cc __malloc_unlock
2002a468 g     F .text	00000020 OSTaskStatHook
2002dfa0 g     O .bss	00000001 OSLockNesting
2002c844 g     O .rwdata	00000002 OSDataSize
2002dfa1 g     O .bss	00000001 OSRunning
2002a4a8 g     F .text	00000020 OSInitHookBegin
2002c83c g     O .rwdata	00000002 OSTmrSize
200293c4 g     F .text	00000080 altera_avalon_mutex_trylock
2002dfa4 g     O .bss	00000004 OSIdleCtr
2002a1b0 g     F .text	00000024 altera_nios2_gen2_irq_init
2002a280 g       .text	00000000 OSStartTsk
200228b8 g     F .text	000002d4 OS_TCBInit
20020000 g     F .entry	0000001c __reset
2002c842 g     O .rwdata	00000002 OSTmrWheelTblSize
200294b0 g     F .text	00000074 altera_avalon_mutex_is_mine
20020020 g       *ABS*	00000000 __flash_exceptions_start
2002c7e2 g     O .rwdata	00000002 OSEventSize
2002dfa8 g     O .bss	00000001 OSPrioHighRdy
2002a424 g     F .text	00000024 OSTaskDelHook
2002e000 g     O .bss	00000004 errno
2002a260 g       .text	00000000 OSStartHighRdy
20026d84 g     F .text	000001e4 OSTaskCreateExt
10000000 g       *ABS*	00000000 __alt_mem_sdram_controller
20023ba0 g     F .text	00000060 OSFlagPendGetFlagsRdy
2002c822 g     O .rwdata	00000002 OSTaskStatStkSize
20022d1c g     F .text	00000308 OSFlagAccept
200250f0 g     F .text	000000b8 OSQFlush
20024b84 g     F .text	00000140 OSQAccept
2002df88 g     O .bss	00000004 alt_argv
200347c8 g       *ABS*	00000000 _gp
20026bd8 g     F .text	000001ac OSTaskCreate
200266e8 g     F .text	000004f0 OSTaskChangePrio
2002df9c g     O .bss	00000004 alt_heapsem
20022b8c g     F .text	00000190 OSDebugInit
20026f68 g     F .text	00000344 OSTaskDel
2002c224 g     O .rwdata	00000180 alt_fd_list
2002e904 g     O .bss	00000370 OSFlagTbl
20021e64 g     F .text	000000b8 OS_EventTaskRemove
20029ab4 g     F .text	00000090 alt_find_dev
2002a868 g     F .text	00000148 memcpy
2002c80c g     O .rwdata	00000002 OSRdyTblSize
20029cd8 g     F .text	0000007c alt_io_redirect
2002aff0 g       *ABS*	00000000 __DTOR_END__
20029b78 g     F .text	0000009c alt_exception_cause_generated_bad_addr
20020b78 g     F .text	00000120 OSEventNameGet
2002c7f0 g     O .rwdata	00000002 OSFlagMax
2002148c g     F .text	000000f8 OSIntExit
2002c82a g     O .rwdata	00000002 OSTCBSize
2002dfa9 g     O .bss	00000001 OSPrioCur
20028ca8 g     F .text	000002bc altera_avalon_jtag_uart_read
2002af00 g     F .text	00000064 .hidden __udivsi3
2002c810 g     O .rwdata	00000002 OSStkWidth
2002c804 g     O .rwdata	00000002 OSPtrSize
2002c7e4 g     O .rwdata	00000002 OSEventTblSize
2002a1d4 g       .text	00000000 OSCtxSw
2002a710 g     F .text	00000090 alt_icache_flush
2002dfac g     O .bss	00000004 OSTCBList
2002dff0 g     O .bss	00000004 alt_fd_list_lock
2002ec74 g     O .bss	00000c30 OSMemTbl
2002dfb0 g     O .bss	00000001 OSTickStepState
2002c808 g     O .rwdata	00000002 OSQMax
2002f8a4 g     O .bss	00000800 OSTaskStatStk
200246f4 g     F .text	000000f0 OSMemNameGet
2002c7e8 g     O .rwdata	00000002 OSFlagEn
2002c82e g     O .rwdata	00000002 OSTimeTickHookEn
200255a0 g     F .text	00000168 OSQPost
2002438c g     F .text	000000a4 OS_FlagUnlink
2002c860 g     O .rwdata	00000004 alt_max_fd
20022450 g     F .text	00000068 OS_MemCopy
200224b8 g     F .text	000000d0 OS_Sched
20024604 g     F .text	000000f0 OSMemGet
20027594 g     F .text	000001b4 OSTaskNameSet
2002dfb4 g     O .bss	00000004 OSCtxSwCtr
2002a488 g     F .text	00000020 OSTimeTickHook
2002c7f2 g     O .rwdata	00000002 OSFlagNameSize
20021f1c g     F .text	00000100 OS_EventTaskRemoveMulti
20021d14 g     F .text	00000150 OS_EventTaskWaitMulti
2002c80a g     O .rwdata	00000002 OSQSize
20029524 g     F .text	00000050 altera_avalon_mutex_first_lock
20026050 g     F .text	0000020c OSSemPend
2002c870 g     O .rwdata	00000004 _global_impure_ptr
2002c7f4 g     O .rwdata	00000002 OSLowestPrio
20031b28 g       *ABS*	00000000 __bss_end
200205d0 g     F .text	000000f0 alt_iic_isr_register
2002a508 g     F .text	00000024 OSTCBInitHook
2002c83a g     O .rwdata	00000002 OSTmrCfgTicksPerSec
2002a0a8 g     F .text	00000108 alt_tick
2002c7dc g     O .rwdata	00000002 OSEventEn
2002c836 g     O .rwdata	00000002 OSTmrCfgNameSize
20020584 g     F .text	0000004c alt_ic_irq_enabled
200241b8 g     F .text	000000e0 OS_FlagInit
2002a00c g     F .text	0000009c alt_alarm_stop
2002c818 g     O .rwdata	00000002 OSTaskIdleStkSize
2002df80 g     O .bss	00000004 alt_irq_active
20025c88 g     F .text	000000b0 OSSemAccept
200248f8 g     F .text	000000d8 OSMemPut
20024430 g     F .text	000001d4 OSMemCreate
2002dfb8 g     O .bss	00000004 OSIdleCtrMax
200200fc g     F .exceptions	000000d4 alt_irq_handler
2002c1fc g     O .rwdata	00000028 alt_dev_null
2002c82c g     O .rwdata	00000002 OSTicksPerSec
200292e0 g     F .text	00000054 altera_avalon_mutex_open
2002a1d4 g       .text	00000000 OSIntCtxSw
200298a0 g     F .text	00000048 alt_dcache_flush_all
2002dfbc g     O .bss	00000004 OSTCBFreeList
2002c878 g       *ABS*	00000000 __ram_rwdata_end
2002625c g     F .text	0000016c OSSemPendAbort
2002c858 g     O .rwdata	00000008 alt_dev_list
2002c830 g     O .rwdata	00000002 OSVersionNbr
2002c848 g     O .rwdata	00000008 alt_mutex_list
2002b17c g       *ABS*	00000000 __ram_rodata_end
2002c7d8 g     O .rwdata	00000004 OSEndiannessTest
2002af64 g     F .text	00000058 .hidden __umodsi3
2002c7ea g     O .rwdata	00000002 OSFlagGrpSize
2002df7c g     O .bss	00000004 mutex
20031b28 g       *ABS*	00000000 end
20028660 g     F .text	00000148 altera_avalon_jtag_uart_init
20022720 g     F .text	000000cc OS_TaskStat
200201d0 g     F .exceptions	00000074 alt_instruction_exception_entry
2002aff0 g       *ABS*	00000000 __CTOR_LIST__
20040000 g       *ABS*	00000000 __alt_stack_pointer
200295ec g     F .text	0000007c alt_avalon_timer_sc_init
20028f64 g     F .text	000002c4 altera_avalon_jtag_uart_write
200223fc g     F .text	00000054 OS_MemClr
2002a2a4 g     F .text	0000015c OSTaskStkInit
20021a6c g     F .text	00000198 OS_EventTaskRdy
2002ac88 g     F .text	00000180 __call_exitprocs
2002dfc0 g     O .bss	00000001 OSCPUUsage
20020244 g     F .text	0000004c _start
2002dff8 g     O .bss	00000004 _alt_tick_rate
200251a8 g     F .text	0000028c OSQPend
20027e54 g     F .text	00000104 OSTimeDly
2002dffc g     O .bss	00000004 _alt_nticks
2002848c g     F .text	00000070 alt_sys_init
2002ab70 g     F .text	00000118 __register_exitproc
2002df74 g     O .bss	00000004 milliseconds
2002dfc1 g     O .bss	00000001 OSTaskCtr
20029444 g     F .text	0000006c altera_avalon_mutex_unlock
20027f58 g     F .text	00000154 OSTimeDlyHMSM
20028b50 g     F .text	00000068 altera_avalon_jtag_uart_close
2002b17c g       *ABS*	00000000 __ram_rwdata_start
2002aff0 g       *ABS*	00000000 __ram_rodata_start
2002c7de g     O .rwdata	00000002 OSEventMax
200263c8 g     F .text	00000110 OSSemPost
20021610 g     F .text	000000dc OSSchedUnlock
200284fc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
2002a634 g     F .text	000000dc alt_get_fd
2002dfc4 g     O .bss	00000004 OSMemFreeList
2002175c g     F .text	000000b0 OSStatInit
20023f94 g     F .text	000000c4 OSFlagQuery
2002c814 g     O .rwdata	00000002 OSTaskCreateExtEn
2002a7ec g     F .text	0000007c memcmp
20021a4c g     F .text	00000020 OS_Dummy
200285bc g     F .text	00000050 altera_avalon_jtag_uart_close_fd
20031b28 g       *ABS*	00000000 __alt_stack_base
2002860c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
200300a4 g     O .bss	000001e0 OSQTbl
2002dfc8 g     O .bss	00000004 OSTCBHighRdy
2002dfcc g     O .bss	00000004 OSQFreeList
2002a52c g     F .text	00000108 alt_find_file
20029950 g     F .text	000000a4 alt_dev_llist_insert
2002098c g     F .text	00000120 __malloc_lock
20020c98 g     F .text	00000140 OSEventNameSet
2002dfd0 g     O .bss	00000001 OSRdyGrp
2002df74 g       *ABS*	00000000 __bss_start
2002a9b0 g     F .text	00000128 memset
20020310 g     F .text	000000b8 main
2002df8c g     O .bss	00000004 alt_envp
2002855c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
2002b01c g     O .rodata	00000100 OSUnMapTbl
2002c80e g     O .rwdata	00000002 OSSemEn
20023c00 g     F .text	00000394 OSFlagPost
20021c04 g     F .text	00000110 OS_EventTaskWait
200227ec g     F .text	000000cc OS_TaskStatStkChk
20029358 g     F .text	0000006c altera_avalon_mutex_lock
200272ac g     F .text	00000150 OSTaskDelReq
2002c864 g     O .rwdata	00000004 alt_errno
200216ec g     F .text	00000070 OSStart
2002092c g     F .text	00000060 __env_unlock
20027748 g     F .text	000001d4 OSTaskResume
200249d0 g     F .text	000000e8 OSMemQuery
2002c820 g     O .rwdata	00000002 OSTaskStatEn
2002c7fa g     O .rwdata	00000002 OSMemMax
20025708 g     F .text	00000170 OSQPostFront
2002ae08 g     F .text	00000084 .hidden __divsi3
2002dfd1 g     O .bss	00000003 OSRdyTbl
2002c7d4 g     O .rwdata	00000002 OSDebugEn
2002aff0 g       *ABS*	00000000 __CTOR_END__
2002c7ec g     O .rwdata	00000002 OSFlagNodeSize
2002c834 g     O .rwdata	00000002 OSTmrCfgMax
20024cc4 g     F .text	000001ac OSQCreate
200273fc g     F .text	00000198 OSTaskNameGet
2002aff0 g       *ABS*	00000000 __flash_rodata_start
20025878 g     F .text	0000020c OSQPostOpt
2002180c g     F .text	00000220 OSTimeTick
2002c81c g     O .rwdata	00000002 OSTaskMax
2002aff0 g       *ABS*	00000000 __DTOR_LIST__
20025d38 g     F .text	000000d8 OSSemCreate
2002c840 g     O .rwdata	00000002 OSTmrWheelSize
2002c816 g     O .rwdata	00000002 OSTaskDelEn
200264d8 g     F .text	00000110 OSSemQuery
20024e70 g     F .text	00000280 OSQDel
20025434 g     F .text	0000016c OSQPendAbort
20028454 g     F .text	00000038 alt_irq_init
20029fa8 g     F .text	00000064 alt_release_fd
2002a7a0 g     F .text	00000014 atexit
20021584 g     F .text	0000008c OSSchedLock
20023024 g     F .text	00000108 OSFlagCreate
20020290 g     F .text	00000080 task_leds
2002c874 g     O .rwdata	00000004 _impure_ptr
2002df84 g     O .bss	00000004 alt_argc
200203c8 g     F .text	00000058 timer_interrupt
20029a54 g     F .text	00000060 _do_dtors
2002c7e6 g     O .rwdata	00000002 OSEventMultiEn
2002312c g     F .text	00000248 OSFlagDel
2002dfd4 g     O .bss	00000004 OSEventFreeList
20020020 g       .exceptions	00000000 alt_irq_entry
200235e8 g     F .text	000005b8 OSFlagPend
2002c832 g     O .rwdata	00000002 OSTmrEn
2002c850 g     O .rwdata	00000008 alt_fs_list
200225fc g     F .text	00000074 OS_StrCopy
2002c7fc g     O .rwdata	00000002 OSMemNameSize
2002a4c8 g     F .text	00000020 OSInitHookEnd
20020020 g       *ABS*	00000000 __ram_exceptions_start
2002c828 g     O .rwdata	00000002 OSTCBPrioTblMax
2002c824 g     O .rwdata	00000002 OSTaskStatStkChkEn
20020420 g     F .text	00000050 alt_ic_isr_register
2002c7f8 g     O .rwdata	00000002 OSMemEn
2002c802 g     O .rwdata	00000002 OSMutexEn
2002c878 g       *ABS*	00000000 _edata
20031b28 g       *ABS*	00000000 _end
2002dfd8 g     O .bss	00000001 OSIntNesting
20020244 g       *ABS*	00000000 __ram_exceptions_end
20028bb8 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
200280ac g     F .text	000001d4 OSTimeDlyResume
2002349c g     F .text	0000014c OSFlagNameSet
2002791c g     F .text	000001c0 OSTaskStkChk
200204f8 g     F .text	0000008c alt_ic_irq_disable
2002c7fe g     O .rwdata	00000002 OSMemSize
2002dfdc g     O .bss	00000004 OSTCBCur
2002a7b4 g     F .text	00000038 exit
2002c800 g     O .rwdata	00000002 OSMemTblSize
2002ae8c g     F .text	00000074 .hidden __modsi3
20040000 g       *ABS*	00000000 __alt_data_end
20020020 g     F .exceptions	00000000 alt_exception
200213e8 g     F .text	00000058 OSInit
20027cc0 g     F .text	00000124 OSTaskQuery
20025be0 g     F .text	000000a8 OS_QInit
20022670 g     F .text	00000054 OS_StrLen
200247e4 g     F .text	00000114 OSMemNameSet
2002c81a g     O .rwdata	00000002 OSTaskProfileEn
2002dfe0 g     O .bss	00000004 OSTime
20030284 g     O .bss	00000800 OSTaskIdleStk
2002afbc g     F .text	00000034 _exit
20029668 g     F .text	0000012c alt_alarm_start
20023374 g     F .text	00000128 OSFlagNameGet
20028280 g     F .text	0000005c OSTimeGet
2002aad8 g     F .text	00000098 strlen
2002a448 g     F .text	00000020 OSTaskSwHook
20029e54 g     F .text	00000154 open
20030a84 g     O .bss	00000b40 OSEventTbl
20020000 g       *ABS*	00000000 __alt_mem_CPU_1_0_onchip_memory2_0
200315c4 g     O .bss	00000510 OSTCBTbl
200265e8 g     F .text	00000100 OSSemSet
20029b44 g     F .text	00000034 alt_icache_flush_all
2002c7c8 g     O .rwdata	00000004 alt_priority_mask
20025e10 g     F .text	00000240 OSSemDel
2002dfe4 g     O .bss	00000004 OSFlagFreeList
20020470 g     F .text	00000088 alt_ic_irq_enable
2002c7e0 g     O .rwdata	00000002 OSEventNameSize
2002dfe8 g     O .bss	00000001 OSStatRdy
20029334 g     F .text	00000024 altera_avalon_mutex_close
20031ad4 g     O .bss	00000054 OSTCBPrioTbl
20020868 g     F .text	000000c4 __env_lock
2002c826 g     O .rwdata	00000002 OSTaskSwHookEn
2002e004 g     O .bss	00000800 task_leds_stack
2002c868 g     O .rwdata	00000008 alt_alarm_list
2002c7ee g     O .rwdata	00000002 OSFlagWidth
200299f4 g     F .text	00000060 _do_ctors
200297d0 g     F .text	000000d0 close
2002df94 g     O .bss	00000004 alt_envsem
2002dfec g     O .bss	00000004 OSIdleCtrRun
20021a2c g     F .text	00000020 OSVersion
2002c838 g     O .rwdata	00000002 OSTmrCfgWheelSize
20020728 g     F .text	00000084 alt_load
20027de4 g     F .text	00000070 OS_TaskStkClr
2002c812 g     O .rwdata	00000002 OSTaskCreateEn
2002201c g     F .text	00000068 OS_EventWaitListInit
2002a4e8 g     F .text	00000020 OSTaskIdleHook
20027adc g     F .text	000001e4 OSTaskSuspend
200226c4 g     F .text	0000005c OS_TaskIdle
2002c83e g     O .rwdata	00000002 OSTmrTblSize
20025a84 g     F .text	0000015c OSQQuery



Disassembly of section .entry:

20020000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
20020000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
20020004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
20020008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
2002000c:	00bffd16 	blt	zero,r2,20020004 <__alt_data_end+0xfffe0004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
20020010:	004800b4 	movhi	at,8194
    ori r1, r1, %lo(_start)
20020014:	08409114 	ori	at,at,580
    jmp r1
20020018:	0800683a 	jmp	at
2002001c:	00000000 	call	20000000 <__alt_mem_sdram_controller+0x10000000>

Disassembly of section .exceptions:

20020020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
20020020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
20020024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
20020028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
2002002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
20020030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
20020034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
20020038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
2002003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
20020040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
20020044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
20020048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
2002004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
20020050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
20020054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
20020058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
2002005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
20020060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
20020064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
20020068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
2002006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
20020070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
20020074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
20020078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
2002007c:	10000326 	beq	r2,zero,2002008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
20020080:	20000226 	beq	r4,zero,2002008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
20020084:	00200fc0 	call	200200fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
20020088:	00000706 	br	200200a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
2002008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
20020090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
20020094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
20020098:	00201d00 	call	200201d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
2002009c:	1000021e 	bne	r2,zero,200200a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
200200a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
200200a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
200200a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
200200ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
200200b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
200200b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
200200b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
200200bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
200200c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
200200c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
200200c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
200200cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
200200d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
200200d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
200200d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
200200dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
200200e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
200200e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
200200e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
200200ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
200200f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
200200f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
200200f8:	ef80083a 	eret

200200fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
200200fc:	defff904 	addi	sp,sp,-28
20020100:	dfc00615 	stw	ra,24(sp)
20020104:	df000515 	stw	fp,20(sp)
20020108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
2002010c:	00214400 	call	20021440 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
20020110:	0005313a 	rdctl	r2,ipending
20020114:	e0bffe15 	stw	r2,-8(fp)

  return active;
20020118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
2002011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
20020120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
20020124:	00800044 	movi	r2,1
20020128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
2002012c:	e0fffb17 	ldw	r3,-20(fp)
20020130:	e0bffc17 	ldw	r2,-16(fp)
20020134:	1884703a 	and	r2,r3,r2
20020138:	10001426 	beq	r2,zero,2002018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
2002013c:	008800f4 	movhi	r2,8195
20020140:	10ba0104 	addi	r2,r2,-6140
20020144:	e0fffd17 	ldw	r3,-12(fp)
20020148:	180690fa 	slli	r3,r3,3
2002014c:	10c5883a 	add	r2,r2,r3
20020150:	10c00017 	ldw	r3,0(r2)
20020154:	008800f4 	movhi	r2,8195
20020158:	10ba0104 	addi	r2,r2,-6140
2002015c:	e13ffd17 	ldw	r4,-12(fp)
20020160:	200890fa 	slli	r4,r4,3
20020164:	1105883a 	add	r2,r2,r4
20020168:	10800104 	addi	r2,r2,4
2002016c:	10800017 	ldw	r2,0(r2)
20020170:	1009883a 	mov	r4,r2
20020174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
20020178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
2002017c:	0005313a 	rdctl	r2,ipending
20020180:	e0bfff15 	stw	r2,-4(fp)

  return active;
20020184:	e0bfff17 	ldw	r2,-4(fp)
20020188:	00000706 	br	200201a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
2002018c:	e0bffc17 	ldw	r2,-16(fp)
20020190:	1085883a 	add	r2,r2,r2
20020194:	e0bffc15 	stw	r2,-16(fp)
      i++;
20020198:	e0bffd17 	ldw	r2,-12(fp)
2002019c:	10800044 	addi	r2,r2,1
200201a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
200201a4:	003fe106 	br	2002012c <__alt_data_end+0xfffe012c>

    active = alt_irq_pending ();
200201a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
200201ac:	e0bffb17 	ldw	r2,-20(fp)
200201b0:	103fdb1e 	bne	r2,zero,20020120 <__alt_data_end+0xfffe0120>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
200201b4:	002148c0 	call	2002148c <OSIntExit>
}
200201b8:	0001883a 	nop
200201bc:	e037883a 	mov	sp,fp
200201c0:	dfc00117 	ldw	ra,4(sp)
200201c4:	df000017 	ldw	fp,0(sp)
200201c8:	dec00204 	addi	sp,sp,8
200201cc:	f800283a 	ret

200201d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
200201d0:	defffb04 	addi	sp,sp,-20
200201d4:	dfc00415 	stw	ra,16(sp)
200201d8:	df000315 	stw	fp,12(sp)
200201dc:	df000304 	addi	fp,sp,12
200201e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
200201e4:	000531fa 	rdctl	r2,exception
200201e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
200201ec:	e0bffd17 	ldw	r2,-12(fp)
200201f0:	10801f0c 	andi	r2,r2,124
200201f4:	1004d0ba 	srli	r2,r2,2
200201f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
200201fc:	0005333a 	rdctl	r2,badaddr
20020200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
20020204:	d0a60b17 	ldw	r2,-26580(gp)
20020208:	10000726 	beq	r2,zero,20020228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
2002020c:	d0a60b17 	ldw	r2,-26580(gp)
20020210:	e0fffd17 	ldw	r3,-12(fp)
20020214:	e1bffe17 	ldw	r6,-8(fp)
20020218:	e17fff17 	ldw	r5,-4(fp)
2002021c:	1809883a 	mov	r4,r3
20020220:	103ee83a 	callr	r2
20020224:	00000206 	br	20020230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
20020228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
2002022c:	0005883a 	mov	r2,zero
}
20020230:	e037883a 	mov	sp,fp
20020234:	dfc00117 	ldw	ra,4(sp)
20020238:	df000017 	ldw	fp,0(sp)
2002023c:	dec00204 	addi	sp,sp,8
20020240:	f800283a 	ret

Disassembly of section .text:

20020244 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
20020244:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
20020248:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
2002024c:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
20020250:	00bffd16 	blt	zero,r2,20020248 <__alt_data_end+0xfffe0248>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
20020254:	06c80134 	movhi	sp,8196
    ori sp, sp, %lo(__alt_stack_pointer)
20020258:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
2002025c:	068800f4 	movhi	gp,8195
    ori gp, gp, %lo(_gp)
20020260:	d691f214 	ori	gp,gp,18376
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
20020264:	008800b4 	movhi	r2,8194
    ori r2, r2, %lo(__bss_start)
20020268:	10b7dd14 	ori	r2,r2,57204

    movhi r3, %hi(__bss_end)
2002026c:	00c800f4 	movhi	r3,8195
    ori r3, r3, %lo(__bss_end)
20020270:	18c6ca14 	ori	r3,r3,6952

    beq r2, r3, 1f
20020274:	10c00326 	beq	r2,r3,20020284 <_start+0x40>

0:
    stw zero, (r2)
20020278:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
2002027c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
20020280:	10fffd36 	bltu	r2,r3,20020278 <__alt_data_end+0xfffe0278>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
20020284:	00207280 	call	20020728 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
20020288:	00207ac0 	call	200207ac <alt_main>

2002028c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
2002028c:	003fff06 	br	2002028c <__alt_data_end+0xfffe028c>

20020290 <task_leds>:

long read_timer(long base_address);
void timer_interrupt();

void task_leds(void* pdata)
{
20020290:	defffa04 	addi	sp,sp,-24
20020294:	dfc00515 	stw	ra,20(sp)
20020298:	df000415 	stw	fp,16(sp)
2002029c:	df000404 	addi	fp,sp,16
200202a0:	e13fff15 	stw	r4,-4(fp)
	unsigned long counter = 0, data = 1, blink = 0;
200202a4:	e03ffc15 	stw	zero,-16(fp)
200202a8:	00800044 	movi	r2,1
200202ac:	e0bffd15 	stw	r2,-12(fp)
200202b0:	e03ffe15 	stw	zero,-8(fp)
	while (1)
	{
		if (time_elapsed == 1)
200202b4:	d0a5ec03 	ldbu	r2,-26704(gp)
200202b8:	10803fcc 	andi	r2,r2,255
200202bc:	1080201c 	xori	r2,r2,128
200202c0:	10bfe004 	addi	r2,r2,-128
200202c4:	10800058 	cmpnei	r2,r2,1
200202c8:	103ffa1e 	bne	r2,zero,200202b4 <__alt_data_end+0xfffe02b4>
		{
			//printf("CPU 1 %d\n", counter++);
			time_elapsed = 0;
200202cc:	d025ec05 	stb	zero,-26704(gp)

			altera_avalon_mutex_lock( mutex, 1 );	// acquire the mutex, setting the value to three
200202d0:	d0a5ed17 	ldw	r2,-26700(gp)
200202d4:	01400044 	movi	r5,1
200202d8:	1009883a 	mov	r4,r2
200202dc:	00293580 	call	20029358 <altera_avalon_mutex_lock>

			counter = IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE);
200202e0:	00850034 	movhi	r2,5120
200202e4:	10800037 	ldwio	r2,0(r2)
200202e8:	e0bffc15 	stw	r2,-16(fp)
			IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, counter + COUNTER_INCREMENT);
200202ec:	e0bffc17 	ldw	r2,-16(fp)
200202f0:	10bfffc4 	addi	r2,r2,-1
200202f4:	1007883a 	mov	r3,r2
200202f8:	00850034 	movhi	r2,5120
200202fc:	10c00035 	stwio	r3,0(r2)

			altera_avalon_mutex_unlock( mutex );	 // release the lock
20020300:	d0a5ed17 	ldw	r2,-26700(gp)
20020304:	1009883a 	mov	r4,r2
20020308:	00294440 	call	20029444 <altera_avalon_mutex_unlock>
		}
	}
2002030c:	003fe906 	br	200202b4 <__alt_data_end+0xfffe02b4>

20020310 <main>:
}


int main(void)
{
20020310:	defff904 	addi	sp,sp,-28
20020314:	dfc00615 	stw	ra,24(sp)
20020318:	df000515 	stw	fp,20(sp)
2002031c:	df000504 	addi	fp,sp,20
	// setup the parallel port to control the LEDs
	IOWR_ALTERA_AVALON_PIO_DIRECTION(PIO_0_BASE, 0xFFFFFFFF);	// sets pins as output
20020320:	00ffffc4 	movi	r3,-1
20020324:	00850034 	movhi	r2,5120
20020328:	10800104 	addi	r2,r2,4
2002032c:	10c00035 	stwio	r3,0(r2)

	// timer setup
	IOWR_ALTERA_AVALON_TIMER_CONTROL(CPU_1_0_TIMER_0_BASE, 0b0111);	// start timer, continuous mode on, interrupts active
20020330:	00c001c4 	movi	r3,7
20020334:	00880134 	movhi	r2,8196
20020338:	10840104 	addi	r2,r2,4100
2002033c:	10c00035 	stwio	r3,0(r2)

	// register the Isr to respond to a timer overflow
	alt_ic_isr_register(CPU_1_0_TIMER_0_IRQ_INTERRUPT_CONTROLLER_ID, CPU_1_0_TIMER_0_IRQ, timer_interrupt, NULL, NULL);
20020340:	d8000015 	stw	zero,0(sp)
20020344:	000f883a 	mov	r7,zero
20020348:	018800b4 	movhi	r6,8194
2002034c:	3180f204 	addi	r6,r6,968
20020350:	01400044 	movi	r5,1
20020354:	0009883a 	mov	r4,zero
20020358:	00204200 	call	20020420 <alt_ic_isr_register>

	/* get the mutex device handle */
	mutex = altera_avalon_mutex_open("/dev/mutex_0");
2002035c:	010800f4 	movhi	r4,8195
20020360:	212bfc04 	addi	r4,r4,-20496
20020364:	00292e00 	call	200292e0 <altera_avalon_mutex_open>
20020368:	d0a5ed15 	stw	r2,-26700(gp)



	// creates the task which displays the counter value on the LEDs
	OSTaskCreateExt(task_leds,
2002036c:	d8000415 	stw	zero,16(sp)
20020370:	d8000315 	stw	zero,12(sp)
20020374:	00808004 	movi	r2,512
20020378:	d8800215 	stw	r2,8(sp)
2002037c:	008800f4 	movhi	r2,8195
20020380:	10b80104 	addi	r2,r2,-8188
20020384:	d8800115 	stw	r2,4(sp)
20020388:	00800084 	movi	r2,2
2002038c:	d8800015 	stw	r2,0(sp)
20020390:	01c00084 	movi	r7,2
20020394:	018800f4 	movhi	r6,8195
20020398:	31ba0004 	addi	r6,r6,-6144
2002039c:	000b883a 	mov	r5,zero
200203a0:	010800b4 	movhi	r4,8194
200203a4:	2100a404 	addi	r4,r4,656
200203a8:	0026d840 	call	20026d84 <OSTaskCreateExt>
                  TASK_STACKSIZE,
                  NULL,
                  0);
              
               
  OSStart();
200203ac:	00216ec0 	call	200216ec <OSStart>
  return 0;
200203b0:	0005883a 	mov	r2,zero
}
200203b4:	e037883a 	mov	sp,fp
200203b8:	dfc00117 	ldw	ra,4(sp)
200203bc:	df000017 	ldw	fp,0(sp)
200203c0:	dec00204 	addi	sp,sp,8
200203c4:	f800283a 	ret

200203c8 <timer_interrupt>:



// Timer Isr: every 1 ms updates the counter
void timer_interrupt()
{
200203c8:	deffff04 	addi	sp,sp,-4
200203cc:	df000015 	stw	fp,0(sp)
200203d0:	d839883a 	mov	fp,sp
	if (milliseconds < COUNTER_PERIOD)
200203d4:	d0a5eb17 	ldw	r2,-26708(gp)
200203d8:	108002a8 	cmpgeui	r2,r2,10
200203dc:	1000041e 	bne	r2,zero,200203f0 <timer_interrupt+0x28>
		milliseconds++;
200203e0:	d0a5eb17 	ldw	r2,-26708(gp)
200203e4:	10800044 	addi	r2,r2,1
200203e8:	d0a5eb15 	stw	r2,-26708(gp)
200203ec:	00000306 	br	200203fc <timer_interrupt+0x34>
	else
	{
		milliseconds = 0;
200203f0:	d025eb15 	stw	zero,-26708(gp)
		time_elapsed = 1;
200203f4:	00800044 	movi	r2,1
200203f8:	d0a5ec05 	stb	r2,-26704(gp)
	}

	IOWR_ALTERA_AVALON_TIMER_STATUS(CPU_1_0_TIMER_0_BASE, 0x0000); 	// acknowledge interrupt
200203fc:	0007883a 	mov	r3,zero
20020400:	00880134 	movhi	r2,8196
20020404:	10840004 	addi	r2,r2,4096
20020408:	10c00035 	stwio	r3,0(r2)
}
2002040c:	0001883a 	nop
20020410:	e037883a 	mov	sp,fp
20020414:	df000017 	ldw	fp,0(sp)
20020418:	dec00104 	addi	sp,sp,4
2002041c:	f800283a 	ret

20020420 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
20020420:	defff904 	addi	sp,sp,-28
20020424:	dfc00615 	stw	ra,24(sp)
20020428:	df000515 	stw	fp,20(sp)
2002042c:	df000504 	addi	fp,sp,20
20020430:	e13ffc15 	stw	r4,-16(fp)
20020434:	e17ffd15 	stw	r5,-12(fp)
20020438:	e1bffe15 	stw	r6,-8(fp)
2002043c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
20020440:	e0800217 	ldw	r2,8(fp)
20020444:	d8800015 	stw	r2,0(sp)
20020448:	e1ffff17 	ldw	r7,-4(fp)
2002044c:	e1bffe17 	ldw	r6,-8(fp)
20020450:	e17ffd17 	ldw	r5,-12(fp)
20020454:	e13ffc17 	ldw	r4,-16(fp)
20020458:	00205d00 	call	200205d0 <alt_iic_isr_register>
}  
2002045c:	e037883a 	mov	sp,fp
20020460:	dfc00117 	ldw	ra,4(sp)
20020464:	df000017 	ldw	fp,0(sp)
20020468:	dec00204 	addi	sp,sp,8
2002046c:	f800283a 	ret

20020470 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
20020470:	defff904 	addi	sp,sp,-28
20020474:	df000615 	stw	fp,24(sp)
20020478:	df000604 	addi	fp,sp,24
2002047c:	e13ffe15 	stw	r4,-8(fp)
20020480:	e17fff15 	stw	r5,-4(fp)
20020484:	e0bfff17 	ldw	r2,-4(fp)
20020488:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002048c:	0005303a 	rdctl	r2,status
20020490:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20020494:	e0fffb17 	ldw	r3,-20(fp)
20020498:	00bfff84 	movi	r2,-2
2002049c:	1884703a 	and	r2,r3,r2
200204a0:	1001703a 	wrctl	status,r2
  
  return context;
200204a4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
200204a8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
200204ac:	00c00044 	movi	r3,1
200204b0:	e0bffa17 	ldw	r2,-24(fp)
200204b4:	1884983a 	sll	r2,r3,r2
200204b8:	1007883a 	mov	r3,r2
200204bc:	d0a5ee17 	ldw	r2,-26696(gp)
200204c0:	1884b03a 	or	r2,r3,r2
200204c4:	d0a5ee15 	stw	r2,-26696(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
200204c8:	d0a5ee17 	ldw	r2,-26696(gp)
200204cc:	100170fa 	wrctl	ienable,r2
200204d0:	e0bffc17 	ldw	r2,-16(fp)
200204d4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200204d8:	e0bffd17 	ldw	r2,-12(fp)
200204dc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
200204e0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
200204e4:	0001883a 	nop
}
200204e8:	e037883a 	mov	sp,fp
200204ec:	df000017 	ldw	fp,0(sp)
200204f0:	dec00104 	addi	sp,sp,4
200204f4:	f800283a 	ret

200204f8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
200204f8:	defff904 	addi	sp,sp,-28
200204fc:	df000615 	stw	fp,24(sp)
20020500:	df000604 	addi	fp,sp,24
20020504:	e13ffe15 	stw	r4,-8(fp)
20020508:	e17fff15 	stw	r5,-4(fp)
2002050c:	e0bfff17 	ldw	r2,-4(fp)
20020510:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20020514:	0005303a 	rdctl	r2,status
20020518:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2002051c:	e0fffb17 	ldw	r3,-20(fp)
20020520:	00bfff84 	movi	r2,-2
20020524:	1884703a 	and	r2,r3,r2
20020528:	1001703a 	wrctl	status,r2
  
  return context;
2002052c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
20020530:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
20020534:	00c00044 	movi	r3,1
20020538:	e0bffa17 	ldw	r2,-24(fp)
2002053c:	1884983a 	sll	r2,r3,r2
20020540:	0084303a 	nor	r2,zero,r2
20020544:	1007883a 	mov	r3,r2
20020548:	d0a5ee17 	ldw	r2,-26696(gp)
2002054c:	1884703a 	and	r2,r3,r2
20020550:	d0a5ee15 	stw	r2,-26696(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
20020554:	d0a5ee17 	ldw	r2,-26696(gp)
20020558:	100170fa 	wrctl	ienable,r2
2002055c:	e0bffc17 	ldw	r2,-16(fp)
20020560:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20020564:	e0bffd17 	ldw	r2,-12(fp)
20020568:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
2002056c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
20020570:	0001883a 	nop
}
20020574:	e037883a 	mov	sp,fp
20020578:	df000017 	ldw	fp,0(sp)
2002057c:	dec00104 	addi	sp,sp,4
20020580:	f800283a 	ret

20020584 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
20020584:	defffc04 	addi	sp,sp,-16
20020588:	df000315 	stw	fp,12(sp)
2002058c:	df000304 	addi	fp,sp,12
20020590:	e13ffe15 	stw	r4,-8(fp)
20020594:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
20020598:	000530fa 	rdctl	r2,ienable
2002059c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
200205a0:	00c00044 	movi	r3,1
200205a4:	e0bfff17 	ldw	r2,-4(fp)
200205a8:	1884983a 	sll	r2,r3,r2
200205ac:	1007883a 	mov	r3,r2
200205b0:	e0bffd17 	ldw	r2,-12(fp)
200205b4:	1884703a 	and	r2,r3,r2
200205b8:	1004c03a 	cmpne	r2,r2,zero
200205bc:	10803fcc 	andi	r2,r2,255
}
200205c0:	e037883a 	mov	sp,fp
200205c4:	df000017 	ldw	fp,0(sp)
200205c8:	dec00104 	addi	sp,sp,4
200205cc:	f800283a 	ret

200205d0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
200205d0:	defff504 	addi	sp,sp,-44
200205d4:	dfc00a15 	stw	ra,40(sp)
200205d8:	df000915 	stw	fp,36(sp)
200205dc:	df000904 	addi	fp,sp,36
200205e0:	e13ffc15 	stw	r4,-16(fp)
200205e4:	e17ffd15 	stw	r5,-12(fp)
200205e8:	e1bffe15 	stw	r6,-8(fp)
200205ec:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
200205f0:	00bffa84 	movi	r2,-22
200205f4:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
200205f8:	e0bffd17 	ldw	r2,-12(fp)
200205fc:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
20020600:	e0bff817 	ldw	r2,-32(fp)
20020604:	10800808 	cmpgei	r2,r2,32
20020608:	1000271e 	bne	r2,zero,200206a8 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002060c:	0005303a 	rdctl	r2,status
20020610:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20020614:	e0fffb17 	ldw	r3,-20(fp)
20020618:	00bfff84 	movi	r2,-2
2002061c:	1884703a 	and	r2,r3,r2
20020620:	1001703a 	wrctl	status,r2
  
  return context;
20020624:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
20020628:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
2002062c:	008800f4 	movhi	r2,8195
20020630:	10ba0104 	addi	r2,r2,-6140
20020634:	e0fff817 	ldw	r3,-32(fp)
20020638:	180690fa 	slli	r3,r3,3
2002063c:	10c5883a 	add	r2,r2,r3
20020640:	e0fffe17 	ldw	r3,-8(fp)
20020644:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
20020648:	008800f4 	movhi	r2,8195
2002064c:	10ba0104 	addi	r2,r2,-6140
20020650:	e0fff817 	ldw	r3,-32(fp)
20020654:	180690fa 	slli	r3,r3,3
20020658:	10c5883a 	add	r2,r2,r3
2002065c:	10800104 	addi	r2,r2,4
20020660:	e0ffff17 	ldw	r3,-4(fp)
20020664:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
20020668:	e0bffe17 	ldw	r2,-8(fp)
2002066c:	10000526 	beq	r2,zero,20020684 <alt_iic_isr_register+0xb4>
20020670:	e0bff817 	ldw	r2,-32(fp)
20020674:	100b883a 	mov	r5,r2
20020678:	e13ffc17 	ldw	r4,-16(fp)
2002067c:	00204700 	call	20020470 <alt_ic_irq_enable>
20020680:	00000406 	br	20020694 <alt_iic_isr_register+0xc4>
20020684:	e0bff817 	ldw	r2,-32(fp)
20020688:	100b883a 	mov	r5,r2
2002068c:	e13ffc17 	ldw	r4,-16(fp)
20020690:	00204f80 	call	200204f8 <alt_ic_irq_disable>
20020694:	e0bff715 	stw	r2,-36(fp)
20020698:	e0bffa17 	ldw	r2,-24(fp)
2002069c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200206a0:	e0bff917 	ldw	r2,-28(fp)
200206a4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
200206a8:	e0bff717 	ldw	r2,-36(fp)
}
200206ac:	e037883a 	mov	sp,fp
200206b0:	dfc00117 	ldw	ra,4(sp)
200206b4:	df000017 	ldw	fp,0(sp)
200206b8:	dec00204 	addi	sp,sp,8
200206bc:	f800283a 	ret

200206c0 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
200206c0:	defffc04 	addi	sp,sp,-16
200206c4:	df000315 	stw	fp,12(sp)
200206c8:	df000304 	addi	fp,sp,12
200206cc:	e13ffd15 	stw	r4,-12(fp)
200206d0:	e17ffe15 	stw	r5,-8(fp)
200206d4:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
200206d8:	e0fffe17 	ldw	r3,-8(fp)
200206dc:	e0bffd17 	ldw	r2,-12(fp)
200206e0:	18800c26 	beq	r3,r2,20020714 <alt_load_section+0x54>
  {
    while( to != end )
200206e4:	00000806 	br	20020708 <alt_load_section+0x48>
    {
      *to++ = *from++;
200206e8:	e0bffe17 	ldw	r2,-8(fp)
200206ec:	10c00104 	addi	r3,r2,4
200206f0:	e0fffe15 	stw	r3,-8(fp)
200206f4:	e0fffd17 	ldw	r3,-12(fp)
200206f8:	19000104 	addi	r4,r3,4
200206fc:	e13ffd15 	stw	r4,-12(fp)
20020700:	18c00017 	ldw	r3,0(r3)
20020704:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
20020708:	e0fffe17 	ldw	r3,-8(fp)
2002070c:	e0bfff17 	ldw	r2,-4(fp)
20020710:	18bff51e 	bne	r3,r2,200206e8 <__alt_data_end+0xfffe06e8>
    {
      *to++ = *from++;
    }
  }
}
20020714:	0001883a 	nop
20020718:	e037883a 	mov	sp,fp
2002071c:	df000017 	ldw	fp,0(sp)
20020720:	dec00104 	addi	sp,sp,4
20020724:	f800283a 	ret

20020728 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
20020728:	defffe04 	addi	sp,sp,-8
2002072c:	dfc00115 	stw	ra,4(sp)
20020730:	df000015 	stw	fp,0(sp)
20020734:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
20020738:	018800f4 	movhi	r6,8195
2002073c:	31b21e04 	addi	r6,r6,-14216
20020740:	014800f4 	movhi	r5,8195
20020744:	296c5f04 	addi	r5,r5,-20100
20020748:	010800f4 	movhi	r4,8195
2002074c:	21321e04 	addi	r4,r4,-14216
20020750:	00206c00 	call	200206c0 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
20020754:	018800b4 	movhi	r6,8194
20020758:	31809104 	addi	r6,r6,580
2002075c:	014800b4 	movhi	r5,8194
20020760:	29400804 	addi	r5,r5,32
20020764:	010800b4 	movhi	r4,8194
20020768:	21000804 	addi	r4,r4,32
2002076c:	00206c00 	call	200206c0 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
20020770:	018800f4 	movhi	r6,8195
20020774:	31ac5f04 	addi	r6,r6,-20100
20020778:	014800f4 	movhi	r5,8195
2002077c:	296bfc04 	addi	r5,r5,-20496
20020780:	010800f4 	movhi	r4,8195
20020784:	212bfc04 	addi	r4,r4,-20496
20020788:	00206c00 	call	200206c0 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
2002078c:	00298a00 	call	200298a0 <alt_dcache_flush_all>
  alt_icache_flush_all();
20020790:	0029b440 	call	20029b44 <alt_icache_flush_all>
}
20020794:	0001883a 	nop
20020798:	e037883a 	mov	sp,fp
2002079c:	dfc00117 	ldw	ra,4(sp)
200207a0:	df000017 	ldw	fp,0(sp)
200207a4:	dec00204 	addi	sp,sp,8
200207a8:	f800283a 	ret

200207ac <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
200207ac:	defff904 	addi	sp,sp,-28
200207b0:	dfc00615 	stw	ra,24(sp)
200207b4:	df000515 	stw	fp,20(sp)
200207b8:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
200207bc:	0009883a 	mov	r4,zero
200207c0:	00284540 	call	20028454 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
200207c4:	00213e80 	call	200213e8 <OSInit>
200207c8:	01000044 	movi	r4,1
200207cc:	0025d380 	call	20025d38 <OSSemCreate>
200207d0:	d0a5f315 	stw	r2,-26676(gp)
200207d4:	01000044 	movi	r4,1
200207d8:	0025d380 	call	20025d38 <OSSemCreate>
200207dc:	d0a5f515 	stw	r2,-26668(gp)
200207e0:	d0a60a04 	addi	r2,gp,-26584
200207e4:	e0bffc15 	stw	r2,-16(fp)
200207e8:	00800044 	movi	r2,1
200207ec:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
200207f0:	e0bffd0b 	ldhu	r2,-12(fp)
200207f4:	1009883a 	mov	r4,r2
200207f8:	0025d380 	call	20025d38 <OSSemCreate>
200207fc:	1007883a 	mov	r3,r2
20020800:	e0bffc17 	ldw	r2,-16(fp)
20020804:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
20020808:	002848c0 	call	2002848c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
2002080c:	018800f4 	movhi	r6,8195
20020810:	31ac0004 	addi	r6,r6,-20480
20020814:	014800f4 	movhi	r5,8195
20020818:	296c0004 	addi	r5,r5,-20480
2002081c:	010800f4 	movhi	r4,8195
20020820:	212c0004 	addi	r4,r4,-20480
20020824:	0029cd80 	call	20029cd8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
20020828:	00299f40 	call	200299f4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
2002082c:	010800f4 	movhi	r4,8195
20020830:	21269504 	addi	r4,r4,-26028
20020834:	002a7a00 	call	2002a7a0 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
20020838:	d0a5ef17 	ldw	r2,-26692(gp)
2002083c:	d0e5f017 	ldw	r3,-26688(gp)
20020840:	d125f117 	ldw	r4,-26684(gp)
20020844:	200d883a 	mov	r6,r4
20020848:	180b883a 	mov	r5,r3
2002084c:	1009883a 	mov	r4,r2
20020850:	00203100 	call	20020310 <main>
20020854:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
20020858:	01000044 	movi	r4,1
2002085c:	00297d00 	call	200297d0 <close>
  exit (result);
20020860:	e13ffb17 	ldw	r4,-20(fp)
20020864:	002a7b40 	call	2002a7b4 <exit>

20020868 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
20020868:	deffdf04 	addi	sp,sp,-132
2002086c:	dfc02015 	stw	ra,128(sp)
20020870:	df001f15 	stw	fp,124(sp)
20020874:	df001f04 	addi	fp,sp,124
20020878:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
2002087c:	e0bfe204 	addi	r2,fp,-120
20020880:	100b883a 	mov	r5,r2
20020884:	01003fc4 	movi	r4,255
20020888:	0027cc00 	call	20027cc0 <OSTaskQuery>
2002088c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
20020890:	e0bffe83 	ldbu	r2,-6(fp)
20020894:	10803fcc 	andi	r2,r2,255
20020898:	10001e1e 	bne	r2,zero,20020914 <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
2002089c:	e0bfee83 	ldbu	r2,-70(fp)
200208a0:	10803fcc 	andi	r2,r2,255
200208a4:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
200208a8:	d0a5f317 	ldw	r2,-26676(gp)
200208ac:	e0fffd04 	addi	r3,fp,-12
200208b0:	180b883a 	mov	r5,r3
200208b4:	1009883a 	mov	r4,r2
200208b8:	00264d80 	call	200264d8 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
200208bc:	e0bffe43 	ldbu	r2,-7(fp)
200208c0:	10803fcc 	andi	r2,r2,255
200208c4:	10000726 	beq	r2,zero,200208e4 <__env_lock+0x7c>
200208c8:	d0a00117 	ldw	r2,-32764(gp)
200208cc:	e0ffe117 	ldw	r3,-124(fp)
200208d0:	1880041e 	bne	r3,r2,200208e4 <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
200208d4:	d0a5f217 	ldw	r2,-26680(gp)
200208d8:	10800044 	addi	r2,r2,1
200208dc:	d0a5f215 	stw	r2,-26680(gp)
200208e0:	00000a06 	br	2002090c <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
200208e4:	d0a5f317 	ldw	r2,-26676(gp)
200208e8:	e0fffe84 	addi	r3,fp,-6
200208ec:	180d883a 	mov	r6,r3
200208f0:	000b883a 	mov	r5,zero
200208f4:	1009883a 	mov	r4,r2
200208f8:	00260500 	call	20026050 <OSSemPend>
    locks  = 1;
200208fc:	00800044 	movi	r2,1
20020900:	d0a5f215 	stw	r2,-26680(gp)
    lockid = id;
20020904:	e0bfe117 	ldw	r2,-124(fp)
20020908:	d0a00115 	stw	r2,-32764(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
2002090c:	0001883a 	nop
20020910:	00000106 	br	20020918 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
20020914:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
20020918:	e037883a 	mov	sp,fp
2002091c:	dfc00117 	ldw	ra,4(sp)
20020920:	df000017 	ldw	fp,0(sp)
20020924:	dec00204 	addi	sp,sp,8
20020928:	f800283a 	ret

2002092c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
2002092c:	defffd04 	addi	sp,sp,-12
20020930:	dfc00215 	stw	ra,8(sp)
20020934:	df000115 	stw	fp,4(sp)
20020938:	df000104 	addi	fp,sp,4
2002093c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
20020940:	d0a5f217 	ldw	r2,-26680(gp)
20020944:	10000b26 	beq	r2,zero,20020974 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
20020948:	d0a5f217 	ldw	r2,-26680(gp)
2002094c:	10bfffc4 	addi	r2,r2,-1
20020950:	d0a5f215 	stw	r2,-26680(gp)
20020954:	d0a5f217 	ldw	r2,-26680(gp)
20020958:	1000071e 	bne	r2,zero,20020978 <__env_unlock+0x4c>
  {
    lockid = -1;
2002095c:	00bfffc4 	movi	r2,-1
20020960:	d0a00115 	stw	r2,-32764(gp)
    OSSemPost( alt_envsem );
20020964:	d0a5f317 	ldw	r2,-26676(gp)
20020968:	1009883a 	mov	r4,r2
2002096c:	00263c80 	call	200263c8 <OSSemPost>
20020970:	00000106 	br	20020978 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
20020974:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
20020978:	e037883a 	mov	sp,fp
2002097c:	dfc00117 	ldw	ra,4(sp)
20020980:	df000017 	ldw	fp,0(sp)
20020984:	dec00204 	addi	sp,sp,8
20020988:	f800283a 	ret

2002098c <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
2002098c:	deffdb04 	addi	sp,sp,-148
20020990:	dfc02415 	stw	ra,144(sp)
20020994:	df002315 	stw	fp,140(sp)
20020998:	df002304 	addi	fp,sp,140
2002099c:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200209a0:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
200209a4:	d0a5f643 	ldbu	r2,-26663(gp)
200209a8:	10803fcc 	andi	r2,r2,255
200209ac:	10800060 	cmpeqi	r2,r2,1
200209b0:	10003626 	beq	r2,zero,20020a8c <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
200209b4:	e0bfe204 	addi	r2,fp,-120
200209b8:	100b883a 	mov	r5,r2
200209bc:	01003fc4 	movi	r4,255
200209c0:	0027cc00 	call	20027cc0 <OSTaskQuery>
200209c4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
200209c8:	e0bffe83 	ldbu	r2,-6(fp)
200209cc:	10803fcc 	andi	r2,r2,255
200209d0:	1000301e 	bne	r2,zero,20020a94 <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
200209d4:	e0bfee83 	ldbu	r2,-70(fp)
200209d8:	10803fcc 	andi	r2,r2,255
200209dc:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
200209e0:	d0a5f517 	ldw	r2,-26668(gp)
200209e4:	e0fffd04 	addi	r3,fp,-12
200209e8:	180b883a 	mov	r5,r3
200209ec:	1009883a 	mov	r4,r2
200209f0:	00264d80 	call	200264d8 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200209f4:	0005303a 	rdctl	r2,status
200209f8:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200209fc:	e0ffe117 	ldw	r3,-124(fp)
20020a00:	00bfff84 	movi	r2,-2
20020a04:	1884703a 	and	r2,r3,r2
20020a08:	1001703a 	wrctl	status,r2
  
  return context;
20020a0c:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
20020a10:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
20020a14:	e0bffd0b 	ldhu	r2,-12(fp)
20020a18:	10bfffcc 	andi	r2,r2,65535
20020a1c:	10000b1e 	bne	r2,zero,20020a4c <__malloc_lock+0xc0>
20020a20:	d0a00217 	ldw	r2,-32760(gp)
20020a24:	e0ffde17 	ldw	r3,-136(fp)
20020a28:	1880081e 	bne	r3,r2,20020a4c <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
20020a2c:	d0a5f417 	ldw	r2,-26672(gp)
20020a30:	10800044 	addi	r2,r2,1
20020a34:	d0a5f415 	stw	r2,-26672(gp)
20020a38:	e0bfdd17 	ldw	r2,-140(fp)
20020a3c:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20020a40:	e0bfdf17 	ldw	r2,-132(fp)
20020a44:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
20020a48:	00000e06 	br	20020a84 <__malloc_lock+0xf8>
20020a4c:	e0bfdd17 	ldw	r2,-140(fp)
20020a50:	e0bfe015 	stw	r2,-128(fp)
20020a54:	e0bfe017 	ldw	r2,-128(fp)
20020a58:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
20020a5c:	d0a5f517 	ldw	r2,-26668(gp)
20020a60:	e0fffe84 	addi	r3,fp,-6
20020a64:	180d883a 	mov	r6,r3
20020a68:	000b883a 	mov	r5,zero
20020a6c:	1009883a 	mov	r4,r2
20020a70:	00260500 	call	20026050 <OSSemPend>
    locks  = 1;
20020a74:	00800044 	movi	r2,1
20020a78:	d0a5f415 	stw	r2,-26672(gp)
    lockid = id;
20020a7c:	e0bfde17 	ldw	r2,-136(fp)
20020a80:	d0a00215 	stw	r2,-32760(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
20020a84:	0001883a 	nop
20020a88:	00000306 	br	20020a98 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
20020a8c:	0001883a 	nop
20020a90:	00000106 	br	20020a98 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
20020a94:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
20020a98:	e037883a 	mov	sp,fp
20020a9c:	dfc00117 	ldw	ra,4(sp)
20020aa0:	df000017 	ldw	fp,0(sp)
20020aa4:	dec00204 	addi	sp,sp,8
20020aa8:	f800283a 	ret

20020aac <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
20020aac:	defff804 	addi	sp,sp,-32
20020ab0:	dfc00715 	stw	ra,28(sp)
20020ab4:	df000615 	stw	fp,24(sp)
20020ab8:	df000604 	addi	fp,sp,24
20020abc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20020ac0:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
20020ac4:	d0a5f643 	ldbu	r2,-26663(gp)
20020ac8:	10803fcc 	andi	r2,r2,255
20020acc:	10800060 	cmpeqi	r2,r2,1
20020ad0:	10002326 	beq	r2,zero,20020b60 <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20020ad4:	0005303a 	rdctl	r2,status
20020ad8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20020adc:	e0fffe17 	ldw	r3,-8(fp)
20020ae0:	00bfff84 	movi	r2,-2
20020ae4:	1884703a 	and	r2,r3,r2
20020ae8:	1001703a 	wrctl	status,r2
  
  return context;
20020aec:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
20020af0:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
20020af4:	d0a5f417 	ldw	r2,-26672(gp)
20020af8:	1000051e 	bne	r2,zero,20020b10 <__malloc_unlock+0x64>
20020afc:	e0bffa17 	ldw	r2,-24(fp)
20020b00:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20020b04:	e0bffb17 	ldw	r2,-20(fp)
20020b08:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
20020b0c:	00001506 	br	20020b64 <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
20020b10:	d0a5f417 	ldw	r2,-26672(gp)
20020b14:	10bfffc4 	addi	r2,r2,-1
20020b18:	d0a5f415 	stw	r2,-26672(gp)
20020b1c:	d0a5f417 	ldw	r2,-26672(gp)
20020b20:	10000a1e 	bne	r2,zero,20020b4c <__malloc_unlock+0xa0>
  {
    lockid = -1;
20020b24:	00bfffc4 	movi	r2,-1
20020b28:	d0a00215 	stw	r2,-32760(gp)
20020b2c:	e0bffa17 	ldw	r2,-24(fp)
20020b30:	e0bffc15 	stw	r2,-16(fp)
20020b34:	e0bffc17 	ldw	r2,-16(fp)
20020b38:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
20020b3c:	d0a5f517 	ldw	r2,-26668(gp)
20020b40:	1009883a 	mov	r4,r2
20020b44:	00263c80 	call	200263c8 <OSSemPost>
20020b48:	00000606 	br	20020b64 <__malloc_unlock+0xb8>
20020b4c:	e0bffa17 	ldw	r2,-24(fp)
20020b50:	e0bffd15 	stw	r2,-12(fp)
20020b54:	e0bffd17 	ldw	r2,-12(fp)
20020b58:	1001703a 	wrctl	status,r2
20020b5c:	00000106 	br	20020b64 <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
20020b60:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
20020b64:	e037883a 	mov	sp,fp
20020b68:	dfc00117 	ldw	ra,4(sp)
20020b6c:	df000017 	ldw	fp,0(sp)
20020b70:	dec00204 	addi	sp,sp,8
20020b74:	f800283a 	ret

20020b78 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
20020b78:	defff704 	addi	sp,sp,-36
20020b7c:	dfc00815 	stw	ra,32(sp)
20020b80:	df000715 	stw	fp,28(sp)
20020b84:	df000704 	addi	fp,sp,28
20020b88:	e13ffd15 	stw	r4,-12(fp)
20020b8c:	e17ffe15 	stw	r5,-8(fp)
20020b90:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20020b94:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20020b98:	e0bfff17 	ldw	r2,-4(fp)
20020b9c:	1000021e 	bne	r2,zero,20020ba8 <OSEventNameGet+0x30>
        return (0);
20020ba0:	0005883a 	mov	r2,zero
20020ba4:	00003706 	br	20020c84 <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
20020ba8:	e0bffd17 	ldw	r2,-12(fp)
20020bac:	1000051e 	bne	r2,zero,20020bc4 <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
20020bb0:	e0bfff17 	ldw	r2,-4(fp)
20020bb4:	00c00104 	movi	r3,4
20020bb8:	10c00005 	stb	r3,0(r2)
        return (0);
20020bbc:	0005883a 	mov	r2,zero
20020bc0:	00003006 	br	20020c84 <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
20020bc4:	e0bffe17 	ldw	r2,-8(fp)
20020bc8:	1000051e 	bne	r2,zero,20020be0 <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
20020bcc:	e0bfff17 	ldw	r2,-4(fp)
20020bd0:	00c00304 	movi	r3,12
20020bd4:	10c00005 	stb	r3,0(r2)
        return (0);
20020bd8:	0005883a 	mov	r2,zero
20020bdc:	00002906 	br	20020c84 <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
20020be0:	d0a60403 	ldbu	r2,-26608(gp)
20020be4:	10803fcc 	andi	r2,r2,255
20020be8:	10000526 	beq	r2,zero,20020c00 <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
20020bec:	e0bfff17 	ldw	r2,-4(fp)
20020bf0:	00c00444 	movi	r3,17
20020bf4:	10c00005 	stb	r3,0(r2)
        return (0);
20020bf8:	0005883a 	mov	r2,zero
20020bfc:	00002106 	br	20020c84 <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
20020c00:	e0bffd17 	ldw	r2,-12(fp)
20020c04:	10800003 	ldbu	r2,0(r2)
20020c08:	10803fcc 	andi	r2,r2,255
20020c0c:	10bfffc4 	addi	r2,r2,-1
20020c10:	10800128 	cmpgeui	r2,r2,4
20020c14:	10000526 	beq	r2,zero,20020c2c <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
20020c18:	e0bfff17 	ldw	r2,-4(fp)
20020c1c:	00c00044 	movi	r3,1
20020c20:	10c00005 	stb	r3,0(r2)
             return (0);
20020c24:	0005883a 	mov	r2,zero
20020c28:	00001606 	br	20020c84 <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
20020c2c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20020c30:	0005303a 	rdctl	r2,status
20020c34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20020c38:	e0fffb17 	ldw	r3,-20(fp)
20020c3c:	00bfff84 	movi	r2,-2
20020c40:	1884703a 	and	r2,r3,r2
20020c44:	1001703a 	wrctl	status,r2
  
  return context;
20020c48:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
20020c4c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
20020c50:	e0bffd17 	ldw	r2,-12(fp)
20020c54:	10800384 	addi	r2,r2,14
20020c58:	100b883a 	mov	r5,r2
20020c5c:	e13ffe17 	ldw	r4,-8(fp)
20020c60:	00225fc0 	call	200225fc <OS_StrCopy>
20020c64:	e0bffa05 	stb	r2,-24(fp)
20020c68:	e0bff917 	ldw	r2,-28(fp)
20020c6c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20020c70:	e0bffc17 	ldw	r2,-16(fp)
20020c74:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20020c78:	e0bfff17 	ldw	r2,-4(fp)
20020c7c:	10000005 	stb	zero,0(r2)
    return (len);
20020c80:	e0bffa03 	ldbu	r2,-24(fp)
}
20020c84:	e037883a 	mov	sp,fp
20020c88:	dfc00117 	ldw	ra,4(sp)
20020c8c:	df000017 	ldw	fp,0(sp)
20020c90:	dec00204 	addi	sp,sp,8
20020c94:	f800283a 	ret

20020c98 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
20020c98:	defff604 	addi	sp,sp,-40
20020c9c:	dfc00915 	stw	ra,36(sp)
20020ca0:	df000815 	stw	fp,32(sp)
20020ca4:	df000804 	addi	fp,sp,32
20020ca8:	e13ffd15 	stw	r4,-12(fp)
20020cac:	e17ffe15 	stw	r5,-8(fp)
20020cb0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20020cb4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20020cb8:	e0bfff17 	ldw	r2,-4(fp)
20020cbc:	10004026 	beq	r2,zero,20020dc0 <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
20020cc0:	e0bffd17 	ldw	r2,-12(fp)
20020cc4:	1000041e 	bne	r2,zero,20020cd8 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
20020cc8:	e0bfff17 	ldw	r2,-4(fp)
20020ccc:	00c00104 	movi	r3,4
20020cd0:	10c00005 	stb	r3,0(r2)
        return;
20020cd4:	00003b06 	br	20020dc4 <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
20020cd8:	e0bffe17 	ldw	r2,-8(fp)
20020cdc:	1000041e 	bne	r2,zero,20020cf0 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
20020ce0:	e0bfff17 	ldw	r2,-4(fp)
20020ce4:	00c00304 	movi	r3,12
20020ce8:	10c00005 	stb	r3,0(r2)
        return;
20020cec:	00003506 	br	20020dc4 <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
20020cf0:	d0a60403 	ldbu	r2,-26608(gp)
20020cf4:	10803fcc 	andi	r2,r2,255
20020cf8:	10000426 	beq	r2,zero,20020d0c <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
20020cfc:	e0bfff17 	ldw	r2,-4(fp)
20020d00:	00c00484 	movi	r3,18
20020d04:	10c00005 	stb	r3,0(r2)
        return;
20020d08:	00002e06 	br	20020dc4 <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
20020d0c:	e0bffd17 	ldw	r2,-12(fp)
20020d10:	10800003 	ldbu	r2,0(r2)
20020d14:	10803fcc 	andi	r2,r2,255
20020d18:	10bfffc4 	addi	r2,r2,-1
20020d1c:	10800128 	cmpgeui	r2,r2,4
20020d20:	10000426 	beq	r2,zero,20020d34 <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
20020d24:	e0bfff17 	ldw	r2,-4(fp)
20020d28:	00c00044 	movi	r3,1
20020d2c:	10c00005 	stb	r3,0(r2)
             return;
20020d30:	00002406 	br	20020dc4 <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
20020d34:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20020d38:	0005303a 	rdctl	r2,status
20020d3c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20020d40:	e0fffc17 	ldw	r3,-16(fp)
20020d44:	00bfff84 	movi	r2,-2
20020d48:	1884703a 	and	r2,r3,r2
20020d4c:	1001703a 	wrctl	status,r2
  
  return context;
20020d50:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
20020d54:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
20020d58:	e13ffe17 	ldw	r4,-8(fp)
20020d5c:	00226700 	call	20022670 <OS_StrLen>
20020d60:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
20020d64:	e0bffa03 	ldbu	r2,-24(fp)
20020d68:	10800830 	cmpltui	r2,r2,32
20020d6c:	1000081e 	bne	r2,zero,20020d90 <OSEventNameSet+0xf8>
20020d70:	e0bff817 	ldw	r2,-32(fp)
20020d74:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20020d78:	e0bff917 	ldw	r2,-28(fp)
20020d7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
20020d80:	e0bfff17 	ldw	r2,-4(fp)
20020d84:	00c002c4 	movi	r3,11
20020d88:	10c00005 	stb	r3,0(r2)
        return;
20020d8c:	00000d06 	br	20020dc4 <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
20020d90:	e0bffd17 	ldw	r2,-12(fp)
20020d94:	10800384 	addi	r2,r2,14
20020d98:	e17ffe17 	ldw	r5,-8(fp)
20020d9c:	1009883a 	mov	r4,r2
20020da0:	00225fc0 	call	200225fc <OS_StrCopy>
20020da4:	e0bff817 	ldw	r2,-32(fp)
20020da8:	e0bffb15 	stw	r2,-20(fp)
20020dac:	e0bffb17 	ldw	r2,-20(fp)
20020db0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20020db4:	e0bfff17 	ldw	r2,-4(fp)
20020db8:	10000005 	stb	zero,0(r2)
20020dbc:	00000106 	br	20020dc4 <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
20020dc0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
20020dc4:	e037883a 	mov	sp,fp
20020dc8:	dfc00117 	ldw	ra,4(sp)
20020dcc:	df000017 	ldw	fp,0(sp)
20020dd0:	dec00204 	addi	sp,sp,8
20020dd4:	f800283a 	ret

20020dd8 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
20020dd8:	deffed04 	addi	sp,sp,-76
20020ddc:	dfc01215 	stw	ra,72(sp)
20020de0:	df001115 	stw	fp,68(sp)
20020de4:	df001104 	addi	fp,sp,68
20020de8:	e13ffc15 	stw	r4,-16(fp)
20020dec:	e17ffd15 	stw	r5,-12(fp)
20020df0:	e1bffe15 	stw	r6,-8(fp)
20020df4:	3805883a 	mov	r2,r7
20020df8:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
20020dfc:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
20020e00:	e0800217 	ldw	r2,8(fp)
20020e04:	1000021e 	bne	r2,zero,20020e10 <OSEventPendMulti+0x38>
        return (0);
20020e08:	0005883a 	mov	r2,zero
20020e0c:	00017106 	br	200213d4 <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
20020e10:	e0bffc17 	ldw	r2,-16(fp)
20020e14:	1000051e 	bne	r2,zero,20020e2c <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
20020e18:	e0800217 	ldw	r2,8(fp)
20020e1c:	00c00104 	movi	r3,4
20020e20:	10c00005 	stb	r3,0(r2)
        return (0);
20020e24:	0005883a 	mov	r2,zero
20020e28:	00016a06 	br	200213d4 <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
20020e2c:	e0bffd17 	ldw	r2,-12(fp)
20020e30:	1000051e 	bne	r2,zero,20020e48 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
20020e34:	e0800217 	ldw	r2,8(fp)
20020e38:	00c00104 	movi	r3,4
20020e3c:	10c00005 	stb	r3,0(r2)
        return (0);
20020e40:	0005883a 	mov	r2,zero
20020e44:	00016306 	br	200213d4 <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
20020e48:	e0bffe17 	ldw	r2,-8(fp)
20020e4c:	1000051e 	bne	r2,zero,20020e64 <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
20020e50:	e0800217 	ldw	r2,8(fp)
20020e54:	00c00104 	movi	r3,4
20020e58:	10c00005 	stb	r3,0(r2)
        return (0);
20020e5c:	0005883a 	mov	r2,zero
20020e60:	00015c06 	br	200213d4 <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
20020e64:	e0bffd17 	ldw	r2,-12(fp)
20020e68:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
20020e6c:	e0bffc17 	ldw	r2,-16(fp)
20020e70:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
20020e74:	e0bfef17 	ldw	r2,-68(fp)
20020e78:	10800017 	ldw	r2,0(r2)
20020e7c:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
20020e80:	00001906 	br	20020ee8 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
20020e84:	e0bff017 	ldw	r2,-64(fp)
20020e88:	10800003 	ldbu	r2,0(r2)
20020e8c:	10803fcc 	andi	r2,r2,255
20020e90:	10c000a0 	cmpeqi	r3,r2,2
20020e94:	1800091e 	bne	r3,zero,20020ebc <OSEventPendMulti+0xe4>
20020e98:	10c000e0 	cmpeqi	r3,r2,3
20020e9c:	1800091e 	bne	r3,zero,20020ec4 <OSEventPendMulti+0xec>
20020ea0:	10800060 	cmpeqi	r2,r2,1
20020ea4:	1000091e 	bne	r2,zero,20020ecc <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
20020ea8:	e0800217 	ldw	r2,8(fp)
20020eac:	00c00044 	movi	r3,1
20020eb0:	10c00005 	stb	r3,0(r2)
                 return (0);
20020eb4:	0005883a 	mov	r2,zero
20020eb8:	00014606 	br	200213d4 <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
20020ebc:	0001883a 	nop
20020ec0:	00000306 	br	20020ed0 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
20020ec4:	0001883a 	nop
20020ec8:	00000106 	br	20020ed0 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
20020ecc:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
20020ed0:	e0bfef17 	ldw	r2,-68(fp)
20020ed4:	10800104 	addi	r2,r2,4
20020ed8:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
20020edc:	e0bfef17 	ldw	r2,-68(fp)
20020ee0:	10800017 	ldw	r2,0(r2)
20020ee4:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
20020ee8:	e0bff017 	ldw	r2,-64(fp)
20020eec:	103fe51e 	bne	r2,zero,20020e84 <__alt_data_end+0xfffe0e84>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
20020ef0:	d0a60403 	ldbu	r2,-26608(gp)
20020ef4:	10803fcc 	andi	r2,r2,255
20020ef8:	10000526 	beq	r2,zero,20020f10 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
20020efc:	e0800217 	ldw	r2,8(fp)
20020f00:	00c00084 	movi	r3,2
20020f04:	10c00005 	stb	r3,0(r2)
        return (0);
20020f08:	0005883a 	mov	r2,zero
20020f0c:	00013106 	br	200213d4 <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
20020f10:	d0a5f603 	ldbu	r2,-26664(gp)
20020f14:	10803fcc 	andi	r2,r2,255
20020f18:	10000526 	beq	r2,zero,20020f30 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
20020f1c:	e0800217 	ldw	r2,8(fp)
20020f20:	00c00344 	movi	r3,13
20020f24:	10c00005 	stb	r3,0(r2)
        return (0);
20020f28:	0005883a 	mov	r2,zero
20020f2c:	00012906 	br	200213d4 <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20020f30:	0005303a 	rdctl	r2,status
20020f34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20020f38:	e0fffb17 	ldw	r3,-20(fp)
20020f3c:	00bfff84 	movi	r2,-2
20020f40:	1884703a 	and	r2,r3,r2
20020f44:	1001703a 	wrctl	status,r2
  
  return context;
20020f48:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
20020f4c:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
20020f50:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
20020f54:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
20020f58:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
20020f5c:	e0bffc17 	ldw	r2,-16(fp)
20020f60:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
20020f64:	e0bfef17 	ldw	r2,-68(fp)
20020f68:	10800017 	ldw	r2,0(r2)
20020f6c:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
20020f70:	00008106 	br	20021178 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
20020f74:	e0bff017 	ldw	r2,-64(fp)
20020f78:	10800003 	ldbu	r2,0(r2)
20020f7c:	10803fcc 	andi	r2,r2,255
20020f80:	10c000a0 	cmpeqi	r3,r2,2
20020f84:	18003c1e 	bne	r3,zero,20021078 <OSEventPendMulti+0x2a0>
20020f88:	10c000e0 	cmpeqi	r3,r2,3
20020f8c:	1800031e 	bne	r3,zero,20020f9c <OSEventPendMulti+0x1c4>
20020f90:	10800060 	cmpeqi	r2,r2,1
20020f94:	10001e1e 	bne	r2,zero,20021010 <OSEventPendMulti+0x238>
20020f98:	00006606 	br	20021134 <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
20020f9c:	e0bff017 	ldw	r2,-64(fp)
20020fa0:	1080020b 	ldhu	r2,8(r2)
20020fa4:	10bfffcc 	andi	r2,r2,65535
20020fa8:	10001526 	beq	r2,zero,20021000 <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
20020fac:	e0bff017 	ldw	r2,-64(fp)
20020fb0:	1080020b 	ldhu	r2,8(r2)
20020fb4:	10bfffc4 	addi	r2,r2,-1
20020fb8:	1007883a 	mov	r3,r2
20020fbc:	e0bff017 	ldw	r2,-64(fp)
20020fc0:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
20020fc4:	e0bffd17 	ldw	r2,-12(fp)
20020fc8:	10c00104 	addi	r3,r2,4
20020fcc:	e0fffd15 	stw	r3,-12(fp)
20020fd0:	e0fff017 	ldw	r3,-64(fp)
20020fd4:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
20020fd8:	00800044 	movi	r2,1
20020fdc:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
20020fe0:	e0bffe17 	ldw	r2,-8(fp)
20020fe4:	10c00104 	addi	r3,r2,4
20020fe8:	e0fffe15 	stw	r3,-8(fp)
20020fec:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
20020ff0:	e0bff18b 	ldhu	r2,-58(fp)
20020ff4:	10800044 	addi	r2,r2,1
20020ff8:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
20020ffc:	00005806 	br	20021160 <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
20021000:	e0bff203 	ldbu	r2,-56(fp)
20021004:	10800054 	ori	r2,r2,1
20021008:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
2002100c:	00005406 	br	20021160 <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
20021010:	e0bff017 	ldw	r2,-64(fp)
20021014:	10800117 	ldw	r2,4(r2)
20021018:	10001326 	beq	r2,zero,20021068 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
2002101c:	e0bffe17 	ldw	r2,-8(fp)
20021020:	10c00104 	addi	r3,r2,4
20021024:	e0fffe15 	stw	r3,-8(fp)
20021028:	e0fff017 	ldw	r3,-64(fp)
2002102c:	18c00117 	ldw	r3,4(r3)
20021030:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
20021034:	e0bff017 	ldw	r2,-64(fp)
20021038:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
2002103c:	e0bffd17 	ldw	r2,-12(fp)
20021040:	10c00104 	addi	r3,r2,4
20021044:	e0fffd15 	stw	r3,-12(fp)
20021048:	e0fff017 	ldw	r3,-64(fp)
2002104c:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
20021050:	00800044 	movi	r2,1
20021054:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
20021058:	e0bff18b 	ldhu	r2,-58(fp)
2002105c:	10800044 	addi	r2,r2,1
20021060:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
20021064:	00003e06 	br	20021160 <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
20021068:	e0bff203 	ldbu	r2,-56(fp)
2002106c:	10800094 	ori	r2,r2,2
20021070:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
20021074:	00003a06 	br	20021160 <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
20021078:	e0bff017 	ldw	r2,-64(fp)
2002107c:	10800117 	ldw	r2,4(r2)
20021080:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
20021084:	e0bff517 	ldw	r2,-44(fp)
20021088:	1080058b 	ldhu	r2,22(r2)
2002108c:	10bfffcc 	andi	r2,r2,65535
20021090:	10002426 	beq	r2,zero,20021124 <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
20021094:	e0bffe17 	ldw	r2,-8(fp)
20021098:	10c00104 	addi	r3,r2,4
2002109c:	e0fffe15 	stw	r3,-8(fp)
200210a0:	e0fff517 	ldw	r3,-44(fp)
200210a4:	18c00417 	ldw	r3,16(r3)
200210a8:	19400104 	addi	r5,r3,4
200210ac:	e13ff517 	ldw	r4,-44(fp)
200210b0:	21400415 	stw	r5,16(r4)
200210b4:	18c00017 	ldw	r3,0(r3)
200210b8:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
200210bc:	e0bff517 	ldw	r2,-44(fp)
200210c0:	10c00417 	ldw	r3,16(r2)
200210c4:	e0bff517 	ldw	r2,-44(fp)
200210c8:	10800217 	ldw	r2,8(r2)
200210cc:	1880041e 	bne	r3,r2,200210e0 <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
200210d0:	e0bff517 	ldw	r2,-44(fp)
200210d4:	10c00117 	ldw	r3,4(r2)
200210d8:	e0bff517 	ldw	r2,-44(fp)
200210dc:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
200210e0:	e0bff517 	ldw	r2,-44(fp)
200210e4:	1080058b 	ldhu	r2,22(r2)
200210e8:	10bfffc4 	addi	r2,r2,-1
200210ec:	1007883a 	mov	r3,r2
200210f0:	e0bff517 	ldw	r2,-44(fp)
200210f4:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
200210f8:	e0bffd17 	ldw	r2,-12(fp)
200210fc:	10c00104 	addi	r3,r2,4
20021100:	e0fffd15 	stw	r3,-12(fp)
20021104:	e0fff017 	ldw	r3,-64(fp)
20021108:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
2002110c:	00800044 	movi	r2,1
20021110:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
20021114:	e0bff18b 	ldhu	r2,-58(fp)
20021118:	10800044 	addi	r2,r2,1
2002111c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
20021120:	00000f06 	br	20021160 <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
20021124:	e0bff203 	ldbu	r2,-56(fp)
20021128:	10800114 	ori	r2,r2,4
2002112c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
20021130:	00000b06 	br	20021160 <OSEventPendMulti+0x388>
20021134:	e0bff317 	ldw	r2,-52(fp)
20021138:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002113c:	e0bff417 	ldw	r2,-48(fp)
20021140:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
20021144:	e0bffd17 	ldw	r2,-12(fp)
20021148:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
2002114c:	e0800217 	ldw	r2,8(fp)
20021150:	00c00044 	movi	r3,1
20021154:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
20021158:	e0bff18b 	ldhu	r2,-58(fp)
2002115c:	00009d06 	br	200213d4 <OSEventPendMulti+0x5fc>
        }
        pevents++;
20021160:	e0bfef17 	ldw	r2,-68(fp)
20021164:	10800104 	addi	r2,r2,4
20021168:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
2002116c:	e0bfef17 	ldw	r2,-68(fp)
20021170:	10800017 	ldw	r2,0(r2)
20021174:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
20021178:	e0bff017 	ldw	r2,-64(fp)
2002117c:	103f7d1e 	bne	r2,zero,20020f74 <__alt_data_end+0xfffe0f74>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
20021180:	e0bff103 	ldbu	r2,-60(fp)
20021184:	10800058 	cmpnei	r2,r2,1
20021188:	10000a1e 	bne	r2,zero,200211b4 <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
2002118c:	e0bffd17 	ldw	r2,-12(fp)
20021190:	10000015 	stw	zero,0(r2)
20021194:	e0bff317 	ldw	r2,-52(fp)
20021198:	e0bff615 	stw	r2,-40(fp)
2002119c:	e0bff617 	ldw	r2,-40(fp)
200211a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
200211a4:	e0800217 	ldw	r2,8(fp)
200211a8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
200211ac:	e0bff18b 	ldhu	r2,-58(fp)
200211b0:	00008806 	br	200213d4 <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
200211b4:	d0a60517 	ldw	r2,-26604(gp)
200211b8:	d0e60517 	ldw	r3,-26604(gp)
200211bc:	19000c03 	ldbu	r4,48(r3)
200211c0:	e0fff203 	ldbu	r3,-56(fp)
200211c4:	20c6b03a 	or	r3,r4,r3
200211c8:	1809883a 	mov	r4,r3
200211cc:	00ffe004 	movi	r3,-128
200211d0:	20c6b03a 	or	r3,r4,r3
200211d4:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
200211d8:	d0a60517 	ldw	r2,-26604(gp)
200211dc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
200211e0:	d0a60517 	ldw	r2,-26604(gp)
200211e4:	e0ffff0b 	ldhu	r3,-4(fp)
200211e8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
200211ec:	e13ffc17 	ldw	r4,-16(fp)
200211f0:	0021d140 	call	20021d14 <OS_EventTaskWaitMulti>
200211f4:	e0bff317 	ldw	r2,-52(fp)
200211f8:	e0bff915 	stw	r2,-28(fp)
200211fc:	e0bff917 	ldw	r2,-28(fp)
20021200:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
20021204:	00224b80 	call	200224b8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20021208:	0005303a 	rdctl	r2,status
2002120c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20021210:	e0fff717 	ldw	r3,-36(fp)
20021214:	00bfff84 	movi	r2,-2
20021218:	1884703a 	and	r2,r3,r2
2002121c:	1001703a 	wrctl	status,r2
  
  return context;
20021220:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
20021224:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
20021228:	d0a60517 	ldw	r2,-26604(gp)
2002122c:	10800c43 	ldbu	r2,49(r2)
20021230:	10803fcc 	andi	r2,r2,255
20021234:	10000226 	beq	r2,zero,20021240 <OSEventPendMulti+0x468>
20021238:	108000a0 	cmpeqi	r2,r2,2
2002123c:	10001826 	beq	r2,zero,200212a0 <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
20021240:	d0a60517 	ldw	r2,-26604(gp)
20021244:	10800717 	ldw	r2,28(r2)
20021248:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
2002124c:	e0bff017 	ldw	r2,-64(fp)
20021250:	10000b26 	beq	r2,zero,20021280 <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
20021254:	e0bffd17 	ldw	r2,-12(fp)
20021258:	10c00104 	addi	r3,r2,4
2002125c:	e0fffd15 	stw	r3,-12(fp)
20021260:	e0fff017 	ldw	r3,-64(fp)
20021264:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
20021268:	e0bffd17 	ldw	r2,-12(fp)
2002126c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
20021270:	e0bff18b 	ldhu	r2,-58(fp)
20021274:	10800044 	addi	r2,r2,1
20021278:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
2002127c:	00000d06 	br	200212b4 <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
20021280:	d0a60517 	ldw	r2,-26604(gp)
20021284:	00c00044 	movi	r3,1
20021288:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
2002128c:	d0a60517 	ldw	r2,-26604(gp)
20021290:	e17ffc17 	ldw	r5,-16(fp)
20021294:	1009883a 	mov	r4,r2
20021298:	0021f1c0 	call	20021f1c <OS_EventTaskRemoveMulti>
             }
			 break;
2002129c:	00000506 	br	200212b4 <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
200212a0:	d0a60517 	ldw	r2,-26604(gp)
200212a4:	e17ffc17 	ldw	r5,-16(fp)
200212a8:	1009883a 	mov	r4,r2
200212ac:	0021f1c0 	call	20021f1c <OS_EventTaskRemoveMulti>
             break;
200212b0:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
200212b4:	d0a60517 	ldw	r2,-26604(gp)
200212b8:	10800c43 	ldbu	r2,49(r2)
200212bc:	10803fcc 	andi	r2,r2,255
200212c0:	10000326 	beq	r2,zero,200212d0 <OSEventPendMulti+0x4f8>
200212c4:	108000a0 	cmpeqi	r2,r2,2
200212c8:	1000231e 	bne	r2,zero,20021358 <OSEventPendMulti+0x580>
200212cc:	00002a06 	br	20021378 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
200212d0:	e0bff017 	ldw	r2,-64(fp)
200212d4:	10800003 	ldbu	r2,0(r2)
200212d8:	10803fcc 	andi	r2,r2,255
200212dc:	0080100e 	bge	zero,r2,20021320 <OSEventPendMulti+0x548>
200212e0:	10c000d0 	cmplti	r3,r2,3
200212e4:	1800071e 	bne	r3,zero,20021304 <OSEventPendMulti+0x52c>
200212e8:	108000e0 	cmpeqi	r2,r2,3
200212ec:	10000c26 	beq	r2,zero,20021320 <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
200212f0:	e0bffe17 	ldw	r2,-8(fp)
200212f4:	10c00104 	addi	r3,r2,4
200212f8:	e0fffe15 	stw	r3,-8(fp)
200212fc:	10000015 	stw	zero,0(r2)
                      break;
20021300:	00001206 	br	2002134c <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
20021304:	e0bffe17 	ldw	r2,-8(fp)
20021308:	10c00104 	addi	r3,r2,4
2002130c:	e0fffe15 	stw	r3,-8(fp)
20021310:	d0e60517 	ldw	r3,-26604(gp)
20021314:	18c00917 	ldw	r3,36(r3)
20021318:	10c00015 	stw	r3,0(r2)
                      break;
2002131c:	00000b06 	br	2002134c <OSEventPendMulti+0x574>
20021320:	e0bff317 	ldw	r2,-52(fp)
20021324:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20021328:	e0bff817 	ldw	r2,-32(fp)
2002132c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
20021330:	e0bffd17 	ldw	r2,-12(fp)
20021334:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
20021338:	e0800217 	ldw	r2,8(fp)
2002133c:	00c00044 	movi	r3,1
20021340:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
20021344:	e0bff18b 	ldhu	r2,-58(fp)
20021348:	00002206 	br	200213d4 <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
2002134c:	e0800217 	ldw	r2,8(fp)
20021350:	10000005 	stb	zero,0(r2)
             break;
20021354:	00001006 	br	20021398 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
20021358:	e0bffe17 	ldw	r2,-8(fp)
2002135c:	10c00104 	addi	r3,r2,4
20021360:	e0fffe15 	stw	r3,-8(fp)
20021364:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
20021368:	e0800217 	ldw	r2,8(fp)
2002136c:	00c00384 	movi	r3,14
20021370:	10c00005 	stb	r3,0(r2)
             break;
20021374:	00000806 	br	20021398 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
20021378:	e0bffe17 	ldw	r2,-8(fp)
2002137c:	10c00104 	addi	r3,r2,4
20021380:	e0fffe15 	stw	r3,-8(fp)
20021384:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
20021388:	e0800217 	ldw	r2,8(fp)
2002138c:	00c00284 	movi	r3,10
20021390:	10c00005 	stb	r3,0(r2)
             break;
20021394:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
20021398:	d0a60517 	ldw	r2,-26604(gp)
2002139c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
200213a0:	d0a60517 	ldw	r2,-26604(gp)
200213a4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
200213a8:	d0a60517 	ldw	r2,-26604(gp)
200213ac:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
200213b0:	d0a60517 	ldw	r2,-26604(gp)
200213b4:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
200213b8:	d0a60517 	ldw	r2,-26604(gp)
200213bc:	10000915 	stw	zero,36(r2)
200213c0:	e0bff317 	ldw	r2,-52(fp)
200213c4:	e0bffa15 	stw	r2,-24(fp)
200213c8:	e0bffa17 	ldw	r2,-24(fp)
200213cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
200213d0:	e0bff18b 	ldhu	r2,-58(fp)
}
200213d4:	e037883a 	mov	sp,fp
200213d8:	dfc00117 	ldw	ra,4(sp)
200213dc:	df000017 	ldw	fp,0(sp)
200213e0:	dec00204 	addi	sp,sp,8
200213e4:	f800283a 	ret

200213e8 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
200213e8:	defffe04 	addi	sp,sp,-8
200213ec:	dfc00115 	stw	ra,4(sp)
200213f0:	df000015 	stw	fp,0(sp)
200213f4:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
200213f8:	002a4a80 	call	2002a4a8 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
200213fc:	00221640 	call	20022164 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
20021400:	00221ac0 	call	200221ac <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
20021404:	00223180 	call	20022318 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
20021408:	00220840 	call	20022084 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
2002140c:	00241b80 	call	200241b8 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
20021410:	0024ab80 	call	20024ab8 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
20021414:	0025be00 	call	20025be0 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
20021418:	00222180 	call	20022218 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
2002141c:	00222980 	call	20022298 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
20021420:	002a4c80 	call	2002a4c8 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
20021424:	0022b8c0 	call	20022b8c <OSDebugInit>
#endif
}
20021428:	0001883a 	nop
2002142c:	e037883a 	mov	sp,fp
20021430:	dfc00117 	ldw	ra,4(sp)
20021434:	df000017 	ldw	fp,0(sp)
20021438:	dec00204 	addi	sp,sp,8
2002143c:	f800283a 	ret

20021440 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
20021440:	deffff04 	addi	sp,sp,-4
20021444:	df000015 	stw	fp,0(sp)
20021448:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
2002144c:	d0a5f643 	ldbu	r2,-26663(gp)
20021450:	10803fcc 	andi	r2,r2,255
20021454:	10800058 	cmpnei	r2,r2,1
20021458:	1000071e 	bne	r2,zero,20021478 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
2002145c:	d0a60403 	ldbu	r2,-26608(gp)
20021460:	10803fcc 	andi	r2,r2,255
20021464:	10803fe0 	cmpeqi	r2,r2,255
20021468:	1000031e 	bne	r2,zero,20021478 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
2002146c:	d0a60403 	ldbu	r2,-26608(gp)
20021470:	10800044 	addi	r2,r2,1
20021474:	d0a60405 	stb	r2,-26608(gp)
        }
    }
}
20021478:	0001883a 	nop
2002147c:	e037883a 	mov	sp,fp
20021480:	df000017 	ldw	fp,0(sp)
20021484:	dec00104 	addi	sp,sp,4
20021488:	f800283a 	ret

2002148c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
2002148c:	defffb04 	addi	sp,sp,-20
20021490:	dfc00415 	stw	ra,16(sp)
20021494:	df000315 	stw	fp,12(sp)
20021498:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
2002149c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
200214a0:	d0a5f643 	ldbu	r2,-26663(gp)
200214a4:	10803fcc 	andi	r2,r2,255
200214a8:	10800058 	cmpnei	r2,r2,1
200214ac:	10002f1e 	bne	r2,zero,2002156c <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200214b0:	0005303a 	rdctl	r2,status
200214b4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200214b8:	e0ffff17 	ldw	r3,-4(fp)
200214bc:	00bfff84 	movi	r2,-2
200214c0:	1884703a 	and	r2,r3,r2
200214c4:	1001703a 	wrctl	status,r2
  
  return context;
200214c8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
200214cc:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
200214d0:	d0a60403 	ldbu	r2,-26608(gp)
200214d4:	10803fcc 	andi	r2,r2,255
200214d8:	10000326 	beq	r2,zero,200214e8 <OSIntExit+0x5c>
            OSIntNesting--;
200214dc:	d0a60403 	ldbu	r2,-26608(gp)
200214e0:	10bfffc4 	addi	r2,r2,-1
200214e4:	d0a60405 	stb	r2,-26608(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
200214e8:	d0a60403 	ldbu	r2,-26608(gp)
200214ec:	10803fcc 	andi	r2,r2,255
200214f0:	10001a1e 	bne	r2,zero,2002155c <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
200214f4:	d0a5f603 	ldbu	r2,-26664(gp)
200214f8:	10803fcc 	andi	r2,r2,255
200214fc:	1000171e 	bne	r2,zero,2002155c <OSIntExit+0xd0>
                OS_SchedNew();
20021500:	00225880 	call	20022588 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
20021504:	d0e5f803 	ldbu	r3,-26656(gp)
20021508:	d0a5f843 	ldbu	r2,-26655(gp)
2002150c:	18c03fcc 	andi	r3,r3,255
20021510:	10803fcc 	andi	r2,r2,255
20021514:	18801126 	beq	r3,r2,2002155c <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
20021518:	d0a5f803 	ldbu	r2,-26656(gp)
2002151c:	10c03fcc 	andi	r3,r2,255
20021520:	008800f4 	movhi	r2,8195
20021524:	1086b504 	addi	r2,r2,6868
20021528:	18c7883a 	add	r3,r3,r3
2002152c:	18c7883a 	add	r3,r3,r3
20021530:	10c5883a 	add	r2,r2,r3
20021534:	10800017 	ldw	r2,0(r2)
20021538:	d0a60015 	stw	r2,-26624(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
2002153c:	d0a60017 	ldw	r2,-26624(gp)
20021540:	10c00e17 	ldw	r3,56(r2)
20021544:	18c00044 	addi	r3,r3,1
20021548:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
2002154c:	d0a5fb17 	ldw	r2,-26644(gp)
20021550:	10800044 	addi	r2,r2,1
20021554:	d0a5fb15 	stw	r2,-26644(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
20021558:	002a1d40 	call	2002a1d4 <OSCtxSw>
2002155c:	e0bffd17 	ldw	r2,-12(fp)
20021560:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20021564:	e0bffe17 	ldw	r2,-8(fp)
20021568:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
2002156c:	0001883a 	nop
20021570:	e037883a 	mov	sp,fp
20021574:	dfc00117 	ldw	ra,4(sp)
20021578:	df000017 	ldw	fp,0(sp)
2002157c:	dec00204 	addi	sp,sp,8
20021580:	f800283a 	ret

20021584 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
20021584:	defffc04 	addi	sp,sp,-16
20021588:	df000315 	stw	fp,12(sp)
2002158c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20021590:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
20021594:	d0a5f643 	ldbu	r2,-26663(gp)
20021598:	10803fcc 	andi	r2,r2,255
2002159c:	10800058 	cmpnei	r2,r2,1
200215a0:	1000161e 	bne	r2,zero,200215fc <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200215a4:	0005303a 	rdctl	r2,status
200215a8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200215ac:	e0ffff17 	ldw	r3,-4(fp)
200215b0:	00bfff84 	movi	r2,-2
200215b4:	1884703a 	and	r2,r3,r2
200215b8:	1001703a 	wrctl	status,r2
  
  return context;
200215bc:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
200215c0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
200215c4:	d0a60403 	ldbu	r2,-26608(gp)
200215c8:	10803fcc 	andi	r2,r2,255
200215cc:	1000071e 	bne	r2,zero,200215ec <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
200215d0:	d0a5f603 	ldbu	r2,-26664(gp)
200215d4:	10803fcc 	andi	r2,r2,255
200215d8:	10803fe0 	cmpeqi	r2,r2,255
200215dc:	1000031e 	bne	r2,zero,200215ec <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
200215e0:	d0a5f603 	ldbu	r2,-26664(gp)
200215e4:	10800044 	addi	r2,r2,1
200215e8:	d0a5f605 	stb	r2,-26664(gp)
200215ec:	e0bffd17 	ldw	r2,-12(fp)
200215f0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200215f4:	e0bffe17 	ldw	r2,-8(fp)
200215f8:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
200215fc:	0001883a 	nop
20021600:	e037883a 	mov	sp,fp
20021604:	df000017 	ldw	fp,0(sp)
20021608:	dec00104 	addi	sp,sp,4
2002160c:	f800283a 	ret

20021610 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
20021610:	defff804 	addi	sp,sp,-32
20021614:	dfc00715 	stw	ra,28(sp)
20021618:	df000615 	stw	fp,24(sp)
2002161c:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
20021620:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
20021624:	d0a5f643 	ldbu	r2,-26663(gp)
20021628:	10803fcc 	andi	r2,r2,255
2002162c:	10800058 	cmpnei	r2,r2,1
20021630:	1000281e 	bne	r2,zero,200216d4 <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20021634:	0005303a 	rdctl	r2,status
20021638:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2002163c:	e0ffff17 	ldw	r3,-4(fp)
20021640:	00bfff84 	movi	r2,-2
20021644:	1884703a 	and	r2,r3,r2
20021648:	1001703a 	wrctl	status,r2
  
  return context;
2002164c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
20021650:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
20021654:	d0a5f603 	ldbu	r2,-26664(gp)
20021658:	10803fcc 	andi	r2,r2,255
2002165c:	10001926 	beq	r2,zero,200216c4 <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
20021660:	d0a5f603 	ldbu	r2,-26664(gp)
20021664:	10bfffc4 	addi	r2,r2,-1
20021668:	d0a5f605 	stb	r2,-26664(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
2002166c:	d0a5f603 	ldbu	r2,-26664(gp)
20021670:	10803fcc 	andi	r2,r2,255
20021674:	10000e1e 	bne	r2,zero,200216b0 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
20021678:	d0a60403 	ldbu	r2,-26608(gp)
2002167c:	10803fcc 	andi	r2,r2,255
20021680:	1000061e 	bne	r2,zero,2002169c <OSSchedUnlock+0x8c>
20021684:	e0bffa17 	ldw	r2,-24(fp)
20021688:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002168c:	e0bffb17 	ldw	r2,-20(fp)
20021690:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
20021694:	00224b80 	call	200224b8 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
20021698:	00000e06 	br	200216d4 <OSSchedUnlock+0xc4>
2002169c:	e0bffa17 	ldw	r2,-24(fp)
200216a0:	e0bffc15 	stw	r2,-16(fp)
200216a4:	e0bffc17 	ldw	r2,-16(fp)
200216a8:	1001703a 	wrctl	status,r2
200216ac:	00000906 	br	200216d4 <OSSchedUnlock+0xc4>
200216b0:	e0bffa17 	ldw	r2,-24(fp)
200216b4:	e0bffd15 	stw	r2,-12(fp)
200216b8:	e0bffd17 	ldw	r2,-12(fp)
200216bc:	1001703a 	wrctl	status,r2
200216c0:	00000406 	br	200216d4 <OSSchedUnlock+0xc4>
200216c4:	e0bffa17 	ldw	r2,-24(fp)
200216c8:	e0bffe15 	stw	r2,-8(fp)
200216cc:	e0bffe17 	ldw	r2,-8(fp)
200216d0:	1001703a 	wrctl	status,r2
200216d4:	0001883a 	nop
200216d8:	e037883a 	mov	sp,fp
200216dc:	dfc00117 	ldw	ra,4(sp)
200216e0:	df000017 	ldw	fp,0(sp)
200216e4:	dec00204 	addi	sp,sp,8
200216e8:	f800283a 	ret

200216ec <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
200216ec:	defffe04 	addi	sp,sp,-8
200216f0:	dfc00115 	stw	ra,4(sp)
200216f4:	df000015 	stw	fp,0(sp)
200216f8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
200216fc:	d0a5f643 	ldbu	r2,-26663(gp)
20021700:	10803fcc 	andi	r2,r2,255
20021704:	10000f1e 	bne	r2,zero,20021744 <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
20021708:	00225880 	call	20022588 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
2002170c:	d0a5f803 	ldbu	r2,-26656(gp)
20021710:	d0a5f845 	stb	r2,-26655(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
20021714:	d0a5f803 	ldbu	r2,-26656(gp)
20021718:	10c03fcc 	andi	r3,r2,255
2002171c:	008800f4 	movhi	r2,8195
20021720:	1086b504 	addi	r2,r2,6868
20021724:	18c7883a 	add	r3,r3,r3
20021728:	18c7883a 	add	r3,r3,r3
2002172c:	10c5883a 	add	r2,r2,r3
20021730:	10800017 	ldw	r2,0(r2)
20021734:	d0a60015 	stw	r2,-26624(gp)
        OSTCBCur      = OSTCBHighRdy;
20021738:	d0a60017 	ldw	r2,-26624(gp)
2002173c:	d0a60515 	stw	r2,-26604(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
20021740:	002a2600 	call	2002a260 <OSStartHighRdy>
    }
}
20021744:	0001883a 	nop
20021748:	e037883a 	mov	sp,fp
2002174c:	dfc00117 	ldw	ra,4(sp)
20021750:	df000017 	ldw	fp,0(sp)
20021754:	dec00204 	addi	sp,sp,8
20021758:	f800283a 	ret

2002175c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
2002175c:	defff904 	addi	sp,sp,-28
20021760:	dfc00615 	stw	ra,24(sp)
20021764:	df000515 	stw	fp,20(sp)
20021768:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
2002176c:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
20021770:	01000084 	movi	r4,2
20021774:	0027e540 	call	20027e54 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20021778:	0005303a 	rdctl	r2,status
2002177c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20021780:	e0fffc17 	ldw	r3,-16(fp)
20021784:	00bfff84 	movi	r2,-2
20021788:	1884703a 	and	r2,r3,r2
2002178c:	1001703a 	wrctl	status,r2
  
  return context;
20021790:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
20021794:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
20021798:	d025f715 	stw	zero,-26660(gp)
2002179c:	e0bffb17 	ldw	r2,-20(fp)
200217a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200217a4:	e0bffd17 	ldw	r2,-12(fp)
200217a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
200217ac:	01001904 	movi	r4,100
200217b0:	0027e540 	call	20027e54 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200217b4:	0005303a 	rdctl	r2,status
200217b8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200217bc:	e0fffe17 	ldw	r3,-8(fp)
200217c0:	00bfff84 	movi	r2,-2
200217c4:	1884703a 	and	r2,r3,r2
200217c8:	1001703a 	wrctl	status,r2
  
  return context;
200217cc:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
200217d0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
200217d4:	d0a5f717 	ldw	r2,-26660(gp)
200217d8:	d0a5fc15 	stw	r2,-26640(gp)
    OSStatRdy    = OS_TRUE;
200217dc:	00800044 	movi	r2,1
200217e0:	d0a60805 	stb	r2,-26592(gp)
200217e4:	e0bffb17 	ldw	r2,-20(fp)
200217e8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200217ec:	e0bfff17 	ldw	r2,-4(fp)
200217f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
200217f4:	0001883a 	nop
200217f8:	e037883a 	mov	sp,fp
200217fc:	dfc00117 	ldw	ra,4(sp)
20021800:	df000017 	ldw	fp,0(sp)
20021804:	dec00204 	addi	sp,sp,8
20021808:	f800283a 	ret

2002180c <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
2002180c:	defff704 	addi	sp,sp,-36
20021810:	dfc00815 	stw	ra,32(sp)
20021814:	df000715 	stw	fp,28(sp)
20021818:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
2002181c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
20021820:	002a4880 	call	2002a488 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20021824:	0005303a 	rdctl	r2,status
20021828:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2002182c:	e0fffd17 	ldw	r3,-12(fp)
20021830:	00bfff84 	movi	r2,-2
20021834:	1884703a 	and	r2,r3,r2
20021838:	1001703a 	wrctl	status,r2
  
  return context;
2002183c:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
20021840:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
20021844:	d0a60617 	ldw	r2,-26600(gp)
20021848:	10800044 	addi	r2,r2,1
2002184c:	d0a60615 	stw	r2,-26600(gp)
20021850:	e0bffb17 	ldw	r2,-20(fp)
20021854:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20021858:	e0bfff17 	ldw	r2,-4(fp)
2002185c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
20021860:	d0a5f643 	ldbu	r2,-26663(gp)
20021864:	10803fcc 	andi	r2,r2,255
20021868:	10800058 	cmpnei	r2,r2,1
2002186c:	10006a1e 	bne	r2,zero,20021a18 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
20021870:	d0a5fa03 	ldbu	r2,-26648(gp)
20021874:	10803fcc 	andi	r2,r2,255
20021878:	10c00060 	cmpeqi	r3,r2,1
2002187c:	1800061e 	bne	r3,zero,20021898 <OSTimeTick+0x8c>
20021880:	10c000a0 	cmpeqi	r3,r2,2
20021884:	1800061e 	bne	r3,zero,200218a0 <OSTimeTick+0x94>
20021888:	10000a1e 	bne	r2,zero,200218b4 <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
2002188c:	00800044 	movi	r2,1
20021890:	e0bffa05 	stb	r2,-24(fp)
                 break;
20021894:	00000b06 	br	200218c4 <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
20021898:	e03ffa05 	stb	zero,-24(fp)
                 break;
2002189c:	00000906 	br	200218c4 <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
200218a0:	00800044 	movi	r2,1
200218a4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
200218a8:	00800044 	movi	r2,1
200218ac:	d0a5fa05 	stb	r2,-26648(gp)
                 break;
200218b0:	00000406 	br	200218c4 <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
200218b4:	00800044 	movi	r2,1
200218b8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
200218bc:	d025fa05 	stb	zero,-26648(gp)
                 break;
200218c0:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
200218c4:	e0bffa03 	ldbu	r2,-24(fp)
200218c8:	10005226 	beq	r2,zero,20021a14 <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
200218cc:	d0a5f917 	ldw	r2,-26652(gp)
200218d0:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
200218d4:	00004906 	br	200219fc <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200218d8:	0005303a 	rdctl	r2,status
200218dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200218e0:	e0fffc17 	ldw	r3,-16(fp)
200218e4:	00bfff84 	movi	r2,-2
200218e8:	1884703a 	and	r2,r3,r2
200218ec:	1001703a 	wrctl	status,r2
  
  return context;
200218f0:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
200218f4:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
200218f8:	e0bff917 	ldw	r2,-28(fp)
200218fc:	10800b8b 	ldhu	r2,46(r2)
20021900:	10bfffcc 	andi	r2,r2,65535
20021904:	10003626 	beq	r2,zero,200219e0 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
20021908:	e0bff917 	ldw	r2,-28(fp)
2002190c:	10800b8b 	ldhu	r2,46(r2)
20021910:	10bfffc4 	addi	r2,r2,-1
20021914:	1007883a 	mov	r3,r2
20021918:	e0bff917 	ldw	r2,-28(fp)
2002191c:	10c00b8d 	sth	r3,46(r2)
20021920:	e0bff917 	ldw	r2,-28(fp)
20021924:	10800b8b 	ldhu	r2,46(r2)
20021928:	10bfffcc 	andi	r2,r2,65535
2002192c:	10002c1e 	bne	r2,zero,200219e0 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
20021930:	e0bff917 	ldw	r2,-28(fp)
20021934:	10800c03 	ldbu	r2,48(r2)
20021938:	10803fcc 	andi	r2,r2,255
2002193c:	10800dcc 	andi	r2,r2,55
20021940:	10000b26 	beq	r2,zero,20021970 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
20021944:	e0bff917 	ldw	r2,-28(fp)
20021948:	10c00c03 	ldbu	r3,48(r2)
2002194c:	00bff204 	movi	r2,-56
20021950:	1884703a 	and	r2,r3,r2
20021954:	1007883a 	mov	r3,r2
20021958:	e0bff917 	ldw	r2,-28(fp)
2002195c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
20021960:	e0bff917 	ldw	r2,-28(fp)
20021964:	00c00044 	movi	r3,1
20021968:	10c00c45 	stb	r3,49(r2)
2002196c:	00000206 	br	20021978 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
20021970:	e0bff917 	ldw	r2,-28(fp)
20021974:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
20021978:	e0bff917 	ldw	r2,-28(fp)
2002197c:	10800c03 	ldbu	r2,48(r2)
20021980:	10803fcc 	andi	r2,r2,255
20021984:	1080020c 	andi	r2,r2,8
20021988:	1000151e 	bne	r2,zero,200219e0 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
2002198c:	e0bff917 	ldw	r2,-28(fp)
20021990:	10c00d83 	ldbu	r3,54(r2)
20021994:	d0a60203 	ldbu	r2,-26616(gp)
20021998:	1884b03a 	or	r2,r3,r2
2002199c:	d0a60205 	stb	r2,-26616(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
200219a0:	e0bff917 	ldw	r2,-28(fp)
200219a4:	10800d03 	ldbu	r2,52(r2)
200219a8:	10c03fcc 	andi	r3,r2,255
200219ac:	e0bff917 	ldw	r2,-28(fp)
200219b0:	10800d03 	ldbu	r2,52(r2)
200219b4:	11003fcc 	andi	r4,r2,255
200219b8:	d0a60244 	addi	r2,gp,-26615
200219bc:	2085883a 	add	r2,r4,r2
200219c0:	11000003 	ldbu	r4,0(r2)
200219c4:	e0bff917 	ldw	r2,-28(fp)
200219c8:	10800d43 	ldbu	r2,53(r2)
200219cc:	2084b03a 	or	r2,r4,r2
200219d0:	1009883a 	mov	r4,r2
200219d4:	d0a60244 	addi	r2,gp,-26615
200219d8:	1885883a 	add	r2,r3,r2
200219dc:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
200219e0:	e0bff917 	ldw	r2,-28(fp)
200219e4:	10800517 	ldw	r2,20(r2)
200219e8:	e0bff915 	stw	r2,-28(fp)
200219ec:	e0bffb17 	ldw	r2,-20(fp)
200219f0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200219f4:	e0bffe17 	ldw	r2,-8(fp)
200219f8:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
200219fc:	e0bff917 	ldw	r2,-28(fp)
20021a00:	10800c83 	ldbu	r2,50(r2)
20021a04:	10803fcc 	andi	r2,r2,255
20021a08:	10800518 	cmpnei	r2,r2,20
20021a0c:	103fb21e 	bne	r2,zero,200218d8 <__alt_data_end+0xfffe18d8>
20021a10:	00000106 	br	20021a18 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
20021a14:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
20021a18:	e037883a 	mov	sp,fp
20021a1c:	dfc00117 	ldw	ra,4(sp)
20021a20:	df000017 	ldw	fp,0(sp)
20021a24:	dec00204 	addi	sp,sp,8
20021a28:	f800283a 	ret

20021a2c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
20021a2c:	deffff04 	addi	sp,sp,-4
20021a30:	df000015 	stw	fp,0(sp)
20021a34:	d839883a 	mov	fp,sp
    return (OS_VERSION);
20021a38:	00804784 	movi	r2,286
}
20021a3c:	e037883a 	mov	sp,fp
20021a40:	df000017 	ldw	fp,0(sp)
20021a44:	dec00104 	addi	sp,sp,4
20021a48:	f800283a 	ret

20021a4c <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
20021a4c:	deffff04 	addi	sp,sp,-4
20021a50:	df000015 	stw	fp,0(sp)
20021a54:	d839883a 	mov	fp,sp
}
20021a58:	0001883a 	nop
20021a5c:	e037883a 	mov	sp,fp
20021a60:	df000017 	ldw	fp,0(sp)
20021a64:	dec00104 	addi	sp,sp,4
20021a68:	f800283a 	ret

20021a6c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
20021a6c:	defff804 	addi	sp,sp,-32
20021a70:	dfc00715 	stw	ra,28(sp)
20021a74:	df000615 	stw	fp,24(sp)
20021a78:	df000604 	addi	fp,sp,24
20021a7c:	e13ffc15 	stw	r4,-16(fp)
20021a80:	e17ffd15 	stw	r5,-12(fp)
20021a84:	3007883a 	mov	r3,r6
20021a88:	3805883a 	mov	r2,r7
20021a8c:	e0fffe05 	stb	r3,-8(fp)
20021a90:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
20021a94:	e0bffc17 	ldw	r2,-16(fp)
20021a98:	10800283 	ldbu	r2,10(r2)
20021a9c:	10c03fcc 	andi	r3,r2,255
20021aa0:	008800f4 	movhi	r2,8195
20021aa4:	10ac0704 	addi	r2,r2,-20452
20021aa8:	10c5883a 	add	r2,r2,r3
20021aac:	10800003 	ldbu	r2,0(r2)
20021ab0:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
20021ab4:	e0bffa03 	ldbu	r2,-24(fp)
20021ab8:	e0fffc17 	ldw	r3,-16(fp)
20021abc:	1885883a 	add	r2,r3,r2
20021ac0:	108002c4 	addi	r2,r2,11
20021ac4:	10800003 	ldbu	r2,0(r2)
20021ac8:	10c03fcc 	andi	r3,r2,255
20021acc:	008800f4 	movhi	r2,8195
20021ad0:	10ac0704 	addi	r2,r2,-20452
20021ad4:	10c5883a 	add	r2,r2,r3
20021ad8:	10800003 	ldbu	r2,0(r2)
20021adc:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
20021ae0:	e0bffa03 	ldbu	r2,-24(fp)
20021ae4:	100490fa 	slli	r2,r2,3
20021ae8:	1007883a 	mov	r3,r2
20021aec:	e0bffa43 	ldbu	r2,-23(fp)
20021af0:	1885883a 	add	r2,r3,r2
20021af4:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
20021af8:	e0fffa83 	ldbu	r3,-22(fp)
20021afc:	008800f4 	movhi	r2,8195
20021b00:	1086b504 	addi	r2,r2,6868
20021b04:	18c7883a 	add	r3,r3,r3
20021b08:	18c7883a 	add	r3,r3,r3
20021b0c:	10c5883a 	add	r2,r2,r3
20021b10:	10800017 	ldw	r2,0(r2)
20021b14:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
20021b18:	e0bffb17 	ldw	r2,-20(fp)
20021b1c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
20021b20:	e0bffb17 	ldw	r2,-20(fp)
20021b24:	e0fffd17 	ldw	r3,-12(fp)
20021b28:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
20021b2c:	e0bffb17 	ldw	r2,-20(fp)
20021b30:	10800c03 	ldbu	r2,48(r2)
20021b34:	1007883a 	mov	r3,r2
20021b38:	e0bffe03 	ldbu	r2,-8(fp)
20021b3c:	0084303a 	nor	r2,zero,r2
20021b40:	1884703a 	and	r2,r3,r2
20021b44:	1007883a 	mov	r3,r2
20021b48:	e0bffb17 	ldw	r2,-20(fp)
20021b4c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
20021b50:	e0bffb17 	ldw	r2,-20(fp)
20021b54:	e0ffff03 	ldbu	r3,-4(fp)
20021b58:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
20021b5c:	e0bffb17 	ldw	r2,-20(fp)
20021b60:	10800c03 	ldbu	r2,48(r2)
20021b64:	10803fcc 	andi	r2,r2,255
20021b68:	1080020c 	andi	r2,r2,8
20021b6c:	1000111e 	bne	r2,zero,20021bb4 <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
20021b70:	e0bffb17 	ldw	r2,-20(fp)
20021b74:	10c00d83 	ldbu	r3,54(r2)
20021b78:	d0a60203 	ldbu	r2,-26616(gp)
20021b7c:	1884b03a 	or	r2,r3,r2
20021b80:	d0a60205 	stb	r2,-26616(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
20021b84:	e0fffa03 	ldbu	r3,-24(fp)
20021b88:	e13ffa03 	ldbu	r4,-24(fp)
20021b8c:	d0a60244 	addi	r2,gp,-26615
20021b90:	2085883a 	add	r2,r4,r2
20021b94:	11000003 	ldbu	r4,0(r2)
20021b98:	e0bffb17 	ldw	r2,-20(fp)
20021b9c:	10800d43 	ldbu	r2,53(r2)
20021ba0:	2084b03a 	or	r2,r4,r2
20021ba4:	1009883a 	mov	r4,r2
20021ba8:	d0a60244 	addi	r2,gp,-26615
20021bac:	1885883a 	add	r2,r3,r2
20021bb0:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
20021bb4:	e17ffc17 	ldw	r5,-16(fp)
20021bb8:	e13ffb17 	ldw	r4,-20(fp)
20021bbc:	0021e640 	call	20021e64 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
20021bc0:	e0bffb17 	ldw	r2,-20(fp)
20021bc4:	10800817 	ldw	r2,32(r2)
20021bc8:	10000826 	beq	r2,zero,20021bec <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
20021bcc:	e0bffb17 	ldw	r2,-20(fp)
20021bd0:	10800817 	ldw	r2,32(r2)
20021bd4:	100b883a 	mov	r5,r2
20021bd8:	e13ffb17 	ldw	r4,-20(fp)
20021bdc:	0021f1c0 	call	20021f1c <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
20021be0:	e0bffb17 	ldw	r2,-20(fp)
20021be4:	e0fffc17 	ldw	r3,-16(fp)
20021be8:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
20021bec:	e0bffa83 	ldbu	r2,-22(fp)
}
20021bf0:	e037883a 	mov	sp,fp
20021bf4:	dfc00117 	ldw	ra,4(sp)
20021bf8:	df000017 	ldw	fp,0(sp)
20021bfc:	dec00204 	addi	sp,sp,8
20021c00:	f800283a 	ret

20021c04 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
20021c04:	defffd04 	addi	sp,sp,-12
20021c08:	df000215 	stw	fp,8(sp)
20021c0c:	df000204 	addi	fp,sp,8
20021c10:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
20021c14:	d0a60517 	ldw	r2,-26604(gp)
20021c18:	e0ffff17 	ldw	r3,-4(fp)
20021c1c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
20021c20:	d0a60517 	ldw	r2,-26604(gp)
20021c24:	10800d03 	ldbu	r2,52(r2)
20021c28:	10803fcc 	andi	r2,r2,255
20021c2c:	d0e60517 	ldw	r3,-26604(gp)
20021c30:	18c00d03 	ldbu	r3,52(r3)
20021c34:	18c03fcc 	andi	r3,r3,255
20021c38:	e13fff17 	ldw	r4,-4(fp)
20021c3c:	20c7883a 	add	r3,r4,r3
20021c40:	18c002c4 	addi	r3,r3,11
20021c44:	19000003 	ldbu	r4,0(r3)
20021c48:	d0e60517 	ldw	r3,-26604(gp)
20021c4c:	18c00d43 	ldbu	r3,53(r3)
20021c50:	20c6b03a 	or	r3,r4,r3
20021c54:	1809883a 	mov	r4,r3
20021c58:	e0ffff17 	ldw	r3,-4(fp)
20021c5c:	1885883a 	add	r2,r3,r2
20021c60:	108002c4 	addi	r2,r2,11
20021c64:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
20021c68:	e0bfff17 	ldw	r2,-4(fp)
20021c6c:	10c00283 	ldbu	r3,10(r2)
20021c70:	d0a60517 	ldw	r2,-26604(gp)
20021c74:	10800d83 	ldbu	r2,54(r2)
20021c78:	1884b03a 	or	r2,r3,r2
20021c7c:	1007883a 	mov	r3,r2
20021c80:	e0bfff17 	ldw	r2,-4(fp)
20021c84:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
20021c88:	d0a60517 	ldw	r2,-26604(gp)
20021c8c:	10800d03 	ldbu	r2,52(r2)
20021c90:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
20021c94:	e0fffe03 	ldbu	r3,-8(fp)
20021c98:	e13ffe03 	ldbu	r4,-8(fp)
20021c9c:	d0a60244 	addi	r2,gp,-26615
20021ca0:	2085883a 	add	r2,r4,r2
20021ca4:	10800003 	ldbu	r2,0(r2)
20021ca8:	1009883a 	mov	r4,r2
20021cac:	d0a60517 	ldw	r2,-26604(gp)
20021cb0:	10800d43 	ldbu	r2,53(r2)
20021cb4:	0084303a 	nor	r2,zero,r2
20021cb8:	2084703a 	and	r2,r4,r2
20021cbc:	1009883a 	mov	r4,r2
20021cc0:	d0a60244 	addi	r2,gp,-26615
20021cc4:	1885883a 	add	r2,r3,r2
20021cc8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
20021ccc:	e0fffe03 	ldbu	r3,-8(fp)
20021cd0:	d0a60244 	addi	r2,gp,-26615
20021cd4:	1885883a 	add	r2,r3,r2
20021cd8:	10800003 	ldbu	r2,0(r2)
20021cdc:	10803fcc 	andi	r2,r2,255
20021ce0:	1000071e 	bne	r2,zero,20021d00 <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
20021ce4:	d0a60517 	ldw	r2,-26604(gp)
20021ce8:	10800d83 	ldbu	r2,54(r2)
20021cec:	0084303a 	nor	r2,zero,r2
20021cf0:	1007883a 	mov	r3,r2
20021cf4:	d0a60203 	ldbu	r2,-26616(gp)
20021cf8:	1884703a 	and	r2,r3,r2
20021cfc:	d0a60205 	stb	r2,-26616(gp)
    }
}
20021d00:	0001883a 	nop
20021d04:	e037883a 	mov	sp,fp
20021d08:	df000017 	ldw	fp,0(sp)
20021d0c:	dec00104 	addi	sp,sp,4
20021d10:	f800283a 	ret

20021d14 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
20021d14:	defffb04 	addi	sp,sp,-20
20021d18:	df000415 	stw	fp,16(sp)
20021d1c:	df000404 	addi	fp,sp,16
20021d20:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
20021d24:	d0a60517 	ldw	r2,-26604(gp)
20021d28:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
20021d2c:	d0a60517 	ldw	r2,-26604(gp)
20021d30:	e0ffff17 	ldw	r3,-4(fp)
20021d34:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
20021d38:	e0bfff17 	ldw	r2,-4(fp)
20021d3c:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
20021d40:	e0bffc17 	ldw	r2,-16(fp)
20021d44:	10800017 	ldw	r2,0(r2)
20021d48:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
20021d4c:	00002006 	br	20021dd0 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
20021d50:	d0a60517 	ldw	r2,-26604(gp)
20021d54:	10800d03 	ldbu	r2,52(r2)
20021d58:	10803fcc 	andi	r2,r2,255
20021d5c:	d0e60517 	ldw	r3,-26604(gp)
20021d60:	18c00d03 	ldbu	r3,52(r3)
20021d64:	18c03fcc 	andi	r3,r3,255
20021d68:	e13ffd17 	ldw	r4,-12(fp)
20021d6c:	20c7883a 	add	r3,r4,r3
20021d70:	18c002c4 	addi	r3,r3,11
20021d74:	19000003 	ldbu	r4,0(r3)
20021d78:	d0e60517 	ldw	r3,-26604(gp)
20021d7c:	18c00d43 	ldbu	r3,53(r3)
20021d80:	20c6b03a 	or	r3,r4,r3
20021d84:	1809883a 	mov	r4,r3
20021d88:	e0fffd17 	ldw	r3,-12(fp)
20021d8c:	1885883a 	add	r2,r3,r2
20021d90:	108002c4 	addi	r2,r2,11
20021d94:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
20021d98:	e0bffd17 	ldw	r2,-12(fp)
20021d9c:	10c00283 	ldbu	r3,10(r2)
20021da0:	d0a60517 	ldw	r2,-26604(gp)
20021da4:	10800d83 	ldbu	r2,54(r2)
20021da8:	1884b03a 	or	r2,r3,r2
20021dac:	1007883a 	mov	r3,r2
20021db0:	e0bffd17 	ldw	r2,-12(fp)
20021db4:	10c00285 	stb	r3,10(r2)
        pevents++;
20021db8:	e0bffc17 	ldw	r2,-16(fp)
20021dbc:	10800104 	addi	r2,r2,4
20021dc0:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
20021dc4:	e0bffc17 	ldw	r2,-16(fp)
20021dc8:	10800017 	ldw	r2,0(r2)
20021dcc:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
20021dd0:	e0bffd17 	ldw	r2,-12(fp)
20021dd4:	103fde1e 	bne	r2,zero,20021d50 <__alt_data_end+0xfffe1d50>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
20021dd8:	d0a60517 	ldw	r2,-26604(gp)
20021ddc:	10800d03 	ldbu	r2,52(r2)
20021de0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
20021de4:	e0fffe03 	ldbu	r3,-8(fp)
20021de8:	e13ffe03 	ldbu	r4,-8(fp)
20021dec:	d0a60244 	addi	r2,gp,-26615
20021df0:	2085883a 	add	r2,r4,r2
20021df4:	10800003 	ldbu	r2,0(r2)
20021df8:	1009883a 	mov	r4,r2
20021dfc:	d0a60517 	ldw	r2,-26604(gp)
20021e00:	10800d43 	ldbu	r2,53(r2)
20021e04:	0084303a 	nor	r2,zero,r2
20021e08:	2084703a 	and	r2,r4,r2
20021e0c:	1009883a 	mov	r4,r2
20021e10:	d0a60244 	addi	r2,gp,-26615
20021e14:	1885883a 	add	r2,r3,r2
20021e18:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
20021e1c:	e0fffe03 	ldbu	r3,-8(fp)
20021e20:	d0a60244 	addi	r2,gp,-26615
20021e24:	1885883a 	add	r2,r3,r2
20021e28:	10800003 	ldbu	r2,0(r2)
20021e2c:	10803fcc 	andi	r2,r2,255
20021e30:	1000071e 	bne	r2,zero,20021e50 <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
20021e34:	d0a60517 	ldw	r2,-26604(gp)
20021e38:	10800d83 	ldbu	r2,54(r2)
20021e3c:	0084303a 	nor	r2,zero,r2
20021e40:	1007883a 	mov	r3,r2
20021e44:	d0a60203 	ldbu	r2,-26616(gp)
20021e48:	1884703a 	and	r2,r3,r2
20021e4c:	d0a60205 	stb	r2,-26616(gp)
    }
}
20021e50:	0001883a 	nop
20021e54:	e037883a 	mov	sp,fp
20021e58:	df000017 	ldw	fp,0(sp)
20021e5c:	dec00104 	addi	sp,sp,4
20021e60:	f800283a 	ret

20021e64 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
20021e64:	defffc04 	addi	sp,sp,-16
20021e68:	df000315 	stw	fp,12(sp)
20021e6c:	df000304 	addi	fp,sp,12
20021e70:	e13ffe15 	stw	r4,-8(fp)
20021e74:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
20021e78:	e0bffe17 	ldw	r2,-8(fp)
20021e7c:	10800d03 	ldbu	r2,52(r2)
20021e80:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
20021e84:	e0bffd03 	ldbu	r2,-12(fp)
20021e88:	e0fffd03 	ldbu	r3,-12(fp)
20021e8c:	e13fff17 	ldw	r4,-4(fp)
20021e90:	20c7883a 	add	r3,r4,r3
20021e94:	18c002c4 	addi	r3,r3,11
20021e98:	18c00003 	ldbu	r3,0(r3)
20021e9c:	1809883a 	mov	r4,r3
20021ea0:	e0fffe17 	ldw	r3,-8(fp)
20021ea4:	18c00d43 	ldbu	r3,53(r3)
20021ea8:	00c6303a 	nor	r3,zero,r3
20021eac:	20c6703a 	and	r3,r4,r3
20021eb0:	1809883a 	mov	r4,r3
20021eb4:	e0ffff17 	ldw	r3,-4(fp)
20021eb8:	1885883a 	add	r2,r3,r2
20021ebc:	108002c4 	addi	r2,r2,11
20021ec0:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
20021ec4:	e0bffd03 	ldbu	r2,-12(fp)
20021ec8:	e0ffff17 	ldw	r3,-4(fp)
20021ecc:	1885883a 	add	r2,r3,r2
20021ed0:	108002c4 	addi	r2,r2,11
20021ed4:	10800003 	ldbu	r2,0(r2)
20021ed8:	10803fcc 	andi	r2,r2,255
20021edc:	10000a1e 	bne	r2,zero,20021f08 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
20021ee0:	e0bfff17 	ldw	r2,-4(fp)
20021ee4:	10800283 	ldbu	r2,10(r2)
20021ee8:	1007883a 	mov	r3,r2
20021eec:	e0bffe17 	ldw	r2,-8(fp)
20021ef0:	10800d83 	ldbu	r2,54(r2)
20021ef4:	0084303a 	nor	r2,zero,r2
20021ef8:	1884703a 	and	r2,r3,r2
20021efc:	1007883a 	mov	r3,r2
20021f00:	e0bfff17 	ldw	r2,-4(fp)
20021f04:	10c00285 	stb	r3,10(r2)
    }
}
20021f08:	0001883a 	nop
20021f0c:	e037883a 	mov	sp,fp
20021f10:	df000017 	ldw	fp,0(sp)
20021f14:	dec00104 	addi	sp,sp,4
20021f18:	f800283a 	ret

20021f1c <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
20021f1c:	defffa04 	addi	sp,sp,-24
20021f20:	df000515 	stw	fp,20(sp)
20021f24:	df000504 	addi	fp,sp,20
20021f28:	e13ffe15 	stw	r4,-8(fp)
20021f2c:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
20021f30:	e0bffe17 	ldw	r2,-8(fp)
20021f34:	10800d03 	ldbu	r2,52(r2)
20021f38:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
20021f3c:	e0bffe17 	ldw	r2,-8(fp)
20021f40:	10800d83 	ldbu	r2,54(r2)
20021f44:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
20021f48:	e0bffe17 	ldw	r2,-8(fp)
20021f4c:	10800d43 	ldbu	r2,53(r2)
20021f50:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
20021f54:	e0bfff17 	ldw	r2,-4(fp)
20021f58:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
20021f5c:	e0bffb17 	ldw	r2,-20(fp)
20021f60:	10800017 	ldw	r2,0(r2)
20021f64:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
20021f68:	00002506 	br	20022000 <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
20021f6c:	e0bffd03 	ldbu	r2,-12(fp)
20021f70:	e0fffd03 	ldbu	r3,-12(fp)
20021f74:	e13ffc17 	ldw	r4,-16(fp)
20021f78:	20c7883a 	add	r3,r4,r3
20021f7c:	18c002c4 	addi	r3,r3,11
20021f80:	18c00003 	ldbu	r3,0(r3)
20021f84:	1809883a 	mov	r4,r3
20021f88:	e0fffd83 	ldbu	r3,-10(fp)
20021f8c:	00c6303a 	nor	r3,zero,r3
20021f90:	20c6703a 	and	r3,r4,r3
20021f94:	1809883a 	mov	r4,r3
20021f98:	e0fffc17 	ldw	r3,-16(fp)
20021f9c:	1885883a 	add	r2,r3,r2
20021fa0:	108002c4 	addi	r2,r2,11
20021fa4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
20021fa8:	e0bffd03 	ldbu	r2,-12(fp)
20021fac:	e0fffc17 	ldw	r3,-16(fp)
20021fb0:	1885883a 	add	r2,r3,r2
20021fb4:	108002c4 	addi	r2,r2,11
20021fb8:	10800003 	ldbu	r2,0(r2)
20021fbc:	10803fcc 	andi	r2,r2,255
20021fc0:	1000091e 	bne	r2,zero,20021fe8 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
20021fc4:	e0bffc17 	ldw	r2,-16(fp)
20021fc8:	10800283 	ldbu	r2,10(r2)
20021fcc:	1007883a 	mov	r3,r2
20021fd0:	e0bffd43 	ldbu	r2,-11(fp)
20021fd4:	0084303a 	nor	r2,zero,r2
20021fd8:	1884703a 	and	r2,r3,r2
20021fdc:	1007883a 	mov	r3,r2
20021fe0:	e0bffc17 	ldw	r2,-16(fp)
20021fe4:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
20021fe8:	e0bffb17 	ldw	r2,-20(fp)
20021fec:	10800104 	addi	r2,r2,4
20021ff0:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
20021ff4:	e0bffb17 	ldw	r2,-20(fp)
20021ff8:	10800017 	ldw	r2,0(r2)
20021ffc:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
20022000:	e0bffc17 	ldw	r2,-16(fp)
20022004:	103fd91e 	bne	r2,zero,20021f6c <__alt_data_end+0xfffe1f6c>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
20022008:	0001883a 	nop
2002200c:	e037883a 	mov	sp,fp
20022010:	df000017 	ldw	fp,0(sp)
20022014:	dec00104 	addi	sp,sp,4
20022018:	f800283a 	ret

2002201c <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
2002201c:	defffc04 	addi	sp,sp,-16
20022020:	df000315 	stw	fp,12(sp)
20022024:	df000304 	addi	fp,sp,12
20022028:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
2002202c:	e0bfff17 	ldw	r2,-4(fp)
20022030:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
20022034:	e0bfff17 	ldw	r2,-4(fp)
20022038:	108002c4 	addi	r2,r2,11
2002203c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
20022040:	e03ffe05 	stb	zero,-8(fp)
20022044:	00000706 	br	20022064 <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
20022048:	e0bffd17 	ldw	r2,-12(fp)
2002204c:	10c00044 	addi	r3,r2,1
20022050:	e0fffd15 	stw	r3,-12(fp)
20022054:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
20022058:	e0bffe03 	ldbu	r2,-8(fp)
2002205c:	10800044 	addi	r2,r2,1
20022060:	e0bffe05 	stb	r2,-8(fp)
20022064:	e0bffe03 	ldbu	r2,-8(fp)
20022068:	108000f0 	cmpltui	r2,r2,3
2002206c:	103ff61e 	bne	r2,zero,20022048 <__alt_data_end+0xfffe2048>
        *ptbl++ = 0;
    }
}
20022070:	0001883a 	nop
20022074:	e037883a 	mov	sp,fp
20022078:	df000017 	ldw	fp,0(sp)
2002207c:	dec00104 	addi	sp,sp,4
20022080:	f800283a 	ret

20022084 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
20022084:	defffb04 	addi	sp,sp,-20
20022088:	dfc00415 	stw	ra,16(sp)
2002208c:	df000315 	stw	fp,12(sp)
20022090:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
20022094:	0142d004 	movi	r5,2880
20022098:	010800f4 	movhi	r4,8195
2002209c:	2102a104 	addi	r4,r4,2692
200220a0:	00223fc0 	call	200223fc <OS_MemClr>
    pevent1 = &OSEventTbl[0];
200220a4:	008800f4 	movhi	r2,8195
200220a8:	1082a104 	addi	r2,r2,2692
200220ac:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
200220b0:	008800f4 	movhi	r2,8195
200220b4:	1082ad04 	addi	r2,r2,2740
200220b8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
200220bc:	e03ffd0d 	sth	zero,-12(fp)
200220c0:	00001306 	br	20022110 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
200220c4:	e0bffe17 	ldw	r2,-8(fp)
200220c8:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
200220cc:	e0bffe17 	ldw	r2,-8(fp)
200220d0:	e0ffff17 	ldw	r3,-4(fp)
200220d4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
200220d8:	e0bffe17 	ldw	r2,-8(fp)
200220dc:	00c00fc4 	movi	r3,63
200220e0:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
200220e4:	e0bffe17 	ldw	r2,-8(fp)
200220e8:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
200220ec:	e0bffe17 	ldw	r2,-8(fp)
200220f0:	10800c04 	addi	r2,r2,48
200220f4:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
200220f8:	e0bfff17 	ldw	r2,-4(fp)
200220fc:	10800c04 	addi	r2,r2,48
20022100:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
20022104:	e0bffd0b 	ldhu	r2,-12(fp)
20022108:	10800044 	addi	r2,r2,1
2002210c:	e0bffd0d 	sth	r2,-12(fp)
20022110:	e0bffd0b 	ldhu	r2,-12(fp)
20022114:	10800ef0 	cmpltui	r2,r2,59
20022118:	103fea1e 	bne	r2,zero,200220c4 <__alt_data_end+0xfffe20c4>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
2002211c:	e0bffe17 	ldw	r2,-8(fp)
20022120:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
20022124:	e0bffe17 	ldw	r2,-8(fp)
20022128:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
2002212c:	e0bffe17 	ldw	r2,-8(fp)
20022130:	00c00fc4 	movi	r3,63
20022134:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
20022138:	e0bffe17 	ldw	r2,-8(fp)
2002213c:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
20022140:	008800f4 	movhi	r2,8195
20022144:	1082a104 	addi	r2,r2,2692
20022148:	d0a60315 	stw	r2,-26612(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
2002214c:	0001883a 	nop
20022150:	e037883a 	mov	sp,fp
20022154:	dfc00117 	ldw	ra,4(sp)
20022158:	df000017 	ldw	fp,0(sp)
2002215c:	dec00204 	addi	sp,sp,8
20022160:	f800283a 	ret

20022164 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
20022164:	deffff04 	addi	sp,sp,-4
20022168:	df000015 	stw	fp,0(sp)
2002216c:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
20022170:	d0260615 	stw	zero,-26600(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
20022174:	d0260405 	stb	zero,-26608(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
20022178:	d025f605 	stb	zero,-26664(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
2002217c:	d025fe45 	stb	zero,-26631(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
20022180:	d025f645 	stb	zero,-26663(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
20022184:	d025fb15 	stw	zero,-26644(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
20022188:	d025f715 	stw	zero,-26660(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
2002218c:	d0260915 	stw	zero,-26588(gp)
    OSIdleCtrMax  = 0L;
20022190:	d025fc15 	stw	zero,-26640(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
20022194:	d0260805 	stb	zero,-26592(gp)
#endif
}
20022198:	0001883a 	nop
2002219c:	e037883a 	mov	sp,fp
200221a0:	df000017 	ldw	fp,0(sp)
200221a4:	dec00104 	addi	sp,sp,4
200221a8:	f800283a 	ret

200221ac <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
200221ac:	defffd04 	addi	sp,sp,-12
200221b0:	df000215 	stw	fp,8(sp)
200221b4:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
200221b8:	d0260205 	stb	zero,-26616(gp)
    prdytbl       = &OSRdyTbl[0];
200221bc:	d0a60244 	addi	r2,gp,-26615
200221c0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
200221c4:	e03ffe05 	stb	zero,-8(fp)
200221c8:	00000706 	br	200221e8 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
200221cc:	e0bfff17 	ldw	r2,-4(fp)
200221d0:	10c00044 	addi	r3,r2,1
200221d4:	e0ffff15 	stw	r3,-4(fp)
200221d8:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
200221dc:	e0bffe03 	ldbu	r2,-8(fp)
200221e0:	10800044 	addi	r2,r2,1
200221e4:	e0bffe05 	stb	r2,-8(fp)
200221e8:	e0bffe03 	ldbu	r2,-8(fp)
200221ec:	108000f0 	cmpltui	r2,r2,3
200221f0:	103ff61e 	bne	r2,zero,200221cc <__alt_data_end+0xfffe21cc>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
200221f4:	d025f845 	stb	zero,-26655(gp)
    OSPrioHighRdy = 0;
200221f8:	d025f805 	stb	zero,-26656(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
200221fc:	d0260015 	stw	zero,-26624(gp)
    OSTCBCur      = (OS_TCB *)0;
20022200:	d0260515 	stw	zero,-26604(gp)
}
20022204:	0001883a 	nop
20022208:	e037883a 	mov	sp,fp
2002220c:	df000017 	ldw	fp,0(sp)
20022210:	dec00104 	addi	sp,sp,4
20022214:	f800283a 	ret

20022218 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
20022218:	defff804 	addi	sp,sp,-32
2002221c:	dfc00715 	stw	ra,28(sp)
20022220:	df000615 	stw	fp,24(sp)
20022224:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
20022228:	008000c4 	movi	r2,3
2002222c:	d8800415 	stw	r2,16(sp)
20022230:	d8000315 	stw	zero,12(sp)
20022234:	00808004 	movi	r2,512
20022238:	d8800215 	stw	r2,8(sp)
2002223c:	008800f4 	movhi	r2,8195
20022240:	1080a104 	addi	r2,r2,644
20022244:	d8800115 	stw	r2,4(sp)
20022248:	00bfffd4 	movui	r2,65535
2002224c:	d8800015 	stw	r2,0(sp)
20022250:	01c00504 	movi	r7,20
20022254:	018800f4 	movhi	r6,8195
20022258:	3182a004 	addi	r6,r6,2688
2002225c:	000b883a 	mov	r5,zero
20022260:	010800b4 	movhi	r4,8194
20022264:	2109b104 	addi	r4,r4,9924
20022268:	0026d840 	call	20026d84 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
2002226c:	e1bfff04 	addi	r6,fp,-4
20022270:	014800f4 	movhi	r5,8195
20022274:	296c4704 	addi	r5,r5,-20196
20022278:	01000504 	movi	r4,20
2002227c:	00275940 	call	20027594 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
20022280:	0001883a 	nop
20022284:	e037883a 	mov	sp,fp
20022288:	dfc00117 	ldw	ra,4(sp)
2002228c:	df000017 	ldw	fp,0(sp)
20022290:	dec00204 	addi	sp,sp,8
20022294:	f800283a 	ret

20022298 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
20022298:	defff804 	addi	sp,sp,-32
2002229c:	dfc00715 	stw	ra,28(sp)
200222a0:	df000615 	stw	fp,24(sp)
200222a4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
200222a8:	008000c4 	movi	r2,3
200222ac:	d8800415 	stw	r2,16(sp)
200222b0:	d8000315 	stw	zero,12(sp)
200222b4:	00808004 	movi	r2,512
200222b8:	d8800215 	stw	r2,8(sp)
200222bc:	008800f4 	movhi	r2,8195
200222c0:	10be2904 	addi	r2,r2,-1884
200222c4:	d8800115 	stw	r2,4(sp)
200222c8:	00bfff94 	movui	r2,65534
200222cc:	d8800015 	stw	r2,0(sp)
200222d0:	01c004c4 	movi	r7,19
200222d4:	018800f4 	movhi	r6,8195
200222d8:	31802804 	addi	r6,r6,160
200222dc:	000b883a 	mov	r5,zero
200222e0:	010800b4 	movhi	r4,8194
200222e4:	2109c804 	addi	r4,r4,10016
200222e8:	0026d840 	call	20026d84 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
200222ec:	e1bfff04 	addi	r6,fp,-4
200222f0:	014800f4 	movhi	r5,8195
200222f4:	296c4b04 	addi	r5,r5,-20180
200222f8:	010004c4 	movi	r4,19
200222fc:	00275940 	call	20027594 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
20022300:	0001883a 	nop
20022304:	e037883a 	mov	sp,fp
20022308:	dfc00117 	ldw	ra,4(sp)
2002230c:	df000017 	ldw	fp,0(sp)
20022310:	dec00204 	addi	sp,sp,8
20022314:	f800283a 	ret

20022318 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
20022318:	defffb04 	addi	sp,sp,-20
2002231c:	dfc00415 	stw	ra,16(sp)
20022320:	df000315 	stw	fp,12(sp)
20022324:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
20022328:	01414404 	movi	r5,1296
2002232c:	010800f4 	movhi	r4,8195
20022330:	21057104 	addi	r4,r4,5572
20022334:	00223fc0 	call	200223fc <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
20022338:	01401504 	movi	r5,84
2002233c:	010800f4 	movhi	r4,8195
20022340:	2106b504 	addi	r4,r4,6868
20022344:	00223fc0 	call	200223fc <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
20022348:	008800f4 	movhi	r2,8195
2002234c:	10857104 	addi	r2,r2,5572
20022350:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
20022354:	008800f4 	movhi	r2,8195
20022358:	10858c04 	addi	r2,r2,5680
2002235c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
20022360:	e03ffd05 	stb	zero,-12(fp)
20022364:	00001106 	br	200223ac <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
20022368:	e0bffe17 	ldw	r2,-8(fp)
2002236c:	e0ffff17 	ldw	r3,-4(fp)
20022370:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
20022374:	e0bffe17 	ldw	r2,-8(fp)
20022378:	00c00fc4 	movi	r3,63
2002237c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
20022380:	e0bffe17 	ldw	r2,-8(fp)
20022384:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
20022388:	e0bffe17 	ldw	r2,-8(fp)
2002238c:	10801b04 	addi	r2,r2,108
20022390:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
20022394:	e0bfff17 	ldw	r2,-4(fp)
20022398:	10801b04 	addi	r2,r2,108
2002239c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
200223a0:	e0bffd03 	ldbu	r2,-12(fp)
200223a4:	10800044 	addi	r2,r2,1
200223a8:	e0bffd05 	stb	r2,-12(fp)
200223ac:	e0bffd03 	ldbu	r2,-12(fp)
200223b0:	108002f0 	cmpltui	r2,r2,11
200223b4:	103fec1e 	bne	r2,zero,20022368 <__alt_data_end+0xfffe2368>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
200223b8:	e0bffe17 	ldw	r2,-8(fp)
200223bc:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
200223c0:	e0bffe17 	ldw	r2,-8(fp)
200223c4:	00c00fc4 	movi	r3,63
200223c8:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
200223cc:	e0bffe17 	ldw	r2,-8(fp)
200223d0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
200223d4:	d025f915 	stw	zero,-26652(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
200223d8:	008800f4 	movhi	r2,8195
200223dc:	10857104 	addi	r2,r2,5572
200223e0:	d0a5fd15 	stw	r2,-26636(gp)
}
200223e4:	0001883a 	nop
200223e8:	e037883a 	mov	sp,fp
200223ec:	dfc00117 	ldw	ra,4(sp)
200223f0:	df000017 	ldw	fp,0(sp)
200223f4:	dec00204 	addi	sp,sp,8
200223f8:	f800283a 	ret

200223fc <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
200223fc:	defffd04 	addi	sp,sp,-12
20022400:	df000215 	stw	fp,8(sp)
20022404:	df000204 	addi	fp,sp,8
20022408:	e13ffe15 	stw	r4,-8(fp)
2002240c:	2805883a 	mov	r2,r5
20022410:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
20022414:	00000706 	br	20022434 <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
20022418:	e0bffe17 	ldw	r2,-8(fp)
2002241c:	10c00044 	addi	r3,r2,1
20022420:	e0fffe15 	stw	r3,-8(fp)
20022424:	10000005 	stb	zero,0(r2)
        size--;
20022428:	e0bfff0b 	ldhu	r2,-4(fp)
2002242c:	10bfffc4 	addi	r2,r2,-1
20022430:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
20022434:	e0bfff0b 	ldhu	r2,-4(fp)
20022438:	103ff71e 	bne	r2,zero,20022418 <__alt_data_end+0xfffe2418>
        *pdest++ = (INT8U)0;
        size--;
    }
}
2002243c:	0001883a 	nop
20022440:	e037883a 	mov	sp,fp
20022444:	df000017 	ldw	fp,0(sp)
20022448:	dec00104 	addi	sp,sp,4
2002244c:	f800283a 	ret

20022450 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
20022450:	defffc04 	addi	sp,sp,-16
20022454:	df000315 	stw	fp,12(sp)
20022458:	df000304 	addi	fp,sp,12
2002245c:	e13ffd15 	stw	r4,-12(fp)
20022460:	e17ffe15 	stw	r5,-8(fp)
20022464:	3005883a 	mov	r2,r6
20022468:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
2002246c:	00000b06 	br	2002249c <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
20022470:	e0bffd17 	ldw	r2,-12(fp)
20022474:	10c00044 	addi	r3,r2,1
20022478:	e0fffd15 	stw	r3,-12(fp)
2002247c:	e0fffe17 	ldw	r3,-8(fp)
20022480:	19000044 	addi	r4,r3,1
20022484:	e13ffe15 	stw	r4,-8(fp)
20022488:	18c00003 	ldbu	r3,0(r3)
2002248c:	10c00005 	stb	r3,0(r2)
        size--;
20022490:	e0bfff0b 	ldhu	r2,-4(fp)
20022494:	10bfffc4 	addi	r2,r2,-1
20022498:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
2002249c:	e0bfff0b 	ldhu	r2,-4(fp)
200224a0:	103ff31e 	bne	r2,zero,20022470 <__alt_data_end+0xfffe2470>
        *pdest++ = *psrc++;
        size--;
    }
}
200224a4:	0001883a 	nop
200224a8:	e037883a 	mov	sp,fp
200224ac:	df000017 	ldw	fp,0(sp)
200224b0:	dec00104 	addi	sp,sp,4
200224b4:	f800283a 	ret

200224b8 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
200224b8:	defffb04 	addi	sp,sp,-20
200224bc:	dfc00415 	stw	ra,16(sp)
200224c0:	df000315 	stw	fp,12(sp)
200224c4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
200224c8:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200224cc:	0005303a 	rdctl	r2,status
200224d0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200224d4:	e0ffff17 	ldw	r3,-4(fp)
200224d8:	00bfff84 	movi	r2,-2
200224dc:	1884703a 	and	r2,r3,r2
200224e0:	1001703a 	wrctl	status,r2
  
  return context;
200224e4:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
200224e8:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
200224ec:	d0a60403 	ldbu	r2,-26608(gp)
200224f0:	10803fcc 	andi	r2,r2,255
200224f4:	10001a1e 	bne	r2,zero,20022560 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
200224f8:	d0a5f603 	ldbu	r2,-26664(gp)
200224fc:	10803fcc 	andi	r2,r2,255
20022500:	1000171e 	bne	r2,zero,20022560 <OS_Sched+0xa8>
            OS_SchedNew();
20022504:	00225880 	call	20022588 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
20022508:	d0e5f803 	ldbu	r3,-26656(gp)
2002250c:	d0a5f843 	ldbu	r2,-26655(gp)
20022510:	18c03fcc 	andi	r3,r3,255
20022514:	10803fcc 	andi	r2,r2,255
20022518:	18801126 	beq	r3,r2,20022560 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
2002251c:	d0a5f803 	ldbu	r2,-26656(gp)
20022520:	10c03fcc 	andi	r3,r2,255
20022524:	008800f4 	movhi	r2,8195
20022528:	1086b504 	addi	r2,r2,6868
2002252c:	18c7883a 	add	r3,r3,r3
20022530:	18c7883a 	add	r3,r3,r3
20022534:	10c5883a 	add	r2,r2,r3
20022538:	10800017 	ldw	r2,0(r2)
2002253c:	d0a60015 	stw	r2,-26624(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
20022540:	d0a60017 	ldw	r2,-26624(gp)
20022544:	10c00e17 	ldw	r3,56(r2)
20022548:	18c00044 	addi	r3,r3,1
2002254c:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
20022550:	d0a5fb17 	ldw	r2,-26644(gp)
20022554:	10800044 	addi	r2,r2,1
20022558:	d0a5fb15 	stw	r2,-26644(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
2002255c:	002a1d40 	call	2002a1d4 <OSCtxSw>
20022560:	e0bffd17 	ldw	r2,-12(fp)
20022564:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20022568:	e0bffe17 	ldw	r2,-8(fp)
2002256c:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
20022570:	0001883a 	nop
20022574:	e037883a 	mov	sp,fp
20022578:	dfc00117 	ldw	ra,4(sp)
2002257c:	df000017 	ldw	fp,0(sp)
20022580:	dec00204 	addi	sp,sp,8
20022584:	f800283a 	ret

20022588 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
20022588:	defffe04 	addi	sp,sp,-8
2002258c:	df000115 	stw	fp,4(sp)
20022590:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
20022594:	d0a60203 	ldbu	r2,-26616(gp)
20022598:	10c03fcc 	andi	r3,r2,255
2002259c:	008800f4 	movhi	r2,8195
200225a0:	10ac0704 	addi	r2,r2,-20452
200225a4:	10c5883a 	add	r2,r2,r3
200225a8:	10800003 	ldbu	r2,0(r2)
200225ac:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
200225b0:	e0bfff03 	ldbu	r2,-4(fp)
200225b4:	100490fa 	slli	r2,r2,3
200225b8:	1009883a 	mov	r4,r2
200225bc:	e0ffff03 	ldbu	r3,-4(fp)
200225c0:	d0a60244 	addi	r2,gp,-26615
200225c4:	1885883a 	add	r2,r3,r2
200225c8:	10800003 	ldbu	r2,0(r2)
200225cc:	10c03fcc 	andi	r3,r2,255
200225d0:	008800f4 	movhi	r2,8195
200225d4:	10ac0704 	addi	r2,r2,-20452
200225d8:	10c5883a 	add	r2,r2,r3
200225dc:	10800003 	ldbu	r2,0(r2)
200225e0:	2085883a 	add	r2,r4,r2
200225e4:	d0a5f805 	stb	r2,-26656(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
200225e8:	0001883a 	nop
200225ec:	e037883a 	mov	sp,fp
200225f0:	df000017 	ldw	fp,0(sp)
200225f4:	dec00104 	addi	sp,sp,4
200225f8:	f800283a 	ret

200225fc <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
200225fc:	defffc04 	addi	sp,sp,-16
20022600:	df000315 	stw	fp,12(sp)
20022604:	df000304 	addi	fp,sp,12
20022608:	e13ffe15 	stw	r4,-8(fp)
2002260c:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
20022610:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
20022614:	00000b06 	br	20022644 <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
20022618:	e0bffe17 	ldw	r2,-8(fp)
2002261c:	10c00044 	addi	r3,r2,1
20022620:	e0fffe15 	stw	r3,-8(fp)
20022624:	e0ffff17 	ldw	r3,-4(fp)
20022628:	19000044 	addi	r4,r3,1
2002262c:	e13fff15 	stw	r4,-4(fp)
20022630:	18c00003 	ldbu	r3,0(r3)
20022634:	10c00005 	stb	r3,0(r2)
        len++;
20022638:	e0bffd03 	ldbu	r2,-12(fp)
2002263c:	10800044 	addi	r2,r2,1
20022640:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
20022644:	e0bfff17 	ldw	r2,-4(fp)
20022648:	10800003 	ldbu	r2,0(r2)
2002264c:	10803fcc 	andi	r2,r2,255
20022650:	103ff11e 	bne	r2,zero,20022618 <__alt_data_end+0xfffe2618>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
20022654:	e0bffe17 	ldw	r2,-8(fp)
20022658:	10000005 	stb	zero,0(r2)
    return (len);
2002265c:	e0bffd03 	ldbu	r2,-12(fp)
}
20022660:	e037883a 	mov	sp,fp
20022664:	df000017 	ldw	fp,0(sp)
20022668:	dec00104 	addi	sp,sp,4
2002266c:	f800283a 	ret

20022670 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
20022670:	defffd04 	addi	sp,sp,-12
20022674:	df000215 	stw	fp,8(sp)
20022678:	df000204 	addi	fp,sp,8
2002267c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
20022680:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
20022684:	00000606 	br	200226a0 <OS_StrLen+0x30>
        psrc++;
20022688:	e0bfff17 	ldw	r2,-4(fp)
2002268c:	10800044 	addi	r2,r2,1
20022690:	e0bfff15 	stw	r2,-4(fp)
        len++;
20022694:	e0bffe03 	ldbu	r2,-8(fp)
20022698:	10800044 	addi	r2,r2,1
2002269c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
200226a0:	e0bfff17 	ldw	r2,-4(fp)
200226a4:	10800003 	ldbu	r2,0(r2)
200226a8:	10803fcc 	andi	r2,r2,255
200226ac:	103ff61e 	bne	r2,zero,20022688 <__alt_data_end+0xfffe2688>
        psrc++;
        len++;
    }
    return (len);
200226b0:	e0bffe03 	ldbu	r2,-8(fp)
}
200226b4:	e037883a 	mov	sp,fp
200226b8:	df000017 	ldw	fp,0(sp)
200226bc:	dec00104 	addi	sp,sp,4
200226c0:	f800283a 	ret

200226c4 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
200226c4:	defffa04 	addi	sp,sp,-24
200226c8:	dfc00515 	stw	ra,20(sp)
200226cc:	df000415 	stw	fp,16(sp)
200226d0:	df000404 	addi	fp,sp,16
200226d4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200226d8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200226dc:	0005303a 	rdctl	r2,status
200226e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200226e4:	e0fffd17 	ldw	r3,-12(fp)
200226e8:	00bfff84 	movi	r2,-2
200226ec:	1884703a 	and	r2,r3,r2
200226f0:	1001703a 	wrctl	status,r2
  
  return context;
200226f4:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
200226f8:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
200226fc:	d0a5f717 	ldw	r2,-26660(gp)
20022700:	10800044 	addi	r2,r2,1
20022704:	d0a5f715 	stw	r2,-26660(gp)
20022708:	e0bffc17 	ldw	r2,-16(fp)
2002270c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20022710:	e0bffe17 	ldw	r2,-8(fp)
20022714:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
20022718:	002a4e80 	call	2002a4e8 <OSTaskIdleHook>
    }
2002271c:	003fef06 	br	200226dc <__alt_data_end+0xfffe26dc>

20022720 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
20022720:	defffa04 	addi	sp,sp,-24
20022724:	dfc00515 	stw	ra,20(sp)
20022728:	df000415 	stw	fp,16(sp)
2002272c:	df000404 	addi	fp,sp,16
20022730:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20022734:	e03ffc15 	stw	zero,-16(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
20022738:	00000206 	br	20022744 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
2002273c:	01003204 	movi	r4,200
20022740:	0027e540 	call	20027e54 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
20022744:	d0a60803 	ldbu	r2,-26592(gp)
20022748:	10803fcc 	andi	r2,r2,255
2002274c:	103ffb26 	beq	r2,zero,2002273c <__alt_data_end+0xfffe273c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
20022750:	d0a5fc17 	ldw	r2,-26640(gp)
20022754:	01401904 	movi	r5,100
20022758:	1009883a 	mov	r4,r2
2002275c:	002af000 	call	2002af00 <__udivsi3>
20022760:	d0a5fc15 	stw	r2,-26640(gp)
    if (OSIdleCtrMax == 0L) {
20022764:	d0a5fc17 	ldw	r2,-26640(gp)
20022768:	1000031e 	bne	r2,zero,20022778 <OS_TaskStat+0x58>
        OSCPUUsage = 0;
2002276c:	d025fe05 	stb	zero,-26632(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
20022770:	01003fc4 	movi	r4,255
20022774:	0027adc0 	call	20027adc <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20022778:	0005303a 	rdctl	r2,status
2002277c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20022780:	e0fffd17 	ldw	r3,-12(fp)
20022784:	00bfff84 	movi	r2,-2
20022788:	1884703a 	and	r2,r3,r2
2002278c:	1001703a 	wrctl	status,r2
  
  return context;
20022790:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
20022794:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
20022798:	d0a5f717 	ldw	r2,-26660(gp)
2002279c:	d0a60915 	stw	r2,-26588(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
200227a0:	d025f715 	stw	zero,-26660(gp)
200227a4:	e0bffc17 	ldw	r2,-16(fp)
200227a8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200227ac:	e0bffe17 	ldw	r2,-8(fp)
200227b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
200227b4:	d0a60917 	ldw	r2,-26588(gp)
200227b8:	d0e5fc17 	ldw	r3,-26640(gp)
200227bc:	180b883a 	mov	r5,r3
200227c0:	1009883a 	mov	r4,r2
200227c4:	002af000 	call	2002af00 <__udivsi3>
200227c8:	1007883a 	mov	r3,r2
200227cc:	00801904 	movi	r2,100
200227d0:	10c5c83a 	sub	r2,r2,r3
200227d4:	d0a5fe05 	stb	r2,-26632(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
200227d8:	002a4680 	call	2002a468 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
200227dc:	00227ec0 	call	200227ec <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
200227e0:	01001904 	movi	r4,100
200227e4:	0027e540 	call	20027e54 <OSTimeDly>
    }
200227e8:	003fe306 	br	20022778 <__alt_data_end+0xfffe2778>

200227ec <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
200227ec:	defffa04 	addi	sp,sp,-24
200227f0:	dfc00515 	stw	ra,20(sp)
200227f4:	df000415 	stw	fp,16(sp)
200227f8:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
200227fc:	e03ffc05 	stb	zero,-16(fp)
20022800:	00002406 	br	20022894 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
20022804:	e0bffc03 	ldbu	r2,-16(fp)
20022808:	e0fffe04 	addi	r3,fp,-8
2002280c:	180b883a 	mov	r5,r3
20022810:	1009883a 	mov	r4,r2
20022814:	002791c0 	call	2002791c <OSTaskStkChk>
20022818:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
2002281c:	e0bffc43 	ldbu	r2,-15(fp)
20022820:	1000191e 	bne	r2,zero,20022888 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
20022824:	e0fffc03 	ldbu	r3,-16(fp)
20022828:	008800f4 	movhi	r2,8195
2002282c:	1086b504 	addi	r2,r2,6868
20022830:	18c7883a 	add	r3,r3,r3
20022834:	18c7883a 	add	r3,r3,r3
20022838:	10c5883a 	add	r2,r2,r3
2002283c:	10800017 	ldw	r2,0(r2)
20022840:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
20022844:	e0bffd17 	ldw	r2,-12(fp)
20022848:	10000f26 	beq	r2,zero,20022888 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
2002284c:	e0bffd17 	ldw	r2,-12(fp)
20022850:	10800060 	cmpeqi	r2,r2,1
20022854:	10000c1e 	bne	r2,zero,20022888 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
20022858:	e0bffd17 	ldw	r2,-12(fp)
2002285c:	10c00217 	ldw	r3,8(r2)
20022860:	e0bffd17 	ldw	r2,-12(fp)
20022864:	10800317 	ldw	r2,12(r2)
20022868:	1085883a 	add	r2,r2,r2
2002286c:	1085883a 	add	r2,r2,r2
20022870:	1887883a 	add	r3,r3,r2
20022874:	e0bffd17 	ldw	r2,-12(fp)
20022878:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
2002287c:	e0ffff17 	ldw	r3,-4(fp)
20022880:	e0bffd17 	ldw	r2,-12(fp)
20022884:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
20022888:	e0bffc03 	ldbu	r2,-16(fp)
2002288c:	10800044 	addi	r2,r2,1
20022890:	e0bffc05 	stb	r2,-16(fp)
20022894:	e0bffc03 	ldbu	r2,-16(fp)
20022898:	10800570 	cmpltui	r2,r2,21
2002289c:	103fd91e 	bne	r2,zero,20022804 <__alt_data_end+0xfffe2804>
#endif
                }
            }
        }
    }
}
200228a0:	0001883a 	nop
200228a4:	e037883a 	mov	sp,fp
200228a8:	dfc00117 	ldw	ra,4(sp)
200228ac:	df000017 	ldw	fp,0(sp)
200228b0:	dec00204 	addi	sp,sp,8
200228b4:	f800283a 	ret

200228b8 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
200228b8:	defff204 	addi	sp,sp,-56
200228bc:	dfc00d15 	stw	ra,52(sp)
200228c0:	df000c15 	stw	fp,48(sp)
200228c4:	df000c04 	addi	fp,sp,48
200228c8:	e17ffc15 	stw	r5,-16(fp)
200228cc:	e1bffd15 	stw	r6,-12(fp)
200228d0:	3807883a 	mov	r3,r7
200228d4:	e0800417 	ldw	r2,16(fp)
200228d8:	e13ffb05 	stb	r4,-20(fp)
200228dc:	e0fffe0d 	sth	r3,-8(fp)
200228e0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
200228e4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200228e8:	0005303a 	rdctl	r2,status
200228ec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200228f0:	e0fffa17 	ldw	r3,-24(fp)
200228f4:	00bfff84 	movi	r2,-2
200228f8:	1884703a 	and	r2,r3,r2
200228fc:	1001703a 	wrctl	status,r2
  
  return context;
20022900:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
20022904:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
20022908:	d0a5fd17 	ldw	r2,-26636(gp)
2002290c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
20022910:	e0bff617 	ldw	r2,-40(fp)
20022914:	10009326 	beq	r2,zero,20022b64 <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
20022918:	e0bff617 	ldw	r2,-40(fp)
2002291c:	10800517 	ldw	r2,20(r2)
20022920:	d0a5fd15 	stw	r2,-26636(gp)
20022924:	e0bff417 	ldw	r2,-48(fp)
20022928:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002292c:	e0bff817 	ldw	r2,-32(fp)
20022930:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
20022934:	e0bff617 	ldw	r2,-40(fp)
20022938:	e0fffc17 	ldw	r3,-16(fp)
2002293c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
20022940:	e0bff617 	ldw	r2,-40(fp)
20022944:	e0fffb03 	ldbu	r3,-20(fp)
20022948:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
2002294c:	e0bff617 	ldw	r2,-40(fp)
20022950:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
20022954:	e0bff617 	ldw	r2,-40(fp)
20022958:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
2002295c:	e0bff617 	ldw	r2,-40(fp)
20022960:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
20022964:	e0bff617 	ldw	r2,-40(fp)
20022968:	e0c00317 	ldw	r3,12(fp)
2002296c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
20022970:	e0bff617 	ldw	r2,-40(fp)
20022974:	e0c00217 	ldw	r3,8(fp)
20022978:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
2002297c:	e0bff617 	ldw	r2,-40(fp)
20022980:	e0fffd17 	ldw	r3,-12(fp)
20022984:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
20022988:	e0bff617 	ldw	r2,-40(fp)
2002298c:	e0ffff0b 	ldhu	r3,-4(fp)
20022990:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
20022994:	e0bff617 	ldw	r2,-40(fp)
20022998:	e0fffe0b 	ldhu	r3,-8(fp)
2002299c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
200229a0:	e0bff617 	ldw	r2,-40(fp)
200229a4:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
200229a8:	e0bffb03 	ldbu	r2,-20(fp)
200229ac:	1004d0fa 	srli	r2,r2,3
200229b0:	1007883a 	mov	r3,r2
200229b4:	e0bff617 	ldw	r2,-40(fp)
200229b8:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
200229bc:	e0bffb03 	ldbu	r2,-20(fp)
200229c0:	108001cc 	andi	r2,r2,7
200229c4:	1007883a 	mov	r3,r2
200229c8:	e0bff617 	ldw	r2,-40(fp)
200229cc:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
200229d0:	e0bff617 	ldw	r2,-40(fp)
200229d4:	10800d03 	ldbu	r2,52(r2)
200229d8:	10803fcc 	andi	r2,r2,255
200229dc:	00c00044 	movi	r3,1
200229e0:	1884983a 	sll	r2,r3,r2
200229e4:	1007883a 	mov	r3,r2
200229e8:	e0bff617 	ldw	r2,-40(fp)
200229ec:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
200229f0:	e0bff617 	ldw	r2,-40(fp)
200229f4:	10800cc3 	ldbu	r2,51(r2)
200229f8:	10803fcc 	andi	r2,r2,255
200229fc:	00c00044 	movi	r3,1
20022a00:	1884983a 	sll	r2,r3,r2
20022a04:	1007883a 	mov	r3,r2
20022a08:	e0bff617 	ldw	r2,-40(fp)
20022a0c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
20022a10:	e0bff617 	ldw	r2,-40(fp)
20022a14:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
20022a18:	e0bff617 	ldw	r2,-40(fp)
20022a1c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
20022a20:	e0bff617 	ldw	r2,-40(fp)
20022a24:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
20022a28:	e0bff617 	ldw	r2,-40(fp)
20022a2c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
20022a30:	e0bff617 	ldw	r2,-40(fp)
20022a34:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
20022a38:	e0bff617 	ldw	r2,-40(fp)
20022a3c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
20022a40:	e0bff617 	ldw	r2,-40(fp)
20022a44:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
20022a48:	e0bff617 	ldw	r2,-40(fp)
20022a4c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
20022a50:	e0bff617 	ldw	r2,-40(fp)
20022a54:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
20022a58:	e0bff617 	ldw	r2,-40(fp)
20022a5c:	00c00fc4 	movi	r3,63
20022a60:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
20022a64:	e0bff617 	ldw	r2,-40(fp)
20022a68:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
20022a6c:	e13ff617 	ldw	r4,-40(fp)
20022a70:	002a5080 	call	2002a508 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
20022a74:	e13ff617 	ldw	r4,-40(fp)
20022a78:	002a4000 	call	2002a400 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20022a7c:	0005303a 	rdctl	r2,status
20022a80:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20022a84:	e0fff517 	ldw	r3,-44(fp)
20022a88:	00bfff84 	movi	r2,-2
20022a8c:	1884703a 	and	r2,r3,r2
20022a90:	1001703a 	wrctl	status,r2
  
  return context;
20022a94:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
20022a98:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
20022a9c:	e0fffb03 	ldbu	r3,-20(fp)
20022aa0:	008800f4 	movhi	r2,8195
20022aa4:	1086b504 	addi	r2,r2,6868
20022aa8:	18c7883a 	add	r3,r3,r3
20022aac:	18c7883a 	add	r3,r3,r3
20022ab0:	10c5883a 	add	r2,r2,r3
20022ab4:	e0fff617 	ldw	r3,-40(fp)
20022ab8:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
20022abc:	d0e5f917 	ldw	r3,-26652(gp)
20022ac0:	e0bff617 	ldw	r2,-40(fp)
20022ac4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
20022ac8:	e0bff617 	ldw	r2,-40(fp)
20022acc:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
20022ad0:	d0a5f917 	ldw	r2,-26652(gp)
20022ad4:	10000326 	beq	r2,zero,20022ae4 <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
20022ad8:	d0a5f917 	ldw	r2,-26652(gp)
20022adc:	e0fff617 	ldw	r3,-40(fp)
20022ae0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
20022ae4:	e0bff617 	ldw	r2,-40(fp)
20022ae8:	d0a5f915 	stw	r2,-26652(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
20022aec:	e0bff617 	ldw	r2,-40(fp)
20022af0:	10c00d83 	ldbu	r3,54(r2)
20022af4:	d0a60203 	ldbu	r2,-26616(gp)
20022af8:	1884b03a 	or	r2,r3,r2
20022afc:	d0a60205 	stb	r2,-26616(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
20022b00:	e0bff617 	ldw	r2,-40(fp)
20022b04:	10800d03 	ldbu	r2,52(r2)
20022b08:	10c03fcc 	andi	r3,r2,255
20022b0c:	e0bff617 	ldw	r2,-40(fp)
20022b10:	10800d03 	ldbu	r2,52(r2)
20022b14:	11003fcc 	andi	r4,r2,255
20022b18:	d0a60244 	addi	r2,gp,-26615
20022b1c:	2085883a 	add	r2,r4,r2
20022b20:	11000003 	ldbu	r4,0(r2)
20022b24:	e0bff617 	ldw	r2,-40(fp)
20022b28:	10800d43 	ldbu	r2,53(r2)
20022b2c:	2084b03a 	or	r2,r4,r2
20022b30:	1009883a 	mov	r4,r2
20022b34:	d0a60244 	addi	r2,gp,-26615
20022b38:	1885883a 	add	r2,r3,r2
20022b3c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
20022b40:	d0a5fe43 	ldbu	r2,-26631(gp)
20022b44:	10800044 	addi	r2,r2,1
20022b48:	d0a5fe45 	stb	r2,-26631(gp)
20022b4c:	e0bff417 	ldw	r2,-48(fp)
20022b50:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20022b54:	e0bff717 	ldw	r2,-36(fp)
20022b58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
20022b5c:	0005883a 	mov	r2,zero
20022b60:	00000506 	br	20022b78 <OS_TCBInit+0x2c0>
20022b64:	e0bff417 	ldw	r2,-48(fp)
20022b68:	e0bff915 	stw	r2,-28(fp)
20022b6c:	e0bff917 	ldw	r2,-28(fp)
20022b70:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
20022b74:	00801084 	movi	r2,66
}
20022b78:	e037883a 	mov	sp,fp
20022b7c:	dfc00117 	ldw	ra,4(sp)
20022b80:	df000017 	ldw	fp,0(sp)
20022b84:	dec00204 	addi	sp,sp,8
20022b88:	f800283a 	ret

20022b8c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
20022b8c:	defffe04 	addi	sp,sp,-8
20022b90:	df000115 	stw	fp,4(sp)
20022b94:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
20022b98:	d0a00304 	addi	r2,gp,-32756
20022b9c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
20022ba0:	d0a00404 	addi	r2,gp,-32752
20022ba4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
20022ba8:	d0a00584 	addi	r2,gp,-32746
20022bac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
20022bb0:	d0a00604 	addi	r2,gp,-32744
20022bb4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
20022bb8:	d0a00504 	addi	r2,gp,-32748
20022bbc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
20022bc0:	d0a00684 	addi	r2,gp,-32742
20022bc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
20022bc8:	d0a00704 	addi	r2,gp,-32740
20022bcc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
20022bd0:	d0a00784 	addi	r2,gp,-32738
20022bd4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
20022bd8:	d0a00804 	addi	r2,gp,-32736
20022bdc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
20022be0:	d0a00884 	addi	r2,gp,-32734
20022be4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
20022be8:	d0a00904 	addi	r2,gp,-32732
20022bec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
20022bf0:	d0a00984 	addi	r2,gp,-32730
20022bf4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
20022bf8:	d0a00a04 	addi	r2,gp,-32728
20022bfc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
20022c00:	d0a00a84 	addi	r2,gp,-32726
20022c04:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
20022c08:	d0a00b04 	addi	r2,gp,-32724
20022c0c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
20022c10:	d0a00b84 	addi	r2,gp,-32722
20022c14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
20022c18:	d0a00c04 	addi	r2,gp,-32720
20022c1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
20022c20:	d0a00c84 	addi	r2,gp,-32718
20022c24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
20022c28:	d0a00d04 	addi	r2,gp,-32716
20022c2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
20022c30:	d0a00d84 	addi	r2,gp,-32714
20022c34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
20022c38:	d0a00e04 	addi	r2,gp,-32712
20022c3c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
20022c40:	d0a00e84 	addi	r2,gp,-32710
20022c44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
20022c48:	d0a00f04 	addi	r2,gp,-32708
20022c4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
20022c50:	d0a00f84 	addi	r2,gp,-32706
20022c54:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
20022c58:	d0a01004 	addi	r2,gp,-32704
20022c5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
20022c60:	d0a01084 	addi	r2,gp,-32702
20022c64:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
20022c68:	d0a01104 	addi	r2,gp,-32700
20022c6c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
20022c70:	d0a01184 	addi	r2,gp,-32698
20022c74:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
20022c78:	d0a01204 	addi	r2,gp,-32696
20022c7c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
20022c80:	d0a01284 	addi	r2,gp,-32694
20022c84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
20022c88:	d0a01304 	addi	r2,gp,-32692
20022c8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
20022c90:	d0a01384 	addi	r2,gp,-32690
20022c94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
20022c98:	d0a01404 	addi	r2,gp,-32688
20022c9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
20022ca0:	d0a01484 	addi	r2,gp,-32686
20022ca4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
20022ca8:	d0a01504 	addi	r2,gp,-32684
20022cac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
20022cb0:	d0a01584 	addi	r2,gp,-32682
20022cb4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
20022cb8:	d0a01604 	addi	r2,gp,-32680
20022cbc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
20022cc0:	d0a01684 	addi	r2,gp,-32678
20022cc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
20022cc8:	d0a01704 	addi	r2,gp,-32676
20022ccc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
20022cd0:	d0a01784 	addi	r2,gp,-32674
20022cd4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
20022cd8:	d0a01804 	addi	r2,gp,-32672
20022cdc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
20022ce0:	d0a01884 	addi	r2,gp,-32670
20022ce4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
20022ce8:	d0a01904 	addi	r2,gp,-32668
20022cec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
20022cf0:	d0a01984 	addi	r2,gp,-32666
20022cf4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
20022cf8:	d0a01a04 	addi	r2,gp,-32664
20022cfc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
20022d00:	d0a01f04 	addi	r2,gp,-32644
20022d04:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
20022d08:	0001883a 	nop
20022d0c:	e037883a 	mov	sp,fp
20022d10:	df000017 	ldw	fp,0(sp)
20022d14:	dec00104 	addi	sp,sp,4
20022d18:	f800283a 	ret

20022d1c <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
20022d1c:	defff204 	addi	sp,sp,-56
20022d20:	df000d15 	stw	fp,52(sp)
20022d24:	df000d04 	addi	fp,sp,52
20022d28:	e13ffc15 	stw	r4,-16(fp)
20022d2c:	2807883a 	mov	r3,r5
20022d30:	3005883a 	mov	r2,r6
20022d34:	e1ffff15 	stw	r7,-4(fp)
20022d38:	e0fffd0d 	sth	r3,-12(fp)
20022d3c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
20022d40:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
20022d44:	e0bfff17 	ldw	r2,-4(fp)
20022d48:	1000021e 	bne	r2,zero,20022d54 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
20022d4c:	0005883a 	mov	r2,zero
20022d50:	0000b006 	br	20023014 <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
20022d54:	e0bffc17 	ldw	r2,-16(fp)
20022d58:	1000051e 	bne	r2,zero,20022d70 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
20022d5c:	e0bfff17 	ldw	r2,-4(fp)
20022d60:	00c01b84 	movi	r3,110
20022d64:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
20022d68:	0005883a 	mov	r2,zero
20022d6c:	0000a906 	br	20023014 <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
20022d70:	e0bffc17 	ldw	r2,-16(fp)
20022d74:	10800003 	ldbu	r2,0(r2)
20022d78:	10803fcc 	andi	r2,r2,255
20022d7c:	10800160 	cmpeqi	r2,r2,5
20022d80:	1000051e 	bne	r2,zero,20022d98 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
20022d84:	e0bfff17 	ldw	r2,-4(fp)
20022d88:	00c00044 	movi	r3,1
20022d8c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
20022d90:	0005883a 	mov	r2,zero
20022d94:	00009f06 	br	20023014 <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
20022d98:	e0fffe03 	ldbu	r3,-8(fp)
20022d9c:	00bfe004 	movi	r2,-128
20022da0:	1884703a 	and	r2,r3,r2
20022da4:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
20022da8:	e0bff503 	ldbu	r2,-44(fp)
20022dac:	10000626 	beq	r2,zero,20022dc8 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
20022db0:	e0bffe03 	ldbu	r2,-8(fp)
20022db4:	10801fcc 	andi	r2,r2,127
20022db8:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
20022dbc:	00800044 	movi	r2,1
20022dc0:	e0bff385 	stb	r2,-50(fp)
20022dc4:	00000106 	br	20022dcc <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
20022dc8:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
20022dcc:	e0bfff17 	ldw	r2,-4(fp)
20022dd0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20022dd4:	0005303a 	rdctl	r2,status
20022dd8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20022ddc:	e0fffb17 	ldw	r3,-20(fp)
20022de0:	00bfff84 	movi	r2,-2
20022de4:	1884703a 	and	r2,r3,r2
20022de8:	1001703a 	wrctl	status,r2
  
  return context;
20022dec:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
20022df0:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
20022df4:	e0bffe03 	ldbu	r2,-8(fp)
20022df8:	10c00060 	cmpeqi	r3,r2,1
20022dfc:	18005f1e 	bne	r3,zero,20022f7c <OSFlagAccept+0x260>
20022e00:	10c00088 	cmpgei	r3,r2,2
20022e04:	1800021e 	bne	r3,zero,20022e10 <OSFlagAccept+0xf4>
20022e08:	10003f26 	beq	r2,zero,20022f08 <OSFlagAccept+0x1ec>
20022e0c:	00007706 	br	20022fec <OSFlagAccept+0x2d0>
20022e10:	10c000a0 	cmpeqi	r3,r2,2
20022e14:	1800031e 	bne	r3,zero,20022e24 <OSFlagAccept+0x108>
20022e18:	108000e0 	cmpeqi	r2,r2,3
20022e1c:	10001e1e 	bne	r2,zero,20022e98 <OSFlagAccept+0x17c>
20022e20:	00007206 	br	20022fec <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
20022e24:	e0bffc17 	ldw	r2,-16(fp)
20022e28:	10c0020b 	ldhu	r3,8(r2)
20022e2c:	e0bffd0b 	ldhu	r2,-12(fp)
20022e30:	1884703a 	and	r2,r3,r2
20022e34:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
20022e38:	e0fff30b 	ldhu	r3,-52(fp)
20022e3c:	e0bffd0b 	ldhu	r2,-12(fp)
20022e40:	18800d1e 	bne	r3,r2,20022e78 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20022e44:	e0bff383 	ldbu	r2,-50(fp)
20022e48:	10800058 	cmpnei	r2,r2,1
20022e4c:	10000d1e 	bne	r2,zero,20022e84 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
20022e50:	e0bffc17 	ldw	r2,-16(fp)
20022e54:	1080020b 	ldhu	r2,8(r2)
20022e58:	1007883a 	mov	r3,r2
20022e5c:	e0bff30b 	ldhu	r2,-52(fp)
20022e60:	0084303a 	nor	r2,zero,r2
20022e64:	1884703a 	and	r2,r3,r2
20022e68:	1007883a 	mov	r3,r2
20022e6c:	e0bffc17 	ldw	r2,-16(fp)
20022e70:	10c0020d 	sth	r3,8(r2)
20022e74:	00000306 	br	20022e84 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
20022e78:	e0bfff17 	ldw	r2,-4(fp)
20022e7c:	00c01c04 	movi	r3,112
20022e80:	10c00005 	stb	r3,0(r2)
20022e84:	e0bff417 	ldw	r2,-48(fp)
20022e88:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20022e8c:	e0bff617 	ldw	r2,-40(fp)
20022e90:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
20022e94:	00005e06 	br	20023010 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
20022e98:	e0bffc17 	ldw	r2,-16(fp)
20022e9c:	10c0020b 	ldhu	r3,8(r2)
20022ea0:	e0bffd0b 	ldhu	r2,-12(fp)
20022ea4:	1884703a 	and	r2,r3,r2
20022ea8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
20022eac:	e0bff30b 	ldhu	r2,-52(fp)
20022eb0:	10000d26 	beq	r2,zero,20022ee8 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20022eb4:	e0bff383 	ldbu	r2,-50(fp)
20022eb8:	10800058 	cmpnei	r2,r2,1
20022ebc:	10000d1e 	bne	r2,zero,20022ef4 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
20022ec0:	e0bffc17 	ldw	r2,-16(fp)
20022ec4:	1080020b 	ldhu	r2,8(r2)
20022ec8:	1007883a 	mov	r3,r2
20022ecc:	e0bff30b 	ldhu	r2,-52(fp)
20022ed0:	0084303a 	nor	r2,zero,r2
20022ed4:	1884703a 	and	r2,r3,r2
20022ed8:	1007883a 	mov	r3,r2
20022edc:	e0bffc17 	ldw	r2,-16(fp)
20022ee0:	10c0020d 	sth	r3,8(r2)
20022ee4:	00000306 	br	20022ef4 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
20022ee8:	e0bfff17 	ldw	r2,-4(fp)
20022eec:	00c01c04 	movi	r3,112
20022ef0:	10c00005 	stb	r3,0(r2)
20022ef4:	e0bff417 	ldw	r2,-48(fp)
20022ef8:	e0bff715 	stw	r2,-36(fp)
20022efc:	e0bff717 	ldw	r2,-36(fp)
20022f00:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
20022f04:	00004206 	br	20023010 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
20022f08:	e0bffc17 	ldw	r2,-16(fp)
20022f0c:	1080020b 	ldhu	r2,8(r2)
20022f10:	0084303a 	nor	r2,zero,r2
20022f14:	1007883a 	mov	r3,r2
20022f18:	e0bffd0b 	ldhu	r2,-12(fp)
20022f1c:	1884703a 	and	r2,r3,r2
20022f20:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
20022f24:	e0fff30b 	ldhu	r3,-52(fp)
20022f28:	e0bffd0b 	ldhu	r2,-12(fp)
20022f2c:	18800b1e 	bne	r3,r2,20022f5c <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20022f30:	e0bff383 	ldbu	r2,-50(fp)
20022f34:	10800058 	cmpnei	r2,r2,1
20022f38:	10000b1e 	bne	r2,zero,20022f68 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
20022f3c:	e0bffc17 	ldw	r2,-16(fp)
20022f40:	10c0020b 	ldhu	r3,8(r2)
20022f44:	e0bff30b 	ldhu	r2,-52(fp)
20022f48:	1884b03a 	or	r2,r3,r2
20022f4c:	1007883a 	mov	r3,r2
20022f50:	e0bffc17 	ldw	r2,-16(fp)
20022f54:	10c0020d 	sth	r3,8(r2)
20022f58:	00000306 	br	20022f68 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
20022f5c:	e0bfff17 	ldw	r2,-4(fp)
20022f60:	00c01c04 	movi	r3,112
20022f64:	10c00005 	stb	r3,0(r2)
20022f68:	e0bff417 	ldw	r2,-48(fp)
20022f6c:	e0bff815 	stw	r2,-32(fp)
20022f70:	e0bff817 	ldw	r2,-32(fp)
20022f74:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
20022f78:	00002506 	br	20023010 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
20022f7c:	e0bffc17 	ldw	r2,-16(fp)
20022f80:	1080020b 	ldhu	r2,8(r2)
20022f84:	0084303a 	nor	r2,zero,r2
20022f88:	1007883a 	mov	r3,r2
20022f8c:	e0bffd0b 	ldhu	r2,-12(fp)
20022f90:	1884703a 	and	r2,r3,r2
20022f94:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
20022f98:	e0bff30b 	ldhu	r2,-52(fp)
20022f9c:	10000b26 	beq	r2,zero,20022fcc <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20022fa0:	e0bff383 	ldbu	r2,-50(fp)
20022fa4:	10800058 	cmpnei	r2,r2,1
20022fa8:	10000b1e 	bne	r2,zero,20022fd8 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
20022fac:	e0bffc17 	ldw	r2,-16(fp)
20022fb0:	10c0020b 	ldhu	r3,8(r2)
20022fb4:	e0bff30b 	ldhu	r2,-52(fp)
20022fb8:	1884b03a 	or	r2,r3,r2
20022fbc:	1007883a 	mov	r3,r2
20022fc0:	e0bffc17 	ldw	r2,-16(fp)
20022fc4:	10c0020d 	sth	r3,8(r2)
20022fc8:	00000306 	br	20022fd8 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
20022fcc:	e0bfff17 	ldw	r2,-4(fp)
20022fd0:	00c01c04 	movi	r3,112
20022fd4:	10c00005 	stb	r3,0(r2)
20022fd8:	e0bff417 	ldw	r2,-48(fp)
20022fdc:	e0bff915 	stw	r2,-28(fp)
20022fe0:	e0bff917 	ldw	r2,-28(fp)
20022fe4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
20022fe8:	00000906 	br	20023010 <OSFlagAccept+0x2f4>
20022fec:	e0bff417 	ldw	r2,-48(fp)
20022ff0:	e0bffa15 	stw	r2,-24(fp)
20022ff4:	e0bffa17 	ldw	r2,-24(fp)
20022ff8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
20022ffc:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
20023000:	e0bfff17 	ldw	r2,-4(fp)
20023004:	00c01bc4 	movi	r3,111
20023008:	10c00005 	stb	r3,0(r2)
             break;
2002300c:	0001883a 	nop
    }
    return (flags_rdy);
20023010:	e0bff30b 	ldhu	r2,-52(fp)
}
20023014:	e037883a 	mov	sp,fp
20023018:	df000017 	ldw	fp,0(sp)
2002301c:	dec00104 	addi	sp,sp,4
20023020:	f800283a 	ret

20023024 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
20023024:	defff804 	addi	sp,sp,-32
20023028:	df000715 	stw	fp,28(sp)
2002302c:	df000704 	addi	fp,sp,28
20023030:	2005883a 	mov	r2,r4
20023034:	e17fff15 	stw	r5,-4(fp)
20023038:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
2002303c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
20023040:	e0bfff17 	ldw	r2,-4(fp)
20023044:	1000021e 	bne	r2,zero,20023050 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
20023048:	0005883a 	mov	r2,zero
2002304c:	00003306 	br	2002311c <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
20023050:	d0a60403 	ldbu	r2,-26608(gp)
20023054:	10803fcc 	andi	r2,r2,255
20023058:	10000526 	beq	r2,zero,20023070 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
2002305c:	e0bfff17 	ldw	r2,-4(fp)
20023060:	00c00404 	movi	r3,16
20023064:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
20023068:	0005883a 	mov	r2,zero
2002306c:	00002b06 	br	2002311c <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20023070:	0005303a 	rdctl	r2,status
20023074:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023078:	e0fffd17 	ldw	r3,-12(fp)
2002307c:	00bfff84 	movi	r2,-2
20023080:	1884703a 	and	r2,r3,r2
20023084:	1001703a 	wrctl	status,r2
  
  return context;
20023088:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
2002308c:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
20023090:	d0a60717 	ldw	r2,-26596(gp)
20023094:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
20023098:	e0bffb17 	ldw	r2,-20(fp)
2002309c:	10001726 	beq	r2,zero,200230fc <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
200230a0:	d0a60717 	ldw	r2,-26596(gp)
200230a4:	10800117 	ldw	r2,4(r2)
200230a8:	d0a60715 	stw	r2,-26596(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
200230ac:	e0bffb17 	ldw	r2,-20(fp)
200230b0:	00c00144 	movi	r3,5
200230b4:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
200230b8:	e0bffb17 	ldw	r2,-20(fp)
200230bc:	e0fffe0b 	ldhu	r3,-8(fp)
200230c0:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
200230c4:	e0bffb17 	ldw	r2,-20(fp)
200230c8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
200230cc:	e0bffb17 	ldw	r2,-20(fp)
200230d0:	00c00fc4 	movi	r3,63
200230d4:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
200230d8:	e0bffb17 	ldw	r2,-20(fp)
200230dc:	100002c5 	stb	zero,11(r2)
200230e0:	e0bff917 	ldw	r2,-28(fp)
200230e4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200230e8:	e0bffa17 	ldw	r2,-24(fp)
200230ec:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
200230f0:	e0bfff17 	ldw	r2,-4(fp)
200230f4:	10000005 	stb	zero,0(r2)
200230f8:	00000706 	br	20023118 <OSFlagCreate+0xf4>
200230fc:	e0bff917 	ldw	r2,-28(fp)
20023100:	e0bffc15 	stw	r2,-16(fp)
20023104:	e0bffc17 	ldw	r2,-16(fp)
20023108:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
2002310c:	e0bfff17 	ldw	r2,-4(fp)
20023110:	00c01c84 	movi	r3,114
20023114:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
20023118:	e0bffb17 	ldw	r2,-20(fp)
}
2002311c:	e037883a 	mov	sp,fp
20023120:	df000017 	ldw	fp,0(sp)
20023124:	dec00104 	addi	sp,sp,4
20023128:	f800283a 	ret

2002312c <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
2002312c:	defff204 	addi	sp,sp,-56
20023130:	dfc00d15 	stw	ra,52(sp)
20023134:	df000c15 	stw	fp,48(sp)
20023138:	df000c04 	addi	fp,sp,48
2002313c:	e13ffd15 	stw	r4,-12(fp)
20023140:	2805883a 	mov	r2,r5
20023144:	e1bfff15 	stw	r6,-4(fp)
20023148:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
2002314c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
20023150:	e0bfff17 	ldw	r2,-4(fp)
20023154:	1000021e 	bne	r2,zero,20023160 <OSFlagDel+0x34>
        return (pgrp);
20023158:	e0bffd17 	ldw	r2,-12(fp)
2002315c:	00008006 	br	20023360 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
20023160:	e0bffd17 	ldw	r2,-12(fp)
20023164:	1000051e 	bne	r2,zero,2002317c <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
20023168:	e0bfff17 	ldw	r2,-4(fp)
2002316c:	00c01b84 	movi	r3,110
20023170:	10c00005 	stb	r3,0(r2)
        return (pgrp);
20023174:	e0bffd17 	ldw	r2,-12(fp)
20023178:	00007906 	br	20023360 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
2002317c:	d0a60403 	ldbu	r2,-26608(gp)
20023180:	10803fcc 	andi	r2,r2,255
20023184:	10000526 	beq	r2,zero,2002319c <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
20023188:	e0bfff17 	ldw	r2,-4(fp)
2002318c:	00c003c4 	movi	r3,15
20023190:	10c00005 	stb	r3,0(r2)
        return (pgrp);
20023194:	e0bffd17 	ldw	r2,-12(fp)
20023198:	00007106 	br	20023360 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
2002319c:	e0bffd17 	ldw	r2,-12(fp)
200231a0:	10800003 	ldbu	r2,0(r2)
200231a4:	10803fcc 	andi	r2,r2,255
200231a8:	10800160 	cmpeqi	r2,r2,5
200231ac:	1000051e 	bne	r2,zero,200231c4 <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
200231b0:	e0bfff17 	ldw	r2,-4(fp)
200231b4:	00c00044 	movi	r3,1
200231b8:	10c00005 	stb	r3,0(r2)
        return (pgrp);
200231bc:	e0bffd17 	ldw	r2,-12(fp)
200231c0:	00006706 	br	20023360 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200231c4:	0005303a 	rdctl	r2,status
200231c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200231cc:	e0fffc17 	ldw	r3,-16(fp)
200231d0:	00bfff84 	movi	r2,-2
200231d4:	1884703a 	and	r2,r3,r2
200231d8:	1001703a 	wrctl	status,r2
  
  return context;
200231dc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
200231e0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
200231e4:	e0bffd17 	ldw	r2,-12(fp)
200231e8:	10800117 	ldw	r2,4(r2)
200231ec:	10000326 	beq	r2,zero,200231fc <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
200231f0:	00800044 	movi	r2,1
200231f4:	e0bff405 	stb	r2,-48(fp)
200231f8:	00000106 	br	20023200 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
200231fc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
20023200:	e0bffe03 	ldbu	r2,-8(fp)
20023204:	10000326 	beq	r2,zero,20023214 <OSFlagDel+0xe8>
20023208:	10800060 	cmpeqi	r2,r2,1
2002320c:	1000231e 	bne	r2,zero,2002329c <OSFlagDel+0x170>
20023210:	00004806 	br	20023334 <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
20023214:	e0bff403 	ldbu	r2,-48(fp)
20023218:	1000161e 	bne	r2,zero,20023274 <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
2002321c:	e0bffd17 	ldw	r2,-12(fp)
20023220:	00c00fc4 	movi	r3,63
20023224:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
20023228:	e0bffd17 	ldw	r2,-12(fp)
2002322c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
20023230:	e0bffd17 	ldw	r2,-12(fp)
20023234:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
20023238:	d0e60717 	ldw	r3,-26596(gp)
2002323c:	e0bffd17 	ldw	r2,-12(fp)
20023240:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
20023244:	e0bffd17 	ldw	r2,-12(fp)
20023248:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
2002324c:	e0bffd17 	ldw	r2,-12(fp)
20023250:	d0a60715 	stw	r2,-26596(gp)
20023254:	e0bff717 	ldw	r2,-36(fp)
20023258:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002325c:	e0bff817 	ldw	r2,-32(fp)
20023260:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
20023264:	e0bfff17 	ldw	r2,-4(fp)
20023268:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
2002326c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
20023270:	00003a06 	br	2002335c <OSFlagDel+0x230>
20023274:	e0bff717 	ldw	r2,-36(fp)
20023278:	e0bff915 	stw	r2,-28(fp)
2002327c:	e0bff917 	ldw	r2,-28(fp)
20023280:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
20023284:	e0bfff17 	ldw	r2,-4(fp)
20023288:	00c01244 	movi	r3,73
2002328c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
20023290:	e0bffd17 	ldw	r2,-12(fp)
20023294:	e0bff615 	stw	r2,-40(fp)
             }
             break;
20023298:	00003006 	br	2002335c <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
2002329c:	e0bffd17 	ldw	r2,-12(fp)
200232a0:	10800117 	ldw	r2,4(r2)
200232a4:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
200232a8:	00000606 	br	200232c4 <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
200232ac:	000b883a 	mov	r5,zero
200232b0:	e13ff517 	ldw	r4,-44(fp)
200232b4:	00242980 	call	20024298 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
200232b8:	e0bff517 	ldw	r2,-44(fp)
200232bc:	10800017 	ldw	r2,0(r2)
200232c0:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
200232c4:	e0bff517 	ldw	r2,-44(fp)
200232c8:	103ff81e 	bne	r2,zero,200232ac <__alt_data_end+0xfffe32ac>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
200232cc:	e0bffd17 	ldw	r2,-12(fp)
200232d0:	00c00fc4 	movi	r3,63
200232d4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
200232d8:	e0bffd17 	ldw	r2,-12(fp)
200232dc:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
200232e0:	e0bffd17 	ldw	r2,-12(fp)
200232e4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
200232e8:	d0e60717 	ldw	r3,-26596(gp)
200232ec:	e0bffd17 	ldw	r2,-12(fp)
200232f0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
200232f4:	e0bffd17 	ldw	r2,-12(fp)
200232f8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
200232fc:	e0bffd17 	ldw	r2,-12(fp)
20023300:	d0a60715 	stw	r2,-26596(gp)
20023304:	e0bff717 	ldw	r2,-36(fp)
20023308:	e0bffa15 	stw	r2,-24(fp)
2002330c:	e0bffa17 	ldw	r2,-24(fp)
20023310:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
20023314:	e0bff403 	ldbu	r2,-48(fp)
20023318:	10800058 	cmpnei	r2,r2,1
2002331c:	1000011e 	bne	r2,zero,20023324 <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
20023320:	00224b80 	call	200224b8 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
20023324:	e0bfff17 	ldw	r2,-4(fp)
20023328:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
2002332c:	e03ff615 	stw	zero,-40(fp)
             break;
20023330:	00000a06 	br	2002335c <OSFlagDel+0x230>
20023334:	e0bff717 	ldw	r2,-36(fp)
20023338:	e0bffb15 	stw	r2,-20(fp)
2002333c:	e0bffb17 	ldw	r2,-20(fp)
20023340:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
20023344:	e0bfff17 	ldw	r2,-4(fp)
20023348:	00c001c4 	movi	r3,7
2002334c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
20023350:	e0bffd17 	ldw	r2,-12(fp)
20023354:	e0bff615 	stw	r2,-40(fp)
             break;
20023358:	0001883a 	nop
    }
    return (pgrp_return);
2002335c:	e0bff617 	ldw	r2,-40(fp)
}
20023360:	e037883a 	mov	sp,fp
20023364:	dfc00117 	ldw	ra,4(sp)
20023368:	df000017 	ldw	fp,0(sp)
2002336c:	dec00204 	addi	sp,sp,8
20023370:	f800283a 	ret

20023374 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
20023374:	defff604 	addi	sp,sp,-40
20023378:	dfc00915 	stw	ra,36(sp)
2002337c:	df000815 	stw	fp,32(sp)
20023380:	df000804 	addi	fp,sp,32
20023384:	e13ffd15 	stw	r4,-12(fp)
20023388:	e17ffe15 	stw	r5,-8(fp)
2002338c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20023390:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20023394:	e0bfff17 	ldw	r2,-4(fp)
20023398:	1000021e 	bne	r2,zero,200233a4 <OSFlagNameGet+0x30>
        return (0);
2002339c:	0005883a 	mov	r2,zero
200233a0:	00003906 	br	20023488 <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
200233a4:	e0bffd17 	ldw	r2,-12(fp)
200233a8:	1000051e 	bne	r2,zero,200233c0 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
200233ac:	e0bfff17 	ldw	r2,-4(fp)
200233b0:	00c01b84 	movi	r3,110
200233b4:	10c00005 	stb	r3,0(r2)
        return (0);
200233b8:	0005883a 	mov	r2,zero
200233bc:	00003206 	br	20023488 <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
200233c0:	e0bffe17 	ldw	r2,-8(fp)
200233c4:	1000051e 	bne	r2,zero,200233dc <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
200233c8:	e0bfff17 	ldw	r2,-4(fp)
200233cc:	00c00304 	movi	r3,12
200233d0:	10c00005 	stb	r3,0(r2)
        return (0);
200233d4:	0005883a 	mov	r2,zero
200233d8:	00002b06 	br	20023488 <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
200233dc:	d0a60403 	ldbu	r2,-26608(gp)
200233e0:	10803fcc 	andi	r2,r2,255
200233e4:	10000526 	beq	r2,zero,200233fc <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
200233e8:	e0bfff17 	ldw	r2,-4(fp)
200233ec:	00c00444 	movi	r3,17
200233f0:	10c00005 	stb	r3,0(r2)
        return (0);
200233f4:	0005883a 	mov	r2,zero
200233f8:	00002306 	br	20023488 <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200233fc:	0005303a 	rdctl	r2,status
20023400:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023404:	e0fffc17 	ldw	r3,-16(fp)
20023408:	00bfff84 	movi	r2,-2
2002340c:	1884703a 	and	r2,r3,r2
20023410:	1001703a 	wrctl	status,r2
  
  return context;
20023414:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
20023418:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
2002341c:	e0bffd17 	ldw	r2,-12(fp)
20023420:	10800003 	ldbu	r2,0(r2)
20023424:	10803fcc 	andi	r2,r2,255
20023428:	10800160 	cmpeqi	r2,r2,5
2002342c:	1000091e 	bne	r2,zero,20023454 <OSFlagNameGet+0xe0>
20023430:	e0bff817 	ldw	r2,-32(fp)
20023434:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20023438:	e0bff917 	ldw	r2,-28(fp)
2002343c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
20023440:	e0bfff17 	ldw	r2,-4(fp)
20023444:	00c00044 	movi	r3,1
20023448:	10c00005 	stb	r3,0(r2)
        return (0);
2002344c:	0005883a 	mov	r2,zero
20023450:	00000d06 	br	20023488 <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
20023454:	e0bffd17 	ldw	r2,-12(fp)
20023458:	10800284 	addi	r2,r2,10
2002345c:	100b883a 	mov	r5,r2
20023460:	e13ffe17 	ldw	r4,-8(fp)
20023464:	00225fc0 	call	200225fc <OS_StrCopy>
20023468:	e0bffb05 	stb	r2,-20(fp)
2002346c:	e0bff817 	ldw	r2,-32(fp)
20023470:	e0bffa15 	stw	r2,-24(fp)
20023474:	e0bffa17 	ldw	r2,-24(fp)
20023478:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2002347c:	e0bfff17 	ldw	r2,-4(fp)
20023480:	10000005 	stb	zero,0(r2)
    return (len);
20023484:	e0bffb03 	ldbu	r2,-20(fp)
}
20023488:	e037883a 	mov	sp,fp
2002348c:	dfc00117 	ldw	ra,4(sp)
20023490:	df000017 	ldw	fp,0(sp)
20023494:	dec00204 	addi	sp,sp,8
20023498:	f800283a 	ret

2002349c <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
2002349c:	defff504 	addi	sp,sp,-44
200234a0:	dfc00a15 	stw	ra,40(sp)
200234a4:	df000915 	stw	fp,36(sp)
200234a8:	df000904 	addi	fp,sp,36
200234ac:	e13ffd15 	stw	r4,-12(fp)
200234b0:	e17ffe15 	stw	r5,-8(fp)
200234b4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200234b8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
200234bc:	e0bfff17 	ldw	r2,-4(fp)
200234c0:	10004326 	beq	r2,zero,200235d0 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
200234c4:	e0bffd17 	ldw	r2,-12(fp)
200234c8:	1000041e 	bne	r2,zero,200234dc <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
200234cc:	e0bfff17 	ldw	r2,-4(fp)
200234d0:	00c01b84 	movi	r3,110
200234d4:	10c00005 	stb	r3,0(r2)
        return;
200234d8:	00003e06 	br	200235d4 <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
200234dc:	e0bffe17 	ldw	r2,-8(fp)
200234e0:	1000041e 	bne	r2,zero,200234f4 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
200234e4:	e0bfff17 	ldw	r2,-4(fp)
200234e8:	00c00304 	movi	r3,12
200234ec:	10c00005 	stb	r3,0(r2)
        return;
200234f0:	00003806 	br	200235d4 <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
200234f4:	d0a60403 	ldbu	r2,-26608(gp)
200234f8:	10803fcc 	andi	r2,r2,255
200234fc:	10000426 	beq	r2,zero,20023510 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
20023500:	e0bfff17 	ldw	r2,-4(fp)
20023504:	00c00484 	movi	r3,18
20023508:	10c00005 	stb	r3,0(r2)
        return;
2002350c:	00003106 	br	200235d4 <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20023510:	0005303a 	rdctl	r2,status
20023514:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023518:	e0fffc17 	ldw	r3,-16(fp)
2002351c:	00bfff84 	movi	r2,-2
20023520:	1884703a 	and	r2,r3,r2
20023524:	1001703a 	wrctl	status,r2
  
  return context;
20023528:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
2002352c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
20023530:	e0bffd17 	ldw	r2,-12(fp)
20023534:	10800003 	ldbu	r2,0(r2)
20023538:	10803fcc 	andi	r2,r2,255
2002353c:	10800160 	cmpeqi	r2,r2,5
20023540:	1000081e 	bne	r2,zero,20023564 <OSFlagNameSet+0xc8>
20023544:	e0bff717 	ldw	r2,-36(fp)
20023548:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002354c:	e0bff817 	ldw	r2,-32(fp)
20023550:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
20023554:	e0bfff17 	ldw	r2,-4(fp)
20023558:	00c00044 	movi	r3,1
2002355c:	10c00005 	stb	r3,0(r2)
        return;
20023560:	00001c06 	br	200235d4 <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
20023564:	e13ffe17 	ldw	r4,-8(fp)
20023568:	00226700 	call	20022670 <OS_StrLen>
2002356c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
20023570:	e0bffa03 	ldbu	r2,-24(fp)
20023574:	10800830 	cmpltui	r2,r2,32
20023578:	1000081e 	bne	r2,zero,2002359c <OSFlagNameSet+0x100>
2002357c:	e0bff717 	ldw	r2,-36(fp)
20023580:	e0bff915 	stw	r2,-28(fp)
20023584:	e0bff917 	ldw	r2,-28(fp)
20023588:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
2002358c:	e0bfff17 	ldw	r2,-4(fp)
20023590:	00c01cc4 	movi	r3,115
20023594:	10c00005 	stb	r3,0(r2)
        return;
20023598:	00000e06 	br	200235d4 <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
2002359c:	e0bffd17 	ldw	r2,-12(fp)
200235a0:	10800284 	addi	r2,r2,10
200235a4:	e17ffe17 	ldw	r5,-8(fp)
200235a8:	1009883a 	mov	r4,r2
200235ac:	00225fc0 	call	200225fc <OS_StrCopy>
200235b0:	e0bff717 	ldw	r2,-36(fp)
200235b4:	e0bffb15 	stw	r2,-20(fp)
200235b8:	e0bffb17 	ldw	r2,-20(fp)
200235bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
200235c0:	e0bfff17 	ldw	r2,-4(fp)
200235c4:	10000005 	stb	zero,0(r2)
    return;
200235c8:	0001883a 	nop
200235cc:	00000106 	br	200235d4 <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
200235d0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
200235d4:	e037883a 	mov	sp,fp
200235d8:	dfc00117 	ldw	ra,4(sp)
200235dc:	df000017 	ldw	fp,0(sp)
200235e0:	dec00204 	addi	sp,sp,8
200235e4:	f800283a 	ret

200235e8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
200235e8:	deffe104 	addi	sp,sp,-124
200235ec:	dfc01e15 	stw	ra,120(sp)
200235f0:	df001d15 	stw	fp,116(sp)
200235f4:	df001d04 	addi	fp,sp,116
200235f8:	e13ffc15 	stw	r4,-16(fp)
200235fc:	2809883a 	mov	r4,r5
20023600:	3007883a 	mov	r3,r6
20023604:	3805883a 	mov	r2,r7
20023608:	e13ffd0d 	sth	r4,-12(fp)
2002360c:	e0fffe05 	stb	r3,-8(fp)
20023610:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
20023614:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
20023618:	e0800217 	ldw	r2,8(fp)
2002361c:	1000021e 	bne	r2,zero,20023628 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
20023620:	0005883a 	mov	r2,zero
20023624:	00015906 	br	20023b8c <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
20023628:	e0bffc17 	ldw	r2,-16(fp)
2002362c:	1000051e 	bne	r2,zero,20023644 <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
20023630:	e0800217 	ldw	r2,8(fp)
20023634:	00c01b84 	movi	r3,110
20023638:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
2002363c:	0005883a 	mov	r2,zero
20023640:	00015206 	br	20023b8c <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
20023644:	d0a60403 	ldbu	r2,-26608(gp)
20023648:	10803fcc 	andi	r2,r2,255
2002364c:	10000526 	beq	r2,zero,20023664 <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
20023650:	e0800217 	ldw	r2,8(fp)
20023654:	00c00084 	movi	r3,2
20023658:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
2002365c:	0005883a 	mov	r2,zero
20023660:	00014a06 	br	20023b8c <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
20023664:	d0a5f603 	ldbu	r2,-26664(gp)
20023668:	10803fcc 	andi	r2,r2,255
2002366c:	10000526 	beq	r2,zero,20023684 <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
20023670:	e0800217 	ldw	r2,8(fp)
20023674:	00c00344 	movi	r3,13
20023678:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
2002367c:	0005883a 	mov	r2,zero
20023680:	00014206 	br	20023b8c <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
20023684:	e0bffc17 	ldw	r2,-16(fp)
20023688:	10800003 	ldbu	r2,0(r2)
2002368c:	10803fcc 	andi	r2,r2,255
20023690:	10800160 	cmpeqi	r2,r2,5
20023694:	1000051e 	bne	r2,zero,200236ac <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
20023698:	e0800217 	ldw	r2,8(fp)
2002369c:	00c00044 	movi	r3,1
200236a0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
200236a4:	0005883a 	mov	r2,zero
200236a8:	00013806 	br	20023b8c <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
200236ac:	e0fffe03 	ldbu	r3,-8(fp)
200236b0:	00bfe004 	movi	r2,-128
200236b4:	1884703a 	and	r2,r3,r2
200236b8:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
200236bc:	e0bfe603 	ldbu	r2,-104(fp)
200236c0:	10000626 	beq	r2,zero,200236dc <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
200236c4:	e0bffe03 	ldbu	r2,-8(fp)
200236c8:	10801fcc 	andi	r2,r2,127
200236cc:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
200236d0:	00800044 	movi	r2,1
200236d4:	e0bfe405 	stb	r2,-112(fp)
200236d8:	00000106 	br	200236e0 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
200236dc:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200236e0:	0005303a 	rdctl	r2,status
200236e4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200236e8:	e0fff617 	ldw	r3,-40(fp)
200236ec:	00bfff84 	movi	r2,-2
200236f0:	1884703a 	and	r2,r3,r2
200236f4:	1001703a 	wrctl	status,r2
  
  return context;
200236f8:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
200236fc:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
20023700:	e0bffe03 	ldbu	r2,-8(fp)
20023704:	10c00060 	cmpeqi	r3,r2,1
20023708:	1800921e 	bne	r3,zero,20023954 <OSFlagPend+0x36c>
2002370c:	10c00088 	cmpgei	r3,r2,2
20023710:	1800021e 	bne	r3,zero,2002371c <OSFlagPend+0x134>
20023714:	10006126 	beq	r2,zero,2002389c <OSFlagPend+0x2b4>
20023718:	0000bb06 	br	20023a08 <OSFlagPend+0x420>
2002371c:	10c000a0 	cmpeqi	r3,r2,2
20023720:	1800031e 	bne	r3,zero,20023730 <OSFlagPend+0x148>
20023724:	108000e0 	cmpeqi	r2,r2,3
20023728:	10002f1e 	bne	r2,zero,200237e8 <OSFlagPend+0x200>
2002372c:	0000b606 	br	20023a08 <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
20023730:	e0bffc17 	ldw	r2,-16(fp)
20023734:	10c0020b 	ldhu	r3,8(r2)
20023738:	e0bffd0b 	ldhu	r2,-12(fp)
2002373c:	1884703a 	and	r2,r3,r2
20023740:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
20023744:	e0ffe80b 	ldhu	r3,-96(fp)
20023748:	e0bffd0b 	ldhu	r2,-12(fp)
2002374c:	1880171e 	bne	r3,r2,200237ac <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20023750:	e0bfe403 	ldbu	r2,-112(fp)
20023754:	10800058 	cmpnei	r2,r2,1
20023758:	1000091e 	bne	r2,zero,20023780 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
2002375c:	e0bffc17 	ldw	r2,-16(fp)
20023760:	1080020b 	ldhu	r2,8(r2)
20023764:	1007883a 	mov	r3,r2
20023768:	e0bfe80b 	ldhu	r2,-96(fp)
2002376c:	0084303a 	nor	r2,zero,r2
20023770:	1884703a 	and	r2,r3,r2
20023774:	1007883a 	mov	r3,r2
20023778:	e0bffc17 	ldw	r2,-16(fp)
2002377c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
20023780:	d0a60517 	ldw	r2,-26604(gp)
20023784:	e0ffe80b 	ldhu	r3,-96(fp)
20023788:	10c00b0d 	sth	r3,44(r2)
2002378c:	e0bfe517 	ldw	r2,-108(fp)
20023790:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20023794:	e0bfe717 	ldw	r2,-100(fp)
20023798:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
2002379c:	e0800217 	ldw	r2,8(fp)
200237a0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
200237a4:	e0bfe80b 	ldhu	r2,-96(fp)
200237a8:	0000f806 	br	20023b8c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
200237ac:	e13ffd0b 	ldhu	r4,-12(fp)
200237b0:	e17ffe03 	ldbu	r5,-8(fp)
200237b4:	e0bfff0b 	ldhu	r2,-4(fp)
200237b8:	e0fff704 	addi	r3,fp,-36
200237bc:	d8800015 	stw	r2,0(sp)
200237c0:	280f883a 	mov	r7,r5
200237c4:	200d883a 	mov	r6,r4
200237c8:	180b883a 	mov	r5,r3
200237cc:	e13ffc17 	ldw	r4,-16(fp)
200237d0:	00240580 	call	20024058 <OS_FlagBlock>
200237d4:	e0bfe517 	ldw	r2,-108(fp)
200237d8:	e0bfe915 	stw	r2,-92(fp)
200237dc:	e0bfe917 	ldw	r2,-92(fp)
200237e0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
200237e4:	00009206 	br	20023a30 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
200237e8:	e0bffc17 	ldw	r2,-16(fp)
200237ec:	10c0020b 	ldhu	r3,8(r2)
200237f0:	e0bffd0b 	ldhu	r2,-12(fp)
200237f4:	1884703a 	and	r2,r3,r2
200237f8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
200237fc:	e0bfe80b 	ldhu	r2,-96(fp)
20023800:	10001726 	beq	r2,zero,20023860 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20023804:	e0bfe403 	ldbu	r2,-112(fp)
20023808:	10800058 	cmpnei	r2,r2,1
2002380c:	1000091e 	bne	r2,zero,20023834 <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
20023810:	e0bffc17 	ldw	r2,-16(fp)
20023814:	1080020b 	ldhu	r2,8(r2)
20023818:	1007883a 	mov	r3,r2
2002381c:	e0bfe80b 	ldhu	r2,-96(fp)
20023820:	0084303a 	nor	r2,zero,r2
20023824:	1884703a 	and	r2,r3,r2
20023828:	1007883a 	mov	r3,r2
2002382c:	e0bffc17 	ldw	r2,-16(fp)
20023830:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
20023834:	d0a60517 	ldw	r2,-26604(gp)
20023838:	e0ffe80b 	ldhu	r3,-96(fp)
2002383c:	10c00b0d 	sth	r3,44(r2)
20023840:	e0bfe517 	ldw	r2,-108(fp)
20023844:	e0bfea15 	stw	r2,-88(fp)
20023848:	e0bfea17 	ldw	r2,-88(fp)
2002384c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
20023850:	e0800217 	ldw	r2,8(fp)
20023854:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
20023858:	e0bfe80b 	ldhu	r2,-96(fp)
2002385c:	0000cb06 	br	20023b8c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
20023860:	e13ffd0b 	ldhu	r4,-12(fp)
20023864:	e17ffe03 	ldbu	r5,-8(fp)
20023868:	e0bfff0b 	ldhu	r2,-4(fp)
2002386c:	e0fff704 	addi	r3,fp,-36
20023870:	d8800015 	stw	r2,0(sp)
20023874:	280f883a 	mov	r7,r5
20023878:	200d883a 	mov	r6,r4
2002387c:	180b883a 	mov	r5,r3
20023880:	e13ffc17 	ldw	r4,-16(fp)
20023884:	00240580 	call	20024058 <OS_FlagBlock>
20023888:	e0bfe517 	ldw	r2,-108(fp)
2002388c:	e0bfeb15 	stw	r2,-84(fp)
20023890:	e0bfeb17 	ldw	r2,-84(fp)
20023894:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
20023898:	00006506 	br	20023a30 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
2002389c:	e0bffc17 	ldw	r2,-16(fp)
200238a0:	1080020b 	ldhu	r2,8(r2)
200238a4:	0084303a 	nor	r2,zero,r2
200238a8:	1007883a 	mov	r3,r2
200238ac:	e0bffd0b 	ldhu	r2,-12(fp)
200238b0:	1884703a 	and	r2,r3,r2
200238b4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
200238b8:	e0ffe80b 	ldhu	r3,-96(fp)
200238bc:	e0bffd0b 	ldhu	r2,-12(fp)
200238c0:	1880151e 	bne	r3,r2,20023918 <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
200238c4:	e0bfe403 	ldbu	r2,-112(fp)
200238c8:	10800058 	cmpnei	r2,r2,1
200238cc:	1000071e 	bne	r2,zero,200238ec <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
200238d0:	e0bffc17 	ldw	r2,-16(fp)
200238d4:	10c0020b 	ldhu	r3,8(r2)
200238d8:	e0bfe80b 	ldhu	r2,-96(fp)
200238dc:	1884b03a 	or	r2,r3,r2
200238e0:	1007883a 	mov	r3,r2
200238e4:	e0bffc17 	ldw	r2,-16(fp)
200238e8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
200238ec:	d0a60517 	ldw	r2,-26604(gp)
200238f0:	e0ffe80b 	ldhu	r3,-96(fp)
200238f4:	10c00b0d 	sth	r3,44(r2)
200238f8:	e0bfe517 	ldw	r2,-108(fp)
200238fc:	e0bfec15 	stw	r2,-80(fp)
20023900:	e0bfec17 	ldw	r2,-80(fp)
20023904:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
20023908:	e0800217 	ldw	r2,8(fp)
2002390c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
20023910:	e0bfe80b 	ldhu	r2,-96(fp)
20023914:	00009d06 	br	20023b8c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
20023918:	e13ffd0b 	ldhu	r4,-12(fp)
2002391c:	e17ffe03 	ldbu	r5,-8(fp)
20023920:	e0bfff0b 	ldhu	r2,-4(fp)
20023924:	e0fff704 	addi	r3,fp,-36
20023928:	d8800015 	stw	r2,0(sp)
2002392c:	280f883a 	mov	r7,r5
20023930:	200d883a 	mov	r6,r4
20023934:	180b883a 	mov	r5,r3
20023938:	e13ffc17 	ldw	r4,-16(fp)
2002393c:	00240580 	call	20024058 <OS_FlagBlock>
20023940:	e0bfe517 	ldw	r2,-108(fp)
20023944:	e0bfed15 	stw	r2,-76(fp)
20023948:	e0bfed17 	ldw	r2,-76(fp)
2002394c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
20023950:	00003706 	br	20023a30 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
20023954:	e0bffc17 	ldw	r2,-16(fp)
20023958:	1080020b 	ldhu	r2,8(r2)
2002395c:	0084303a 	nor	r2,zero,r2
20023960:	1007883a 	mov	r3,r2
20023964:	e0bffd0b 	ldhu	r2,-12(fp)
20023968:	1884703a 	and	r2,r3,r2
2002396c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
20023970:	e0bfe80b 	ldhu	r2,-96(fp)
20023974:	10001526 	beq	r2,zero,200239cc <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
20023978:	e0bfe403 	ldbu	r2,-112(fp)
2002397c:	10800058 	cmpnei	r2,r2,1
20023980:	1000071e 	bne	r2,zero,200239a0 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
20023984:	e0bffc17 	ldw	r2,-16(fp)
20023988:	10c0020b 	ldhu	r3,8(r2)
2002398c:	e0bfe80b 	ldhu	r2,-96(fp)
20023990:	1884b03a 	or	r2,r3,r2
20023994:	1007883a 	mov	r3,r2
20023998:	e0bffc17 	ldw	r2,-16(fp)
2002399c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
200239a0:	d0a60517 	ldw	r2,-26604(gp)
200239a4:	e0ffe80b 	ldhu	r3,-96(fp)
200239a8:	10c00b0d 	sth	r3,44(r2)
200239ac:	e0bfe517 	ldw	r2,-108(fp)
200239b0:	e0bfee15 	stw	r2,-72(fp)
200239b4:	e0bfee17 	ldw	r2,-72(fp)
200239b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
200239bc:	e0800217 	ldw	r2,8(fp)
200239c0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
200239c4:	e0bfe80b 	ldhu	r2,-96(fp)
200239c8:	00007006 	br	20023b8c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
200239cc:	e13ffd0b 	ldhu	r4,-12(fp)
200239d0:	e17ffe03 	ldbu	r5,-8(fp)
200239d4:	e0bfff0b 	ldhu	r2,-4(fp)
200239d8:	e0fff704 	addi	r3,fp,-36
200239dc:	d8800015 	stw	r2,0(sp)
200239e0:	280f883a 	mov	r7,r5
200239e4:	200d883a 	mov	r6,r4
200239e8:	180b883a 	mov	r5,r3
200239ec:	e13ffc17 	ldw	r4,-16(fp)
200239f0:	00240580 	call	20024058 <OS_FlagBlock>
200239f4:	e0bfe517 	ldw	r2,-108(fp)
200239f8:	e0bfef15 	stw	r2,-68(fp)
200239fc:	e0bfef17 	ldw	r2,-68(fp)
20023a00:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
20023a04:	00000a06 	br	20023a30 <OSFlagPend+0x448>
20023a08:	e0bfe517 	ldw	r2,-108(fp)
20023a0c:	e0bff015 	stw	r2,-64(fp)
20023a10:	e0bff017 	ldw	r2,-64(fp)
20023a14:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
20023a18:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
20023a1c:	e0800217 	ldw	r2,8(fp)
20023a20:	00c01bc4 	movi	r3,111
20023a24:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
20023a28:	e0bfe80b 	ldhu	r2,-96(fp)
20023a2c:	00005706 	br	20023b8c <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
20023a30:	00224b80 	call	200224b8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20023a34:	0005303a 	rdctl	r2,status
20023a38:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023a3c:	e0fff117 	ldw	r3,-60(fp)
20023a40:	00bfff84 	movi	r2,-2
20023a44:	1884703a 	and	r2,r3,r2
20023a48:	1001703a 	wrctl	status,r2
  
  return context;
20023a4c:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
20023a50:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
20023a54:	d0a60517 	ldw	r2,-26604(gp)
20023a58:	10800c43 	ldbu	r2,49(r2)
20023a5c:	10803fcc 	andi	r2,r2,255
20023a60:	10001c26 	beq	r2,zero,20023ad4 <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
20023a64:	d0a60517 	ldw	r2,-26604(gp)
20023a68:	10800c43 	ldbu	r2,49(r2)
20023a6c:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
20023a70:	d0a60517 	ldw	r2,-26604(gp)
20023a74:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
20023a78:	e0bff704 	addi	r2,fp,-36
20023a7c:	1009883a 	mov	r4,r2
20023a80:	002438c0 	call	2002438c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
20023a84:	d0a60517 	ldw	r2,-26604(gp)
20023a88:	10000c05 	stb	zero,48(r2)
20023a8c:	e0bfe517 	ldw	r2,-108(fp)
20023a90:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20023a94:	e0bff217 	ldw	r2,-56(fp)
20023a98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
20023a9c:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
20023aa0:	e0bff303 	ldbu	r2,-52(fp)
20023aa4:	108000a0 	cmpeqi	r2,r2,2
20023aa8:	10000426 	beq	r2,zero,20023abc <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
20023aac:	e0800217 	ldw	r2,8(fp)
20023ab0:	00c00384 	movi	r3,14
20023ab4:	10c00005 	stb	r3,0(r2)
                 break;
20023ab8:	00000406 	br	20023acc <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
20023abc:	e0800217 	ldw	r2,8(fp)
20023ac0:	00c00284 	movi	r3,10
20023ac4:	10c00005 	stb	r3,0(r2)
                 break;
20023ac8:	0001883a 	nop
        }
        return (flags_rdy);
20023acc:	e0bfe80b 	ldhu	r2,-96(fp)
20023ad0:	00002e06 	br	20023b8c <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
20023ad4:	d0a60517 	ldw	r2,-26604(gp)
20023ad8:	10800b0b 	ldhu	r2,44(r2)
20023adc:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
20023ae0:	e0bfe403 	ldbu	r2,-112(fp)
20023ae4:	10800058 	cmpnei	r2,r2,1
20023ae8:	1000211e 	bne	r2,zero,20023b70 <OSFlagPend+0x588>
        switch (wait_type) {
20023aec:	e0bffe03 	ldbu	r2,-8(fp)
20023af0:	10001616 	blt	r2,zero,20023b4c <OSFlagPend+0x564>
20023af4:	10c00090 	cmplti	r3,r2,2
20023af8:	18000c1e 	bne	r3,zero,20023b2c <OSFlagPend+0x544>
20023afc:	10800108 	cmpgei	r2,r2,4
20023b00:	1000121e 	bne	r2,zero,20023b4c <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
20023b04:	e0bffc17 	ldw	r2,-16(fp)
20023b08:	1080020b 	ldhu	r2,8(r2)
20023b0c:	1007883a 	mov	r3,r2
20023b10:	e0bfe80b 	ldhu	r2,-96(fp)
20023b14:	0084303a 	nor	r2,zero,r2
20023b18:	1884703a 	and	r2,r3,r2
20023b1c:	1007883a 	mov	r3,r2
20023b20:	e0bffc17 	ldw	r2,-16(fp)
20023b24:	10c0020d 	sth	r3,8(r2)
                 break;
20023b28:	00001106 	br	20023b70 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
20023b2c:	e0bffc17 	ldw	r2,-16(fp)
20023b30:	10c0020b 	ldhu	r3,8(r2)
20023b34:	e0bfe80b 	ldhu	r2,-96(fp)
20023b38:	1884b03a 	or	r2,r3,r2
20023b3c:	1007883a 	mov	r3,r2
20023b40:	e0bffc17 	ldw	r2,-16(fp)
20023b44:	10c0020d 	sth	r3,8(r2)
                 break;
20023b48:	00000906 	br	20023b70 <OSFlagPend+0x588>
20023b4c:	e0bfe517 	ldw	r2,-108(fp)
20023b50:	e0bff415 	stw	r2,-48(fp)
20023b54:	e0bff417 	ldw	r2,-48(fp)
20023b58:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
20023b5c:	e0800217 	ldw	r2,8(fp)
20023b60:	00c01bc4 	movi	r3,111
20023b64:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
20023b68:	0005883a 	mov	r2,zero
20023b6c:	00000706 	br	20023b8c <OSFlagPend+0x5a4>
20023b70:	e0bfe517 	ldw	r2,-108(fp)
20023b74:	e0bff515 	stw	r2,-44(fp)
20023b78:	e0bff517 	ldw	r2,-44(fp)
20023b7c:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
20023b80:	e0800217 	ldw	r2,8(fp)
20023b84:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
20023b88:	e0bfe80b 	ldhu	r2,-96(fp)
}
20023b8c:	e037883a 	mov	sp,fp
20023b90:	dfc00117 	ldw	ra,4(sp)
20023b94:	df000017 	ldw	fp,0(sp)
20023b98:	dec00204 	addi	sp,sp,8
20023b9c:	f800283a 	ret

20023ba0 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
20023ba0:	defffb04 	addi	sp,sp,-20
20023ba4:	df000415 	stw	fp,16(sp)
20023ba8:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
20023bac:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20023bb0:	0005303a 	rdctl	r2,status
20023bb4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023bb8:	e0fffe17 	ldw	r3,-8(fp)
20023bbc:	00bfff84 	movi	r2,-2
20023bc0:	1884703a 	and	r2,r3,r2
20023bc4:	1001703a 	wrctl	status,r2
  
  return context;
20023bc8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
20023bcc:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
20023bd0:	d0a60517 	ldw	r2,-26604(gp)
20023bd4:	10800b0b 	ldhu	r2,44(r2)
20023bd8:	e0bffd0d 	sth	r2,-12(fp)
20023bdc:	e0bffc17 	ldw	r2,-16(fp)
20023be0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20023be4:	e0bfff17 	ldw	r2,-4(fp)
20023be8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
20023bec:	e0bffd0b 	ldhu	r2,-12(fp)
}
20023bf0:	e037883a 	mov	sp,fp
20023bf4:	df000017 	ldw	fp,0(sp)
20023bf8:	dec00104 	addi	sp,sp,4
20023bfc:	f800283a 	ret

20023c00 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
20023c00:	deffef04 	addi	sp,sp,-68
20023c04:	dfc01015 	stw	ra,64(sp)
20023c08:	df000f15 	stw	fp,60(sp)
20023c0c:	df000f04 	addi	fp,sp,60
20023c10:	e13ffc15 	stw	r4,-16(fp)
20023c14:	2807883a 	mov	r3,r5
20023c18:	3005883a 	mov	r2,r6
20023c1c:	e1ffff15 	stw	r7,-4(fp)
20023c20:	e0fffd0d 	sth	r3,-12(fp)
20023c24:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
20023c28:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
20023c2c:	e0bfff17 	ldw	r2,-4(fp)
20023c30:	1000021e 	bne	r2,zero,20023c3c <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
20023c34:	0005883a 	mov	r2,zero
20023c38:	0000d106 	br	20023f80 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
20023c3c:	e0bffc17 	ldw	r2,-16(fp)
20023c40:	1000051e 	bne	r2,zero,20023c58 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
20023c44:	e0bfff17 	ldw	r2,-4(fp)
20023c48:	00c01b84 	movi	r3,110
20023c4c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
20023c50:	0005883a 	mov	r2,zero
20023c54:	0000ca06 	br	20023f80 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
20023c58:	e0bffc17 	ldw	r2,-16(fp)
20023c5c:	10800003 	ldbu	r2,0(r2)
20023c60:	10803fcc 	andi	r2,r2,255
20023c64:	10800160 	cmpeqi	r2,r2,5
20023c68:	1000051e 	bne	r2,zero,20023c80 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
20023c6c:	e0bfff17 	ldw	r2,-4(fp)
20023c70:	00c00044 	movi	r3,1
20023c74:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
20023c78:	0005883a 	mov	r2,zero
20023c7c:	0000c006 	br	20023f80 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20023c80:	0005303a 	rdctl	r2,status
20023c84:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023c88:	e0fffb17 	ldw	r3,-20(fp)
20023c8c:	00bfff84 	movi	r2,-2
20023c90:	1884703a 	and	r2,r3,r2
20023c94:	1001703a 	wrctl	status,r2
  
  return context;
20023c98:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
20023c9c:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
20023ca0:	e0bffe03 	ldbu	r2,-8(fp)
20023ca4:	10000326 	beq	r2,zero,20023cb4 <OSFlagPost+0xb4>
20023ca8:	10800060 	cmpeqi	r2,r2,1
20023cac:	10000b1e 	bne	r2,zero,20023cdc <OSFlagPost+0xdc>
20023cb0:	00001206 	br	20023cfc <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
20023cb4:	e0bffc17 	ldw	r2,-16(fp)
20023cb8:	1080020b 	ldhu	r2,8(r2)
20023cbc:	1007883a 	mov	r3,r2
20023cc0:	e0bffd0b 	ldhu	r2,-12(fp)
20023cc4:	0084303a 	nor	r2,zero,r2
20023cc8:	1884703a 	and	r2,r3,r2
20023ccc:	1007883a 	mov	r3,r2
20023cd0:	e0bffc17 	ldw	r2,-16(fp)
20023cd4:	10c0020d 	sth	r3,8(r2)
             break;
20023cd8:	00001106 	br	20023d20 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
20023cdc:	e0bffc17 	ldw	r2,-16(fp)
20023ce0:	10c0020b 	ldhu	r3,8(r2)
20023ce4:	e0bffd0b 	ldhu	r2,-12(fp)
20023ce8:	1884b03a 	or	r2,r3,r2
20023cec:	1007883a 	mov	r3,r2
20023cf0:	e0bffc17 	ldw	r2,-16(fp)
20023cf4:	10c0020d 	sth	r3,8(r2)
             break;
20023cf8:	00000906 	br	20023d20 <OSFlagPost+0x120>
20023cfc:	e0bff317 	ldw	r2,-52(fp)
20023d00:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20023d04:	e0bff417 	ldw	r2,-48(fp)
20023d08:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
20023d0c:	e0bfff17 	ldw	r2,-4(fp)
20023d10:	00c01c44 	movi	r3,113
20023d14:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
20023d18:	0005883a 	mov	r2,zero
20023d1c:	00009806 	br	20023f80 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
20023d20:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
20023d24:	e0bffc17 	ldw	r2,-16(fp)
20023d28:	10800117 	ldw	r2,4(r2)
20023d2c:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
20023d30:	00007706 	br	20023f10 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
20023d34:	e0bff117 	ldw	r2,-60(fp)
20023d38:	10800483 	ldbu	r2,18(r2)
20023d3c:	10803fcc 	andi	r2,r2,255
20023d40:	10c00060 	cmpeqi	r3,r2,1
20023d44:	18004a1e 	bne	r3,zero,20023e70 <OSFlagPost+0x270>
20023d48:	10c00088 	cmpgei	r3,r2,2
20023d4c:	1800021e 	bne	r3,zero,20023d58 <OSFlagPost+0x158>
20023d50:	10002f26 	beq	r2,zero,20023e10 <OSFlagPost+0x210>
20023d54:	00005b06 	br	20023ec4 <OSFlagPost+0x2c4>
20023d58:	10c000a0 	cmpeqi	r3,r2,2
20023d5c:	1800031e 	bne	r3,zero,20023d6c <OSFlagPost+0x16c>
20023d60:	108000e0 	cmpeqi	r2,r2,3
20023d64:	1000171e 	bne	r2,zero,20023dc4 <OSFlagPost+0x1c4>
20023d68:	00005606 	br	20023ec4 <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
20023d6c:	e0bffc17 	ldw	r2,-16(fp)
20023d70:	10c0020b 	ldhu	r3,8(r2)
20023d74:	e0bff117 	ldw	r2,-60(fp)
20023d78:	1080040b 	ldhu	r2,16(r2)
20023d7c:	1884703a 	and	r2,r3,r2
20023d80:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
20023d84:	e0bff117 	ldw	r2,-60(fp)
20023d88:	1080040b 	ldhu	r2,16(r2)
20023d8c:	10ffffcc 	andi	r3,r2,65535
20023d90:	e0bff60b 	ldhu	r2,-40(fp)
20023d94:	1880541e 	bne	r3,r2,20023ee8 <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
20023d98:	e0bff60b 	ldhu	r2,-40(fp)
20023d9c:	100b883a 	mov	r5,r2
20023da0:	e13ff117 	ldw	r4,-60(fp)
20023da4:	00242980 	call	20024298 <OS_FlagTaskRdy>
20023da8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
20023dac:	e0bff683 	ldbu	r2,-38(fp)
20023db0:	10800058 	cmpnei	r2,r2,1
20023db4:	10004c1e 	bne	r2,zero,20023ee8 <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
20023db8:	00800044 	movi	r2,1
20023dbc:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
20023dc0:	00004906 	br	20023ee8 <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
20023dc4:	e0bffc17 	ldw	r2,-16(fp)
20023dc8:	10c0020b 	ldhu	r3,8(r2)
20023dcc:	e0bff117 	ldw	r2,-60(fp)
20023dd0:	1080040b 	ldhu	r2,16(r2)
20023dd4:	1884703a 	and	r2,r3,r2
20023dd8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
20023ddc:	e0bff60b 	ldhu	r2,-40(fp)
20023de0:	10004326 	beq	r2,zero,20023ef0 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
20023de4:	e0bff60b 	ldhu	r2,-40(fp)
20023de8:	100b883a 	mov	r5,r2
20023dec:	e13ff117 	ldw	r4,-60(fp)
20023df0:	00242980 	call	20024298 <OS_FlagTaskRdy>
20023df4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
20023df8:	e0bff683 	ldbu	r2,-38(fp)
20023dfc:	10800058 	cmpnei	r2,r2,1
20023e00:	10003b1e 	bne	r2,zero,20023ef0 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
20023e04:	00800044 	movi	r2,1
20023e08:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
20023e0c:	00003806 	br	20023ef0 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
20023e10:	e0bffc17 	ldw	r2,-16(fp)
20023e14:	1080020b 	ldhu	r2,8(r2)
20023e18:	0084303a 	nor	r2,zero,r2
20023e1c:	1007883a 	mov	r3,r2
20023e20:	e0bff117 	ldw	r2,-60(fp)
20023e24:	1080040b 	ldhu	r2,16(r2)
20023e28:	1884703a 	and	r2,r3,r2
20023e2c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
20023e30:	e0bff117 	ldw	r2,-60(fp)
20023e34:	1080040b 	ldhu	r2,16(r2)
20023e38:	10ffffcc 	andi	r3,r2,65535
20023e3c:	e0bff60b 	ldhu	r2,-40(fp)
20023e40:	18802d1e 	bne	r3,r2,20023ef8 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
20023e44:	e0bff60b 	ldhu	r2,-40(fp)
20023e48:	100b883a 	mov	r5,r2
20023e4c:	e13ff117 	ldw	r4,-60(fp)
20023e50:	00242980 	call	20024298 <OS_FlagTaskRdy>
20023e54:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
20023e58:	e0bff683 	ldbu	r2,-38(fp)
20023e5c:	10800058 	cmpnei	r2,r2,1
20023e60:	1000251e 	bne	r2,zero,20023ef8 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
20023e64:	00800044 	movi	r2,1
20023e68:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
20023e6c:	00002206 	br	20023ef8 <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
20023e70:	e0bffc17 	ldw	r2,-16(fp)
20023e74:	1080020b 	ldhu	r2,8(r2)
20023e78:	0084303a 	nor	r2,zero,r2
20023e7c:	1007883a 	mov	r3,r2
20023e80:	e0bff117 	ldw	r2,-60(fp)
20023e84:	1080040b 	ldhu	r2,16(r2)
20023e88:	1884703a 	and	r2,r3,r2
20023e8c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
20023e90:	e0bff60b 	ldhu	r2,-40(fp)
20023e94:	10001a26 	beq	r2,zero,20023f00 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
20023e98:	e0bff60b 	ldhu	r2,-40(fp)
20023e9c:	100b883a 	mov	r5,r2
20023ea0:	e13ff117 	ldw	r4,-60(fp)
20023ea4:	00242980 	call	20024298 <OS_FlagTaskRdy>
20023ea8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
20023eac:	e0bff683 	ldbu	r2,-38(fp)
20023eb0:	10800058 	cmpnei	r2,r2,1
20023eb4:	1000121e 	bne	r2,zero,20023f00 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
20023eb8:	00800044 	movi	r2,1
20023ebc:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
20023ec0:	00000f06 	br	20023f00 <OSFlagPost+0x300>
20023ec4:	e0bff317 	ldw	r2,-52(fp)
20023ec8:	e0bff515 	stw	r2,-44(fp)
20023ecc:	e0bff517 	ldw	r2,-44(fp)
20023ed0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
20023ed4:	e0bfff17 	ldw	r2,-4(fp)
20023ed8:	00c01bc4 	movi	r3,111
20023edc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
20023ee0:	0005883a 	mov	r2,zero
20023ee4:	00002606 	br	20023f80 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
20023ee8:	0001883a 	nop
20023eec:	00000506 	br	20023f04 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
20023ef0:	0001883a 	nop
20023ef4:	00000306 	br	20023f04 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
20023ef8:	0001883a 	nop
20023efc:	00000106 	br	20023f04 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
20023f00:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
20023f04:	e0bff117 	ldw	r2,-60(fp)
20023f08:	10800017 	ldw	r2,0(r2)
20023f0c:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
20023f10:	e0bff117 	ldw	r2,-60(fp)
20023f14:	103f871e 	bne	r2,zero,20023d34 <__alt_data_end+0xfffe3d34>
20023f18:	e0bff317 	ldw	r2,-52(fp)
20023f1c:	e0bff715 	stw	r2,-36(fp)
20023f20:	e0bff717 	ldw	r2,-36(fp)
20023f24:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
20023f28:	e0bff203 	ldbu	r2,-56(fp)
20023f2c:	10800058 	cmpnei	r2,r2,1
20023f30:	1000011e 	bne	r2,zero,20023f38 <OSFlagPost+0x338>
        OS_Sched();
20023f34:	00224b80 	call	200224b8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20023f38:	0005303a 	rdctl	r2,status
20023f3c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20023f40:	e0fffa17 	ldw	r3,-24(fp)
20023f44:	00bfff84 	movi	r2,-2
20023f48:	1884703a 	and	r2,r3,r2
20023f4c:	1001703a 	wrctl	status,r2
  
  return context;
20023f50:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
20023f54:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
20023f58:	e0bffc17 	ldw	r2,-16(fp)
20023f5c:	1080020b 	ldhu	r2,8(r2)
20023f60:	e0bff90d 	sth	r2,-28(fp)
20023f64:	e0bff317 	ldw	r2,-52(fp)
20023f68:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20023f6c:	e0bff817 	ldw	r2,-32(fp)
20023f70:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
20023f74:	e0bfff17 	ldw	r2,-4(fp)
20023f78:	10000005 	stb	zero,0(r2)
    return (flags_cur);
20023f7c:	e0bff90b 	ldhu	r2,-28(fp)
}
20023f80:	e037883a 	mov	sp,fp
20023f84:	dfc00117 	ldw	ra,4(sp)
20023f88:	df000017 	ldw	fp,0(sp)
20023f8c:	dec00204 	addi	sp,sp,8
20023f90:	f800283a 	ret

20023f94 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
20023f94:	defff904 	addi	sp,sp,-28
20023f98:	df000615 	stw	fp,24(sp)
20023f9c:	df000604 	addi	fp,sp,24
20023fa0:	e13ffe15 	stw	r4,-8(fp)
20023fa4:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
20023fa8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
20023fac:	e0bfff17 	ldw	r2,-4(fp)
20023fb0:	1000021e 	bne	r2,zero,20023fbc <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
20023fb4:	0005883a 	mov	r2,zero
20023fb8:	00002306 	br	20024048 <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
20023fbc:	e0bffe17 	ldw	r2,-8(fp)
20023fc0:	1000051e 	bne	r2,zero,20023fd8 <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
20023fc4:	e0bfff17 	ldw	r2,-4(fp)
20023fc8:	00c01b84 	movi	r3,110
20023fcc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
20023fd0:	0005883a 	mov	r2,zero
20023fd4:	00001c06 	br	20024048 <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
20023fd8:	e0bffe17 	ldw	r2,-8(fp)
20023fdc:	10800003 	ldbu	r2,0(r2)
20023fe0:	10803fcc 	andi	r2,r2,255
20023fe4:	10800160 	cmpeqi	r2,r2,5
20023fe8:	1000051e 	bne	r2,zero,20024000 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
20023fec:	e0bfff17 	ldw	r2,-4(fp)
20023ff0:	00c00044 	movi	r3,1
20023ff4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
20023ff8:	0005883a 	mov	r2,zero
20023ffc:	00001206 	br	20024048 <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024000:	0005303a 	rdctl	r2,status
20024004:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024008:	e0fffc17 	ldw	r3,-16(fp)
2002400c:	00bfff84 	movi	r2,-2
20024010:	1884703a 	and	r2,r3,r2
20024014:	1001703a 	wrctl	status,r2
  
  return context;
20024018:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
2002401c:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
20024020:	e0bffe17 	ldw	r2,-8(fp)
20024024:	1080020b 	ldhu	r2,8(r2)
20024028:	e0bffb0d 	sth	r2,-20(fp)
2002402c:	e0bffa17 	ldw	r2,-24(fp)
20024030:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024034:	e0bffd17 	ldw	r2,-12(fp)
20024038:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2002403c:	e0bfff17 	ldw	r2,-4(fp)
20024040:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
20024044:	e0bffb0b 	ldhu	r2,-20(fp)
}
20024048:	e037883a 	mov	sp,fp
2002404c:	df000017 	ldw	fp,0(sp)
20024050:	dec00104 	addi	sp,sp,4
20024054:	f800283a 	ret

20024058 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
20024058:	defff804 	addi	sp,sp,-32
2002405c:	df000715 	stw	fp,28(sp)
20024060:	df000704 	addi	fp,sp,28
20024064:	e13ffb15 	stw	r4,-20(fp)
20024068:	e17ffc15 	stw	r5,-16(fp)
2002406c:	3009883a 	mov	r4,r6
20024070:	3807883a 	mov	r3,r7
20024074:	e0800117 	ldw	r2,4(fp)
20024078:	e13ffd0d 	sth	r4,-12(fp)
2002407c:	e0fffe05 	stb	r3,-8(fp)
20024080:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
20024084:	d0a60517 	ldw	r2,-26604(gp)
20024088:	d0e60517 	ldw	r3,-26604(gp)
2002408c:	18c00c03 	ldbu	r3,48(r3)
20024090:	18c00814 	ori	r3,r3,32
20024094:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
20024098:	d0a60517 	ldw	r2,-26604(gp)
2002409c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
200240a0:	d0a60517 	ldw	r2,-26604(gp)
200240a4:	e0ffff0b 	ldhu	r3,-4(fp)
200240a8:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
200240ac:	d0a60517 	ldw	r2,-26604(gp)
200240b0:	e0fffc17 	ldw	r3,-16(fp)
200240b4:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
200240b8:	e0bffc17 	ldw	r2,-16(fp)
200240bc:	e0fffd0b 	ldhu	r3,-12(fp)
200240c0:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
200240c4:	e0bffc17 	ldw	r2,-16(fp)
200240c8:	e0fffe03 	ldbu	r3,-8(fp)
200240cc:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
200240d0:	d0e60517 	ldw	r3,-26604(gp)
200240d4:	e0bffc17 	ldw	r2,-16(fp)
200240d8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
200240dc:	e0bffb17 	ldw	r2,-20(fp)
200240e0:	10c00117 	ldw	r3,4(r2)
200240e4:	e0bffc17 	ldw	r2,-16(fp)
200240e8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
200240ec:	e0bffc17 	ldw	r2,-16(fp)
200240f0:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
200240f4:	e0bffc17 	ldw	r2,-16(fp)
200240f8:	e0fffb17 	ldw	r3,-20(fp)
200240fc:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
20024100:	e0bffb17 	ldw	r2,-20(fp)
20024104:	10800117 	ldw	r2,4(r2)
20024108:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
2002410c:	e0bff917 	ldw	r2,-28(fp)
20024110:	10000326 	beq	r2,zero,20024120 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
20024114:	e0bff917 	ldw	r2,-28(fp)
20024118:	e0fffc17 	ldw	r3,-16(fp)
2002411c:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
20024120:	e0bffb17 	ldw	r2,-20(fp)
20024124:	e0fffc17 	ldw	r3,-16(fp)
20024128:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
2002412c:	d0a60517 	ldw	r2,-26604(gp)
20024130:	10800d03 	ldbu	r2,52(r2)
20024134:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
20024138:	e0fffa03 	ldbu	r3,-24(fp)
2002413c:	e13ffa03 	ldbu	r4,-24(fp)
20024140:	d0a60244 	addi	r2,gp,-26615
20024144:	2085883a 	add	r2,r4,r2
20024148:	10800003 	ldbu	r2,0(r2)
2002414c:	1009883a 	mov	r4,r2
20024150:	d0a60517 	ldw	r2,-26604(gp)
20024154:	10800d43 	ldbu	r2,53(r2)
20024158:	0084303a 	nor	r2,zero,r2
2002415c:	2084703a 	and	r2,r4,r2
20024160:	1009883a 	mov	r4,r2
20024164:	d0a60244 	addi	r2,gp,-26615
20024168:	1885883a 	add	r2,r3,r2
2002416c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
20024170:	e0fffa03 	ldbu	r3,-24(fp)
20024174:	d0a60244 	addi	r2,gp,-26615
20024178:	1885883a 	add	r2,r3,r2
2002417c:	10800003 	ldbu	r2,0(r2)
20024180:	10803fcc 	andi	r2,r2,255
20024184:	1000071e 	bne	r2,zero,200241a4 <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
20024188:	d0a60517 	ldw	r2,-26604(gp)
2002418c:	10800d83 	ldbu	r2,54(r2)
20024190:	0084303a 	nor	r2,zero,r2
20024194:	1007883a 	mov	r3,r2
20024198:	d0a60203 	ldbu	r2,-26616(gp)
2002419c:	1884703a 	and	r2,r3,r2
200241a0:	d0a60205 	stb	r2,-26616(gp)
    }
}
200241a4:	0001883a 	nop
200241a8:	e037883a 	mov	sp,fp
200241ac:	df000017 	ldw	fp,0(sp)
200241b0:	dec00104 	addi	sp,sp,4
200241b4:	f800283a 	ret

200241b8 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
200241b8:	defffb04 	addi	sp,sp,-20
200241bc:	dfc00415 	stw	ra,16(sp)
200241c0:	df000315 	stw	fp,12(sp)
200241c4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
200241c8:	0140dc04 	movi	r5,880
200241cc:	010800f4 	movhi	r4,8195
200241d0:	213a4104 	addi	r4,r4,-5884
200241d4:	00223fc0 	call	200223fc <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
200241d8:	008800f4 	movhi	r2,8195
200241dc:	10ba4104 	addi	r2,r2,-5884
200241e0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
200241e4:	008800f4 	movhi	r2,8195
200241e8:	10ba4c04 	addi	r2,r2,-5840
200241ec:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
200241f0:	e03ffd0d 	sth	zero,-12(fp)
200241f4:	00001306 	br	20024244 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
200241f8:	e0bffe17 	ldw	r2,-8(fp)
200241fc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
20024200:	e0bffe17 	ldw	r2,-8(fp)
20024204:	e0ffff17 	ldw	r3,-4(fp)
20024208:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
2002420c:	e0bffe17 	ldw	r2,-8(fp)
20024210:	00c00fc4 	movi	r3,63
20024214:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
20024218:	e0bffe17 	ldw	r2,-8(fp)
2002421c:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
20024220:	e0bffe17 	ldw	r2,-8(fp)
20024224:	10800b04 	addi	r2,r2,44
20024228:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
2002422c:	e0bfff17 	ldw	r2,-4(fp)
20024230:	10800b04 	addi	r2,r2,44
20024234:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
20024238:	e0bffd0b 	ldhu	r2,-12(fp)
2002423c:	10800044 	addi	r2,r2,1
20024240:	e0bffd0d 	sth	r2,-12(fp)
20024244:	e0bffd0b 	ldhu	r2,-12(fp)
20024248:	108004f0 	cmpltui	r2,r2,19
2002424c:	103fea1e 	bne	r2,zero,200241f8 <__alt_data_end+0xfffe41f8>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
20024250:	e0bffe17 	ldw	r2,-8(fp)
20024254:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
20024258:	e0bffe17 	ldw	r2,-8(fp)
2002425c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
20024260:	e0bffe17 	ldw	r2,-8(fp)
20024264:	00c00fc4 	movi	r3,63
20024268:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
2002426c:	e0bffe17 	ldw	r2,-8(fp)
20024270:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
20024274:	008800f4 	movhi	r2,8195
20024278:	10ba4104 	addi	r2,r2,-5884
2002427c:	d0a60715 	stw	r2,-26596(gp)
#endif
}
20024280:	0001883a 	nop
20024284:	e037883a 	mov	sp,fp
20024288:	dfc00117 	ldw	ra,4(sp)
2002428c:	df000017 	ldw	fp,0(sp)
20024290:	dec00204 	addi	sp,sp,8
20024294:	f800283a 	ret

20024298 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
20024298:	defffa04 	addi	sp,sp,-24
2002429c:	dfc00515 	stw	ra,20(sp)
200242a0:	df000415 	stw	fp,16(sp)
200242a4:	df000404 	addi	fp,sp,16
200242a8:	e13ffe15 	stw	r4,-8(fp)
200242ac:	2805883a 	mov	r2,r5
200242b0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
200242b4:	e0bffe17 	ldw	r2,-8(fp)
200242b8:	10800217 	ldw	r2,8(r2)
200242bc:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
200242c0:	e0bffd17 	ldw	r2,-12(fp)
200242c4:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
200242c8:	e0bffd17 	ldw	r2,-12(fp)
200242cc:	e0ffff0b 	ldhu	r3,-4(fp)
200242d0:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
200242d4:	e0bffd17 	ldw	r2,-12(fp)
200242d8:	10c00c03 	ldbu	r3,48(r2)
200242dc:	00bff7c4 	movi	r2,-33
200242e0:	1884703a 	and	r2,r3,r2
200242e4:	1007883a 	mov	r3,r2
200242e8:	e0bffd17 	ldw	r2,-12(fp)
200242ec:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
200242f0:	e0bffd17 	ldw	r2,-12(fp)
200242f4:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
200242f8:	e0bffd17 	ldw	r2,-12(fp)
200242fc:	10800c03 	ldbu	r2,48(r2)
20024300:	10803fcc 	andi	r2,r2,255
20024304:	1000181e 	bne	r2,zero,20024368 <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
20024308:	e0bffd17 	ldw	r2,-12(fp)
2002430c:	10c00d83 	ldbu	r3,54(r2)
20024310:	d0a60203 	ldbu	r2,-26616(gp)
20024314:	1884b03a 	or	r2,r3,r2
20024318:	d0a60205 	stb	r2,-26616(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
2002431c:	e0bffd17 	ldw	r2,-12(fp)
20024320:	10800d03 	ldbu	r2,52(r2)
20024324:	10c03fcc 	andi	r3,r2,255
20024328:	e0bffd17 	ldw	r2,-12(fp)
2002432c:	10800d03 	ldbu	r2,52(r2)
20024330:	11003fcc 	andi	r4,r2,255
20024334:	d0a60244 	addi	r2,gp,-26615
20024338:	2085883a 	add	r2,r4,r2
2002433c:	11000003 	ldbu	r4,0(r2)
20024340:	e0bffd17 	ldw	r2,-12(fp)
20024344:	10800d43 	ldbu	r2,53(r2)
20024348:	2084b03a 	or	r2,r4,r2
2002434c:	1009883a 	mov	r4,r2
20024350:	d0a60244 	addi	r2,gp,-26615
20024354:	1885883a 	add	r2,r3,r2
20024358:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
2002435c:	00800044 	movi	r2,1
20024360:	e0bffc05 	stb	r2,-16(fp)
20024364:	00000106 	br	2002436c <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
20024368:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
2002436c:	e13ffe17 	ldw	r4,-8(fp)
20024370:	002438c0 	call	2002438c <OS_FlagUnlink>
    return (sched);
20024374:	e0bffc03 	ldbu	r2,-16(fp)
}
20024378:	e037883a 	mov	sp,fp
2002437c:	dfc00117 	ldw	ra,4(sp)
20024380:	df000017 	ldw	fp,0(sp)
20024384:	dec00204 	addi	sp,sp,8
20024388:	f800283a 	ret

2002438c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
2002438c:	defffa04 	addi	sp,sp,-24
20024390:	df000515 	stw	fp,20(sp)
20024394:	df000504 	addi	fp,sp,20
20024398:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
2002439c:	e0bfff17 	ldw	r2,-4(fp)
200243a0:	10800117 	ldw	r2,4(r2)
200243a4:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
200243a8:	e0bfff17 	ldw	r2,-4(fp)
200243ac:	10800017 	ldw	r2,0(r2)
200243b0:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
200243b4:	e0bffb17 	ldw	r2,-20(fp)
200243b8:	10000b1e 	bne	r2,zero,200243e8 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
200243bc:	e0bfff17 	ldw	r2,-4(fp)
200243c0:	10800317 	ldw	r2,12(r2)
200243c4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
200243c8:	e0bffd17 	ldw	r2,-12(fp)
200243cc:	e0fffc17 	ldw	r3,-16(fp)
200243d0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
200243d4:	e0bffc17 	ldw	r2,-16(fp)
200243d8:	10000b26 	beq	r2,zero,20024408 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
200243dc:	e0bffc17 	ldw	r2,-16(fp)
200243e0:	10000115 	stw	zero,4(r2)
200243e4:	00000806 	br	20024408 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
200243e8:	e0bffb17 	ldw	r2,-20(fp)
200243ec:	e0fffc17 	ldw	r3,-16(fp)
200243f0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
200243f4:	e0bffc17 	ldw	r2,-16(fp)
200243f8:	10000326 	beq	r2,zero,20024408 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
200243fc:	e0bffc17 	ldw	r2,-16(fp)
20024400:	e0fffb17 	ldw	r3,-20(fp)
20024404:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
20024408:	e0bfff17 	ldw	r2,-4(fp)
2002440c:	10800217 	ldw	r2,8(r2)
20024410:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
20024414:	e0bffe17 	ldw	r2,-8(fp)
20024418:	10000a15 	stw	zero,40(r2)
#endif
}
2002441c:	0001883a 	nop
20024420:	e037883a 	mov	sp,fp
20024424:	df000017 	ldw	fp,0(sp)
20024428:	dec00104 	addi	sp,sp,4
2002442c:	f800283a 	ret

20024430 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
20024430:	defff404 	addi	sp,sp,-48
20024434:	df000b15 	stw	fp,44(sp)
20024438:	df000b04 	addi	fp,sp,44
2002443c:	e13ffc15 	stw	r4,-16(fp)
20024440:	e17ffd15 	stw	r5,-12(fp)
20024444:	e1bffe15 	stw	r6,-8(fp)
20024448:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
2002444c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
20024450:	e0bfff17 	ldw	r2,-4(fp)
20024454:	1000021e 	bne	r2,zero,20024460 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
20024458:	0005883a 	mov	r2,zero
2002445c:	00006506 	br	200245f4 <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
20024460:	e0bffc17 	ldw	r2,-16(fp)
20024464:	1000051e 	bne	r2,zero,2002447c <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
20024468:	e0bfff17 	ldw	r2,-4(fp)
2002446c:	00c01884 	movi	r3,98
20024470:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
20024474:	0005883a 	mov	r2,zero
20024478:	00005e06 	br	200245f4 <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
2002447c:	e0bffc17 	ldw	r2,-16(fp)
20024480:	108000cc 	andi	r2,r2,3
20024484:	10000526 	beq	r2,zero,2002449c <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
20024488:	e0bfff17 	ldw	r2,-4(fp)
2002448c:	00c01884 	movi	r3,98
20024490:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
20024494:	0005883a 	mov	r2,zero
20024498:	00005606 	br	200245f4 <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
2002449c:	e0bffd17 	ldw	r2,-12(fp)
200244a0:	108000a8 	cmpgeui	r2,r2,2
200244a4:	1000051e 	bne	r2,zero,200244bc <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
200244a8:	e0bfff17 	ldw	r2,-4(fp)
200244ac:	00c016c4 	movi	r3,91
200244b0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
200244b4:	0005883a 	mov	r2,zero
200244b8:	00004e06 	br	200245f4 <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
200244bc:	e0bffe17 	ldw	r2,-8(fp)
200244c0:	10800128 	cmpgeui	r2,r2,4
200244c4:	1000051e 	bne	r2,zero,200244dc <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
200244c8:	e0bfff17 	ldw	r2,-4(fp)
200244cc:	00c01704 	movi	r3,92
200244d0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
200244d4:	0005883a 	mov	r2,zero
200244d8:	00004606 	br	200245f4 <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200244dc:	0005303a 	rdctl	r2,status
200244e0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200244e4:	e0fffb17 	ldw	r3,-20(fp)
200244e8:	00bfff84 	movi	r2,-2
200244ec:	1884703a 	and	r2,r3,r2
200244f0:	1001703a 	wrctl	status,r2
  
  return context;
200244f4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
200244f8:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
200244fc:	d0a5ff17 	ldw	r2,-26628(gp)
20024500:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
20024504:	d0a5ff17 	ldw	r2,-26628(gp)
20024508:	10000326 	beq	r2,zero,20024518 <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
2002450c:	d0a5ff17 	ldw	r2,-26628(gp)
20024510:	10800117 	ldw	r2,4(r2)
20024514:	d0a5ff15 	stw	r2,-26628(gp)
20024518:	e0bff817 	ldw	r2,-32(fp)
2002451c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024520:	e0bff917 	ldw	r2,-28(fp)
20024524:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
20024528:	e0bffa17 	ldw	r2,-24(fp)
2002452c:	1000051e 	bne	r2,zero,20024544 <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
20024530:	e0bfff17 	ldw	r2,-4(fp)
20024534:	00c01684 	movi	r3,90
20024538:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
2002453c:	0005883a 	mov	r2,zero
20024540:	00002c06 	br	200245f4 <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
20024544:	e0bffc17 	ldw	r2,-16(fp)
20024548:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
2002454c:	e0fffc17 	ldw	r3,-16(fp)
20024550:	e0bffe17 	ldw	r2,-8(fp)
20024554:	1885883a 	add	r2,r3,r2
20024558:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
2002455c:	e03ff715 	stw	zero,-36(fp)
20024560:	00000c06 	br	20024594 <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
20024564:	e0bff617 	ldw	r2,-40(fp)
20024568:	e0fff517 	ldw	r3,-44(fp)
2002456c:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
20024570:	e0bff517 	ldw	r2,-44(fp)
20024574:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
20024578:	e0fff517 	ldw	r3,-44(fp)
2002457c:	e0bffe17 	ldw	r2,-8(fp)
20024580:	1885883a 	add	r2,r3,r2
20024584:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
20024588:	e0bff717 	ldw	r2,-36(fp)
2002458c:	10800044 	addi	r2,r2,1
20024590:	e0bff715 	stw	r2,-36(fp)
20024594:	e0bffd17 	ldw	r2,-12(fp)
20024598:	10bfffc4 	addi	r2,r2,-1
2002459c:	e0fff717 	ldw	r3,-36(fp)
200245a0:	18bff036 	bltu	r3,r2,20024564 <__alt_data_end+0xfffe4564>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
200245a4:	e0bff617 	ldw	r2,-40(fp)
200245a8:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
200245ac:	e0bffa17 	ldw	r2,-24(fp)
200245b0:	e0fffc17 	ldw	r3,-16(fp)
200245b4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
200245b8:	e0bffa17 	ldw	r2,-24(fp)
200245bc:	e0fffc17 	ldw	r3,-16(fp)
200245c0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
200245c4:	e0bffa17 	ldw	r2,-24(fp)
200245c8:	e0fffd17 	ldw	r3,-12(fp)
200245cc:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
200245d0:	e0bffa17 	ldw	r2,-24(fp)
200245d4:	e0fffd17 	ldw	r3,-12(fp)
200245d8:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
200245dc:	e0bffa17 	ldw	r2,-24(fp)
200245e0:	e0fffe17 	ldw	r3,-8(fp)
200245e4:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
200245e8:	e0bfff17 	ldw	r2,-4(fp)
200245ec:	10000005 	stb	zero,0(r2)
    return (pmem);
200245f0:	e0bffa17 	ldw	r2,-24(fp)
}
200245f4:	e037883a 	mov	sp,fp
200245f8:	df000017 	ldw	fp,0(sp)
200245fc:	dec00104 	addi	sp,sp,4
20024600:	f800283a 	ret

20024604 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
20024604:	defff804 	addi	sp,sp,-32
20024608:	df000715 	stw	fp,28(sp)
2002460c:	df000704 	addi	fp,sp,28
20024610:	e13ffe15 	stw	r4,-8(fp)
20024614:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20024618:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
2002461c:	e0bfff17 	ldw	r2,-4(fp)
20024620:	1000021e 	bne	r2,zero,2002462c <OSMemGet+0x28>
        return ((void *)0);
20024624:	0005883a 	mov	r2,zero
20024628:	00002e06 	br	200246e4 <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
2002462c:	e0bffe17 	ldw	r2,-8(fp)
20024630:	1000051e 	bne	r2,zero,20024648 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
20024634:	e0bfff17 	ldw	r2,-4(fp)
20024638:	00c01804 	movi	r3,96
2002463c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
20024640:	0005883a 	mov	r2,zero
20024644:	00002706 	br	200246e4 <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024648:	0005303a 	rdctl	r2,status
2002464c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024650:	e0fffd17 	ldw	r3,-12(fp)
20024654:	00bfff84 	movi	r2,-2
20024658:	1884703a 	and	r2,r3,r2
2002465c:	1001703a 	wrctl	status,r2
  
  return context;
20024660:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
20024664:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
20024668:	e0bffe17 	ldw	r2,-8(fp)
2002466c:	10800417 	ldw	r2,16(r2)
20024670:	10001426 	beq	r2,zero,200246c4 <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
20024674:	e0bffe17 	ldw	r2,-8(fp)
20024678:	10800117 	ldw	r2,4(r2)
2002467c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
20024680:	e0bffb17 	ldw	r2,-20(fp)
20024684:	10c00017 	ldw	r3,0(r2)
20024688:	e0bffe17 	ldw	r2,-8(fp)
2002468c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
20024690:	e0bffe17 	ldw	r2,-8(fp)
20024694:	10800417 	ldw	r2,16(r2)
20024698:	10ffffc4 	addi	r3,r2,-1
2002469c:	e0bffe17 	ldw	r2,-8(fp)
200246a0:	10c00415 	stw	r3,16(r2)
200246a4:	e0bff917 	ldw	r2,-28(fp)
200246a8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200246ac:	e0bffa17 	ldw	r2,-24(fp)
200246b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
200246b4:	e0bfff17 	ldw	r2,-4(fp)
200246b8:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
200246bc:	e0bffb17 	ldw	r2,-20(fp)
200246c0:	00000806 	br	200246e4 <OSMemGet+0xe0>
200246c4:	e0bff917 	ldw	r2,-28(fp)
200246c8:	e0bffc15 	stw	r2,-16(fp)
200246cc:	e0bffc17 	ldw	r2,-16(fp)
200246d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
200246d4:	e0bfff17 	ldw	r2,-4(fp)
200246d8:	00c01744 	movi	r3,93
200246dc:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
200246e0:	0005883a 	mov	r2,zero
}
200246e4:	e037883a 	mov	sp,fp
200246e8:	df000017 	ldw	fp,0(sp)
200246ec:	dec00104 	addi	sp,sp,4
200246f0:	f800283a 	ret

200246f4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
200246f4:	defff704 	addi	sp,sp,-36
200246f8:	dfc00815 	stw	ra,32(sp)
200246fc:	df000715 	stw	fp,28(sp)
20024700:	df000704 	addi	fp,sp,28
20024704:	e13ffd15 	stw	r4,-12(fp)
20024708:	e17ffe15 	stw	r5,-8(fp)
2002470c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20024710:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20024714:	e0bfff17 	ldw	r2,-4(fp)
20024718:	1000021e 	bne	r2,zero,20024724 <OSMemNameGet+0x30>
        return (0);
2002471c:	0005883a 	mov	r2,zero
20024720:	00002b06 	br	200247d0 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
20024724:	e0bffd17 	ldw	r2,-12(fp)
20024728:	1000051e 	bne	r2,zero,20024740 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
2002472c:	e0bfff17 	ldw	r2,-4(fp)
20024730:	00c01804 	movi	r3,96
20024734:	10c00005 	stb	r3,0(r2)
        return (0);
20024738:	0005883a 	mov	r2,zero
2002473c:	00002406 	br	200247d0 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
20024740:	e0bffe17 	ldw	r2,-8(fp)
20024744:	1000051e 	bne	r2,zero,2002475c <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
20024748:	e0bfff17 	ldw	r2,-4(fp)
2002474c:	00c00304 	movi	r3,12
20024750:	10c00005 	stb	r3,0(r2)
        return (0);
20024754:	0005883a 	mov	r2,zero
20024758:	00001d06 	br	200247d0 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2002475c:	d0a60403 	ldbu	r2,-26608(gp)
20024760:	10803fcc 	andi	r2,r2,255
20024764:	10000526 	beq	r2,zero,2002477c <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
20024768:	e0bfff17 	ldw	r2,-4(fp)
2002476c:	00c00444 	movi	r3,17
20024770:	10c00005 	stb	r3,0(r2)
        return (0);
20024774:	0005883a 	mov	r2,zero
20024778:	00001506 	br	200247d0 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002477c:	0005303a 	rdctl	r2,status
20024780:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024784:	e0fffb17 	ldw	r3,-20(fp)
20024788:	00bfff84 	movi	r2,-2
2002478c:	1884703a 	and	r2,r3,r2
20024790:	1001703a 	wrctl	status,r2
  
  return context;
20024794:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
20024798:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
2002479c:	e0bffd17 	ldw	r2,-12(fp)
200247a0:	10800504 	addi	r2,r2,20
200247a4:	100b883a 	mov	r5,r2
200247a8:	e13ffe17 	ldw	r4,-8(fp)
200247ac:	00225fc0 	call	200225fc <OS_StrCopy>
200247b0:	e0bffa05 	stb	r2,-24(fp)
200247b4:	e0bff917 	ldw	r2,-28(fp)
200247b8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200247bc:	e0bffc17 	ldw	r2,-16(fp)
200247c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
200247c4:	e0bfff17 	ldw	r2,-4(fp)
200247c8:	10000005 	stb	zero,0(r2)
    return (len);
200247cc:	e0bffa03 	ldbu	r2,-24(fp)
}
200247d0:	e037883a 	mov	sp,fp
200247d4:	dfc00117 	ldw	ra,4(sp)
200247d8:	df000017 	ldw	fp,0(sp)
200247dc:	dec00204 	addi	sp,sp,8
200247e0:	f800283a 	ret

200247e4 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
200247e4:	defff604 	addi	sp,sp,-40
200247e8:	dfc00915 	stw	ra,36(sp)
200247ec:	df000815 	stw	fp,32(sp)
200247f0:	df000804 	addi	fp,sp,32
200247f4:	e13ffd15 	stw	r4,-12(fp)
200247f8:	e17ffe15 	stw	r5,-8(fp)
200247fc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20024800:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20024804:	e0bfff17 	ldw	r2,-4(fp)
20024808:	10003526 	beq	r2,zero,200248e0 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
2002480c:	e0bffd17 	ldw	r2,-12(fp)
20024810:	1000041e 	bne	r2,zero,20024824 <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
20024814:	e0bfff17 	ldw	r2,-4(fp)
20024818:	00c01804 	movi	r3,96
2002481c:	10c00005 	stb	r3,0(r2)
        return;
20024820:	00003006 	br	200248e4 <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
20024824:	e0bffe17 	ldw	r2,-8(fp)
20024828:	1000041e 	bne	r2,zero,2002483c <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
2002482c:	e0bfff17 	ldw	r2,-4(fp)
20024830:	00c00304 	movi	r3,12
20024834:	10c00005 	stb	r3,0(r2)
        return;
20024838:	00002a06 	br	200248e4 <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2002483c:	d0a60403 	ldbu	r2,-26608(gp)
20024840:	10803fcc 	andi	r2,r2,255
20024844:	10000426 	beq	r2,zero,20024858 <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
20024848:	e0bfff17 	ldw	r2,-4(fp)
2002484c:	00c00484 	movi	r3,18
20024850:	10c00005 	stb	r3,0(r2)
        return;
20024854:	00002306 	br	200248e4 <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024858:	0005303a 	rdctl	r2,status
2002485c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024860:	e0fffc17 	ldw	r3,-16(fp)
20024864:	00bfff84 	movi	r2,-2
20024868:	1884703a 	and	r2,r3,r2
2002486c:	1001703a 	wrctl	status,r2
  
  return context;
20024870:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
20024874:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
20024878:	e13ffe17 	ldw	r4,-8(fp)
2002487c:	00226700 	call	20022670 <OS_StrLen>
20024880:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
20024884:	e0bffa03 	ldbu	r2,-24(fp)
20024888:	10800830 	cmpltui	r2,r2,32
2002488c:	1000081e 	bne	r2,zero,200248b0 <OSMemNameSet+0xcc>
20024890:	e0bff817 	ldw	r2,-32(fp)
20024894:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024898:	e0bff917 	ldw	r2,-28(fp)
2002489c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
200248a0:	e0bfff17 	ldw	r2,-4(fp)
200248a4:	00c018c4 	movi	r3,99
200248a8:	10c00005 	stb	r3,0(r2)
        return;
200248ac:	00000d06 	br	200248e4 <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
200248b0:	e0bffd17 	ldw	r2,-12(fp)
200248b4:	10800504 	addi	r2,r2,20
200248b8:	e17ffe17 	ldw	r5,-8(fp)
200248bc:	1009883a 	mov	r4,r2
200248c0:	00225fc0 	call	200225fc <OS_StrCopy>
200248c4:	e0bff817 	ldw	r2,-32(fp)
200248c8:	e0bffb15 	stw	r2,-20(fp)
200248cc:	e0bffb17 	ldw	r2,-20(fp)
200248d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
200248d4:	e0bfff17 	ldw	r2,-4(fp)
200248d8:	10000005 	stb	zero,0(r2)
200248dc:	00000106 	br	200248e4 <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
200248e0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
200248e4:	e037883a 	mov	sp,fp
200248e8:	dfc00117 	ldw	ra,4(sp)
200248ec:	df000017 	ldw	fp,0(sp)
200248f0:	dec00204 	addi	sp,sp,8
200248f4:	f800283a 	ret

200248f8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
200248f8:	defff904 	addi	sp,sp,-28
200248fc:	df000615 	stw	fp,24(sp)
20024900:	df000604 	addi	fp,sp,24
20024904:	e13ffe15 	stw	r4,-8(fp)
20024908:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
2002490c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
20024910:	e0bffe17 	ldw	r2,-8(fp)
20024914:	1000021e 	bne	r2,zero,20024920 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
20024918:	00801804 	movi	r2,96
2002491c:	00002806 	br	200249c0 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
20024920:	e0bfff17 	ldw	r2,-4(fp)
20024924:	1000021e 	bne	r2,zero,20024930 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
20024928:	008017c4 	movi	r2,95
2002492c:	00002406 	br	200249c0 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024930:	0005303a 	rdctl	r2,status
20024934:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024938:	e0fffd17 	ldw	r3,-12(fp)
2002493c:	00bfff84 	movi	r2,-2
20024940:	1884703a 	and	r2,r3,r2
20024944:	1001703a 	wrctl	status,r2
  
  return context;
20024948:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
2002494c:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
20024950:	e0bffe17 	ldw	r2,-8(fp)
20024954:	10c00417 	ldw	r3,16(r2)
20024958:	e0bffe17 	ldw	r2,-8(fp)
2002495c:	10800317 	ldw	r2,12(r2)
20024960:	18800636 	bltu	r3,r2,2002497c <OSMemPut+0x84>
20024964:	e0bffa17 	ldw	r2,-24(fp)
20024968:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002496c:	e0bffb17 	ldw	r2,-20(fp)
20024970:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
20024974:	00801784 	movi	r2,94
20024978:	00001106 	br	200249c0 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
2002497c:	e0bffe17 	ldw	r2,-8(fp)
20024980:	10c00117 	ldw	r3,4(r2)
20024984:	e0bfff17 	ldw	r2,-4(fp)
20024988:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
2002498c:	e0bffe17 	ldw	r2,-8(fp)
20024990:	e0ffff17 	ldw	r3,-4(fp)
20024994:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
20024998:	e0bffe17 	ldw	r2,-8(fp)
2002499c:	10800417 	ldw	r2,16(r2)
200249a0:	10c00044 	addi	r3,r2,1
200249a4:	e0bffe17 	ldw	r2,-8(fp)
200249a8:	10c00415 	stw	r3,16(r2)
200249ac:	e0bffa17 	ldw	r2,-24(fp)
200249b0:	e0bffc15 	stw	r2,-16(fp)
200249b4:	e0bffc17 	ldw	r2,-16(fp)
200249b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
200249bc:	0005883a 	mov	r2,zero
}
200249c0:	e037883a 	mov	sp,fp
200249c4:	df000017 	ldw	fp,0(sp)
200249c8:	dec00104 	addi	sp,sp,4
200249cc:	f800283a 	ret

200249d0 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
200249d0:	defffa04 	addi	sp,sp,-24
200249d4:	df000515 	stw	fp,20(sp)
200249d8:	df000504 	addi	fp,sp,20
200249dc:	e13ffe15 	stw	r4,-8(fp)
200249e0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200249e4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
200249e8:	e0bffe17 	ldw	r2,-8(fp)
200249ec:	1000021e 	bne	r2,zero,200249f8 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
200249f0:	00801804 	movi	r2,96
200249f4:	00002c06 	br	20024aa8 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
200249f8:	e0bfff17 	ldw	r2,-4(fp)
200249fc:	1000021e 	bne	r2,zero,20024a08 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
20024a00:	00801844 	movi	r2,97
20024a04:	00002806 	br	20024aa8 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024a08:	0005303a 	rdctl	r2,status
20024a0c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024a10:	e0fffc17 	ldw	r3,-16(fp)
20024a14:	00bfff84 	movi	r2,-2
20024a18:	1884703a 	and	r2,r3,r2
20024a1c:	1001703a 	wrctl	status,r2
  
  return context;
20024a20:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
20024a24:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
20024a28:	e0bffe17 	ldw	r2,-8(fp)
20024a2c:	10c00017 	ldw	r3,0(r2)
20024a30:	e0bfff17 	ldw	r2,-4(fp)
20024a34:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
20024a38:	e0bffe17 	ldw	r2,-8(fp)
20024a3c:	10c00117 	ldw	r3,4(r2)
20024a40:	e0bfff17 	ldw	r2,-4(fp)
20024a44:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
20024a48:	e0bffe17 	ldw	r2,-8(fp)
20024a4c:	10c00217 	ldw	r3,8(r2)
20024a50:	e0bfff17 	ldw	r2,-4(fp)
20024a54:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
20024a58:	e0bffe17 	ldw	r2,-8(fp)
20024a5c:	10c00317 	ldw	r3,12(r2)
20024a60:	e0bfff17 	ldw	r2,-4(fp)
20024a64:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
20024a68:	e0bffe17 	ldw	r2,-8(fp)
20024a6c:	10c00417 	ldw	r3,16(r2)
20024a70:	e0bfff17 	ldw	r2,-4(fp)
20024a74:	10c00415 	stw	r3,16(r2)
20024a78:	e0bffb17 	ldw	r2,-20(fp)
20024a7c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024a80:	e0bffd17 	ldw	r2,-12(fp)
20024a84:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
20024a88:	e0bfff17 	ldw	r2,-4(fp)
20024a8c:	10c00317 	ldw	r3,12(r2)
20024a90:	e0bfff17 	ldw	r2,-4(fp)
20024a94:	10800417 	ldw	r2,16(r2)
20024a98:	1887c83a 	sub	r3,r3,r2
20024a9c:	e0bfff17 	ldw	r2,-4(fp)
20024aa0:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
20024aa4:	0005883a 	mov	r2,zero
}
20024aa8:	e037883a 	mov	sp,fp
20024aac:	df000017 	ldw	fp,0(sp)
20024ab0:	dec00104 	addi	sp,sp,4
20024ab4:	f800283a 	ret

20024ab8 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
20024ab8:	defffc04 	addi	sp,sp,-16
20024abc:	dfc00315 	stw	ra,12(sp)
20024ac0:	df000215 	stw	fp,8(sp)
20024ac4:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
20024ac8:	01430c04 	movi	r5,3120
20024acc:	010800f4 	movhi	r4,8195
20024ad0:	213b1d04 	addi	r4,r4,-5004
20024ad4:	00223fc0 	call	200223fc <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
20024ad8:	008800f4 	movhi	r2,8195
20024adc:	10bb1d04 	addi	r2,r2,-5004
20024ae0:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
20024ae4:	e03fff0d 	sth	zero,-4(fp)
20024ae8:	00001306 	br	20024b38 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
20024aec:	e0bfff0b 	ldhu	r2,-4(fp)
20024af0:	10800044 	addi	r2,r2,1
20024af4:	10c00d24 	muli	r3,r2,52
20024af8:	008800f4 	movhi	r2,8195
20024afc:	10bb1d04 	addi	r2,r2,-5004
20024b00:	1887883a 	add	r3,r3,r2
20024b04:	e0bffe17 	ldw	r2,-8(fp)
20024b08:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
20024b0c:	e0bffe17 	ldw	r2,-8(fp)
20024b10:	00c00fc4 	movi	r3,63
20024b14:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
20024b18:	e0bffe17 	ldw	r2,-8(fp)
20024b1c:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
20024b20:	e0bffe17 	ldw	r2,-8(fp)
20024b24:	10800d04 	addi	r2,r2,52
20024b28:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
20024b2c:	e0bfff0b 	ldhu	r2,-4(fp)
20024b30:	10800044 	addi	r2,r2,1
20024b34:	e0bfff0d 	sth	r2,-4(fp)
20024b38:	e0bfff0b 	ldhu	r2,-4(fp)
20024b3c:	10800ef0 	cmpltui	r2,r2,59
20024b40:	103fea1e 	bne	r2,zero,20024aec <__alt_data_end+0xfffe4aec>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
20024b44:	e0bffe17 	ldw	r2,-8(fp)
20024b48:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
20024b4c:	e0bffe17 	ldw	r2,-8(fp)
20024b50:	00c00fc4 	movi	r3,63
20024b54:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
20024b58:	e0bffe17 	ldw	r2,-8(fp)
20024b5c:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
20024b60:	008800f4 	movhi	r2,8195
20024b64:	10bb1d04 	addi	r2,r2,-5004
20024b68:	d0a5ff15 	stw	r2,-26628(gp)
#endif
}
20024b6c:	0001883a 	nop
20024b70:	e037883a 	mov	sp,fp
20024b74:	dfc00117 	ldw	ra,4(sp)
20024b78:	df000017 	ldw	fp,0(sp)
20024b7c:	dec00204 	addi	sp,sp,8
20024b80:	f800283a 	ret

20024b84 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
20024b84:	defff804 	addi	sp,sp,-32
20024b88:	df000715 	stw	fp,28(sp)
20024b8c:	df000704 	addi	fp,sp,28
20024b90:	e13ffe15 	stw	r4,-8(fp)
20024b94:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20024b98:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20024b9c:	e0bfff17 	ldw	r2,-4(fp)
20024ba0:	1000021e 	bne	r2,zero,20024bac <OSQAccept+0x28>
        return ((void *)0);
20024ba4:	0005883a 	mov	r2,zero
20024ba8:	00004206 	br	20024cb4 <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
20024bac:	e0bffe17 	ldw	r2,-8(fp)
20024bb0:	1000051e 	bne	r2,zero,20024bc8 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
20024bb4:	e0bfff17 	ldw	r2,-4(fp)
20024bb8:	00c00104 	movi	r3,4
20024bbc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
20024bc0:	0005883a 	mov	r2,zero
20024bc4:	00003b06 	br	20024cb4 <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
20024bc8:	e0bffe17 	ldw	r2,-8(fp)
20024bcc:	10800003 	ldbu	r2,0(r2)
20024bd0:	10803fcc 	andi	r2,r2,255
20024bd4:	108000a0 	cmpeqi	r2,r2,2
20024bd8:	1000051e 	bne	r2,zero,20024bf0 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
20024bdc:	e0bfff17 	ldw	r2,-4(fp)
20024be0:	00c00044 	movi	r3,1
20024be4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
20024be8:	0005883a 	mov	r2,zero
20024bec:	00003106 	br	20024cb4 <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024bf0:	0005303a 	rdctl	r2,status
20024bf4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024bf8:	e0fffd17 	ldw	r3,-12(fp)
20024bfc:	00bfff84 	movi	r2,-2
20024c00:	1884703a 	and	r2,r3,r2
20024c04:	1001703a 	wrctl	status,r2
  
  return context;
20024c08:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
20024c0c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
20024c10:	e0bffe17 	ldw	r2,-8(fp)
20024c14:	10800117 	ldw	r2,4(r2)
20024c18:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
20024c1c:	e0bffc17 	ldw	r2,-16(fp)
20024c20:	1080058b 	ldhu	r2,22(r2)
20024c24:	10bfffcc 	andi	r2,r2,65535
20024c28:	10001926 	beq	r2,zero,20024c90 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
20024c2c:	e0bffc17 	ldw	r2,-16(fp)
20024c30:	10800417 	ldw	r2,16(r2)
20024c34:	11000104 	addi	r4,r2,4
20024c38:	e0fffc17 	ldw	r3,-16(fp)
20024c3c:	19000415 	stw	r4,16(r3)
20024c40:	10800017 	ldw	r2,0(r2)
20024c44:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
20024c48:	e0bffc17 	ldw	r2,-16(fp)
20024c4c:	1080058b 	ldhu	r2,22(r2)
20024c50:	10bfffc4 	addi	r2,r2,-1
20024c54:	1007883a 	mov	r3,r2
20024c58:	e0bffc17 	ldw	r2,-16(fp)
20024c5c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
20024c60:	e0bffc17 	ldw	r2,-16(fp)
20024c64:	10c00417 	ldw	r3,16(r2)
20024c68:	e0bffc17 	ldw	r2,-16(fp)
20024c6c:	10800217 	ldw	r2,8(r2)
20024c70:	1880041e 	bne	r3,r2,20024c84 <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
20024c74:	e0bffc17 	ldw	r2,-16(fp)
20024c78:	10c00117 	ldw	r3,4(r2)
20024c7c:	e0bffc17 	ldw	r2,-16(fp)
20024c80:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
20024c84:	e0bfff17 	ldw	r2,-4(fp)
20024c88:	10000005 	stb	zero,0(r2)
20024c8c:	00000406 	br	20024ca0 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
20024c90:	e0bfff17 	ldw	r2,-4(fp)
20024c94:	00c007c4 	movi	r3,31
20024c98:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
20024c9c:	e03ff915 	stw	zero,-28(fp)
20024ca0:	e0bffa17 	ldw	r2,-24(fp)
20024ca4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024ca8:	e0bffb17 	ldw	r2,-20(fp)
20024cac:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
20024cb0:	e0bff917 	ldw	r2,-28(fp)
}
20024cb4:	e037883a 	mov	sp,fp
20024cb8:	df000017 	ldw	fp,0(sp)
20024cbc:	dec00104 	addi	sp,sp,4
20024cc0:	f800283a 	ret

20024cc4 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
20024cc4:	defff404 	addi	sp,sp,-48
20024cc8:	dfc00b15 	stw	ra,44(sp)
20024ccc:	df000a15 	stw	fp,40(sp)
20024cd0:	df000a04 	addi	fp,sp,40
20024cd4:	e13ffe15 	stw	r4,-8(fp)
20024cd8:	2805883a 	mov	r2,r5
20024cdc:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20024ce0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
20024ce4:	d0a60403 	ldbu	r2,-26608(gp)
20024ce8:	10803fcc 	andi	r2,r2,255
20024cec:	10000226 	beq	r2,zero,20024cf8 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
20024cf0:	0005883a 	mov	r2,zero
20024cf4:	00005906 	br	20024e5c <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024cf8:	0005303a 	rdctl	r2,status
20024cfc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024d00:	e0fffd17 	ldw	r3,-12(fp)
20024d04:	00bfff84 	movi	r2,-2
20024d08:	1884703a 	and	r2,r3,r2
20024d0c:	1001703a 	wrctl	status,r2
  
  return context;
20024d10:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
20024d14:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
20024d18:	d0a60317 	ldw	r2,-26612(gp)
20024d1c:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
20024d20:	d0a60317 	ldw	r2,-26612(gp)
20024d24:	10000326 	beq	r2,zero,20024d34 <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
20024d28:	d0a60317 	ldw	r2,-26612(gp)
20024d2c:	10800117 	ldw	r2,4(r2)
20024d30:	d0a60315 	stw	r2,-26612(gp)
20024d34:	e0bff717 	ldw	r2,-36(fp)
20024d38:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024d3c:	e0bff817 	ldw	r2,-32(fp)
20024d40:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
20024d44:	e0bff617 	ldw	r2,-40(fp)
20024d48:	10004326 	beq	r2,zero,20024e58 <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024d4c:	0005303a 	rdctl	r2,status
20024d50:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024d54:	e0fff917 	ldw	r3,-28(fp)
20024d58:	00bfff84 	movi	r2,-2
20024d5c:	1884703a 	and	r2,r3,r2
20024d60:	1001703a 	wrctl	status,r2
  
  return context;
20024d64:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
20024d68:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
20024d6c:	d0a60117 	ldw	r2,-26620(gp)
20024d70:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
20024d74:	e0bffb17 	ldw	r2,-20(fp)
20024d78:	10002d26 	beq	r2,zero,20024e30 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
20024d7c:	d0a60117 	ldw	r2,-26620(gp)
20024d80:	10800017 	ldw	r2,0(r2)
20024d84:	d0a60115 	stw	r2,-26620(gp)
20024d88:	e0bff717 	ldw	r2,-36(fp)
20024d8c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024d90:	e0bffa17 	ldw	r2,-24(fp)
20024d94:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
20024d98:	e0bffb17 	ldw	r2,-20(fp)
20024d9c:	e0fffe17 	ldw	r3,-8(fp)
20024da0:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
20024da4:	e0bfff0b 	ldhu	r2,-4(fp)
20024da8:	1085883a 	add	r2,r2,r2
20024dac:	1085883a 	add	r2,r2,r2
20024db0:	1007883a 	mov	r3,r2
20024db4:	e0bffe17 	ldw	r2,-8(fp)
20024db8:	10c7883a 	add	r3,r2,r3
20024dbc:	e0bffb17 	ldw	r2,-20(fp)
20024dc0:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
20024dc4:	e0bffb17 	ldw	r2,-20(fp)
20024dc8:	e0fffe17 	ldw	r3,-8(fp)
20024dcc:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
20024dd0:	e0bffb17 	ldw	r2,-20(fp)
20024dd4:	e0fffe17 	ldw	r3,-8(fp)
20024dd8:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
20024ddc:	e0bffb17 	ldw	r2,-20(fp)
20024de0:	e0ffff0b 	ldhu	r3,-4(fp)
20024de4:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
20024de8:	e0bffb17 	ldw	r2,-20(fp)
20024dec:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
20024df0:	e0bff617 	ldw	r2,-40(fp)
20024df4:	00c00084 	movi	r3,2
20024df8:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
20024dfc:	e0bff617 	ldw	r2,-40(fp)
20024e00:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
20024e04:	e0bff617 	ldw	r2,-40(fp)
20024e08:	e0fffb17 	ldw	r3,-20(fp)
20024e0c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
20024e10:	e0bff617 	ldw	r2,-40(fp)
20024e14:	00c00fc4 	movi	r3,63
20024e18:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
20024e1c:	e0bff617 	ldw	r2,-40(fp)
20024e20:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
20024e24:	e13ff617 	ldw	r4,-40(fp)
20024e28:	002201c0 	call	2002201c <OS_EventWaitListInit>
20024e2c:	00000a06 	br	20024e58 <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
20024e30:	d0e60317 	ldw	r3,-26612(gp)
20024e34:	e0bff617 	ldw	r2,-40(fp)
20024e38:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
20024e3c:	e0bff617 	ldw	r2,-40(fp)
20024e40:	d0a60315 	stw	r2,-26612(gp)
20024e44:	e0bff717 	ldw	r2,-36(fp)
20024e48:	e0bffc15 	stw	r2,-16(fp)
20024e4c:	e0bffc17 	ldw	r2,-16(fp)
20024e50:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
20024e54:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
20024e58:	e0bff617 	ldw	r2,-40(fp)
}
20024e5c:	e037883a 	mov	sp,fp
20024e60:	dfc00117 	ldw	ra,4(sp)
20024e64:	df000017 	ldw	fp,0(sp)
20024e68:	dec00204 	addi	sp,sp,8
20024e6c:	f800283a 	ret

20024e70 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
20024e70:	defff204 	addi	sp,sp,-56
20024e74:	dfc00d15 	stw	ra,52(sp)
20024e78:	df000c15 	stw	fp,48(sp)
20024e7c:	df000c04 	addi	fp,sp,48
20024e80:	e13ffd15 	stw	r4,-12(fp)
20024e84:	2805883a 	mov	r2,r5
20024e88:	e1bfff15 	stw	r6,-4(fp)
20024e8c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
20024e90:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
20024e94:	e0bfff17 	ldw	r2,-4(fp)
20024e98:	1000021e 	bne	r2,zero,20024ea4 <OSQDel+0x34>
        return (pevent);
20024e9c:	e0bffd17 	ldw	r2,-12(fp)
20024ea0:	00008e06 	br	200250dc <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
20024ea4:	e0bffd17 	ldw	r2,-12(fp)
20024ea8:	1000051e 	bne	r2,zero,20024ec0 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
20024eac:	e0bfff17 	ldw	r2,-4(fp)
20024eb0:	00c00104 	movi	r3,4
20024eb4:	10c00005 	stb	r3,0(r2)
        return (pevent);
20024eb8:	e0bffd17 	ldw	r2,-12(fp)
20024ebc:	00008706 	br	200250dc <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
20024ec0:	e0bffd17 	ldw	r2,-12(fp)
20024ec4:	10800003 	ldbu	r2,0(r2)
20024ec8:	10803fcc 	andi	r2,r2,255
20024ecc:	108000a0 	cmpeqi	r2,r2,2
20024ed0:	1000051e 	bne	r2,zero,20024ee8 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
20024ed4:	e0bfff17 	ldw	r2,-4(fp)
20024ed8:	00c00044 	movi	r3,1
20024edc:	10c00005 	stb	r3,0(r2)
        return (pevent);
20024ee0:	e0bffd17 	ldw	r2,-12(fp)
20024ee4:	00007d06 	br	200250dc <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
20024ee8:	d0a60403 	ldbu	r2,-26608(gp)
20024eec:	10803fcc 	andi	r2,r2,255
20024ef0:	10000526 	beq	r2,zero,20024f08 <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
20024ef4:	e0bfff17 	ldw	r2,-4(fp)
20024ef8:	00c003c4 	movi	r3,15
20024efc:	10c00005 	stb	r3,0(r2)
        return (pevent);
20024f00:	e0bffd17 	ldw	r2,-12(fp)
20024f04:	00007506 	br	200250dc <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20024f08:	0005303a 	rdctl	r2,status
20024f0c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20024f10:	e0fffc17 	ldw	r3,-16(fp)
20024f14:	00bfff84 	movi	r2,-2
20024f18:	1884703a 	and	r2,r3,r2
20024f1c:	1001703a 	wrctl	status,r2
  
  return context;
20024f20:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
20024f24:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
20024f28:	e0bffd17 	ldw	r2,-12(fp)
20024f2c:	10800283 	ldbu	r2,10(r2)
20024f30:	10803fcc 	andi	r2,r2,255
20024f34:	10000326 	beq	r2,zero,20024f44 <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
20024f38:	00800044 	movi	r2,1
20024f3c:	e0bff405 	stb	r2,-48(fp)
20024f40:	00000106 	br	20024f48 <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
20024f44:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
20024f48:	e0bffe03 	ldbu	r2,-8(fp)
20024f4c:	10000326 	beq	r2,zero,20024f5c <OSQDel+0xec>
20024f50:	10800060 	cmpeqi	r2,r2,1
20024f54:	1000301e 	bne	r2,zero,20025018 <OSQDel+0x1a8>
20024f58:	00005506 	br	200250b0 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
20024f5c:	e0bff403 	ldbu	r2,-48(fp)
20024f60:	10001e1e 	bne	r2,zero,20024fdc <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
20024f64:	e0bffd17 	ldw	r2,-12(fp)
20024f68:	00c00fc4 	movi	r3,63
20024f6c:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
20024f70:	e0bffd17 	ldw	r2,-12(fp)
20024f74:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
20024f78:	e0bffd17 	ldw	r2,-12(fp)
20024f7c:	10800117 	ldw	r2,4(r2)
20024f80:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
20024f84:	d0e60117 	ldw	r3,-26620(gp)
20024f88:	e0bff817 	ldw	r2,-32(fp)
20024f8c:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
20024f90:	e0bff817 	ldw	r2,-32(fp)
20024f94:	d0a60115 	stw	r2,-26620(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
20024f98:	e0bffd17 	ldw	r2,-12(fp)
20024f9c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
20024fa0:	d0e60317 	ldw	r3,-26612(gp)
20024fa4:	e0bffd17 	ldw	r2,-12(fp)
20024fa8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
20024fac:	e0bffd17 	ldw	r2,-12(fp)
20024fb0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
20024fb4:	e0bffd17 	ldw	r2,-12(fp)
20024fb8:	d0a60315 	stw	r2,-26612(gp)
20024fbc:	e0bff617 	ldw	r2,-40(fp)
20024fc0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20024fc4:	e0bff717 	ldw	r2,-36(fp)
20024fc8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
20024fcc:	e0bfff17 	ldw	r2,-4(fp)
20024fd0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
20024fd4:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
20024fd8:	00003f06 	br	200250d8 <OSQDel+0x268>
20024fdc:	e0bff617 	ldw	r2,-40(fp)
20024fe0:	e0bff915 	stw	r2,-28(fp)
20024fe4:	e0bff917 	ldw	r2,-28(fp)
20024fe8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
20024fec:	e0bfff17 	ldw	r2,-4(fp)
20024ff0:	00c01244 	movi	r3,73
20024ff4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
20024ff8:	e0bffd17 	ldw	r2,-12(fp)
20024ffc:	e0bff515 	stw	r2,-44(fp)
             }
             break;
20025000:	00003506 	br	200250d8 <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
20025004:	000f883a 	mov	r7,zero
20025008:	01800104 	movi	r6,4
2002500c:	000b883a 	mov	r5,zero
20025010:	e13ffd17 	ldw	r4,-12(fp)
20025014:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
20025018:	e0bffd17 	ldw	r2,-12(fp)
2002501c:	10800283 	ldbu	r2,10(r2)
20025020:	10803fcc 	andi	r2,r2,255
20025024:	103ff71e 	bne	r2,zero,20025004 <__alt_data_end+0xfffe5004>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
20025028:	e0bffd17 	ldw	r2,-12(fp)
2002502c:	00c00fc4 	movi	r3,63
20025030:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
20025034:	e0bffd17 	ldw	r2,-12(fp)
20025038:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
2002503c:	e0bffd17 	ldw	r2,-12(fp)
20025040:	10800117 	ldw	r2,4(r2)
20025044:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
20025048:	d0e60117 	ldw	r3,-26620(gp)
2002504c:	e0bff817 	ldw	r2,-32(fp)
20025050:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
20025054:	e0bff817 	ldw	r2,-32(fp)
20025058:	d0a60115 	stw	r2,-26620(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
2002505c:	e0bffd17 	ldw	r2,-12(fp)
20025060:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
20025064:	d0e60317 	ldw	r3,-26612(gp)
20025068:	e0bffd17 	ldw	r2,-12(fp)
2002506c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
20025070:	e0bffd17 	ldw	r2,-12(fp)
20025074:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
20025078:	e0bffd17 	ldw	r2,-12(fp)
2002507c:	d0a60315 	stw	r2,-26612(gp)
20025080:	e0bff617 	ldw	r2,-40(fp)
20025084:	e0bffa15 	stw	r2,-24(fp)
20025088:	e0bffa17 	ldw	r2,-24(fp)
2002508c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
20025090:	e0bff403 	ldbu	r2,-48(fp)
20025094:	10800058 	cmpnei	r2,r2,1
20025098:	1000011e 	bne	r2,zero,200250a0 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
2002509c:	00224b80 	call	200224b8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
200250a0:	e0bfff17 	ldw	r2,-4(fp)
200250a4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
200250a8:	e03ff515 	stw	zero,-44(fp)
             break;
200250ac:	00000a06 	br	200250d8 <OSQDel+0x268>
200250b0:	e0bff617 	ldw	r2,-40(fp)
200250b4:	e0bffb15 	stw	r2,-20(fp)
200250b8:	e0bffb17 	ldw	r2,-20(fp)
200250bc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
200250c0:	e0bfff17 	ldw	r2,-4(fp)
200250c4:	00c001c4 	movi	r3,7
200250c8:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
200250cc:	e0bffd17 	ldw	r2,-12(fp)
200250d0:	e0bff515 	stw	r2,-44(fp)
             break;
200250d4:	0001883a 	nop
    }
    return (pevent_return);
200250d8:	e0bff517 	ldw	r2,-44(fp)
}
200250dc:	e037883a 	mov	sp,fp
200250e0:	dfc00117 	ldw	ra,4(sp)
200250e4:	df000017 	ldw	fp,0(sp)
200250e8:	dec00204 	addi	sp,sp,8
200250ec:	f800283a 	ret

200250f0 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
200250f0:	defffa04 	addi	sp,sp,-24
200250f4:	df000515 	stw	fp,20(sp)
200250f8:	df000504 	addi	fp,sp,20
200250fc:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20025100:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
20025104:	e0bfff17 	ldw	r2,-4(fp)
20025108:	1000021e 	bne	r2,zero,20025114 <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
2002510c:	00800104 	movi	r2,4
20025110:	00002106 	br	20025198 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
20025114:	e0bfff17 	ldw	r2,-4(fp)
20025118:	10800003 	ldbu	r2,0(r2)
2002511c:	10803fcc 	andi	r2,r2,255
20025120:	108000a0 	cmpeqi	r2,r2,2
20025124:	1000021e 	bne	r2,zero,20025130 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
20025128:	00800044 	movi	r2,1
2002512c:	00001a06 	br	20025198 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025130:	0005303a 	rdctl	r2,status
20025134:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025138:	e0fffd17 	ldw	r3,-12(fp)
2002513c:	00bfff84 	movi	r2,-2
20025140:	1884703a 	and	r2,r3,r2
20025144:	1001703a 	wrctl	status,r2
  
  return context;
20025148:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
2002514c:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
20025150:	e0bfff17 	ldw	r2,-4(fp)
20025154:	10800117 	ldw	r2,4(r2)
20025158:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
2002515c:	e0bffc17 	ldw	r2,-16(fp)
20025160:	10c00117 	ldw	r3,4(r2)
20025164:	e0bffc17 	ldw	r2,-16(fp)
20025168:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
2002516c:	e0bffc17 	ldw	r2,-16(fp)
20025170:	10c00117 	ldw	r3,4(r2)
20025174:	e0bffc17 	ldw	r2,-16(fp)
20025178:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
2002517c:	e0bffc17 	ldw	r2,-16(fp)
20025180:	1000058d 	sth	zero,22(r2)
20025184:	e0bffb17 	ldw	r2,-20(fp)
20025188:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002518c:	e0bffe17 	ldw	r2,-8(fp)
20025190:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
20025194:	0005883a 	mov	r2,zero
}
20025198:	e037883a 	mov	sp,fp
2002519c:	df000017 	ldw	fp,0(sp)
200251a0:	dec00104 	addi	sp,sp,4
200251a4:	f800283a 	ret

200251a8 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
200251a8:	defff304 	addi	sp,sp,-52
200251ac:	dfc00c15 	stw	ra,48(sp)
200251b0:	df000b15 	stw	fp,44(sp)
200251b4:	df000b04 	addi	fp,sp,44
200251b8:	e13ffd15 	stw	r4,-12(fp)
200251bc:	2805883a 	mov	r2,r5
200251c0:	e1bfff15 	stw	r6,-4(fp)
200251c4:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200251c8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
200251cc:	e0bfff17 	ldw	r2,-4(fp)
200251d0:	1000021e 	bne	r2,zero,200251dc <OSQPend+0x34>
        return ((void *)0);
200251d4:	0005883a 	mov	r2,zero
200251d8:	00009106 	br	20025420 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
200251dc:	e0bffd17 	ldw	r2,-12(fp)
200251e0:	1000051e 	bne	r2,zero,200251f8 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
200251e4:	e0bfff17 	ldw	r2,-4(fp)
200251e8:	00c00104 	movi	r3,4
200251ec:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
200251f0:	0005883a 	mov	r2,zero
200251f4:	00008a06 	br	20025420 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
200251f8:	e0bffd17 	ldw	r2,-12(fp)
200251fc:	10800003 	ldbu	r2,0(r2)
20025200:	10803fcc 	andi	r2,r2,255
20025204:	108000a0 	cmpeqi	r2,r2,2
20025208:	1000051e 	bne	r2,zero,20025220 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
2002520c:	e0bfff17 	ldw	r2,-4(fp)
20025210:	00c00044 	movi	r3,1
20025214:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
20025218:	0005883a 	mov	r2,zero
2002521c:	00008006 	br	20025420 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
20025220:	d0a60403 	ldbu	r2,-26608(gp)
20025224:	10803fcc 	andi	r2,r2,255
20025228:	10000526 	beq	r2,zero,20025240 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
2002522c:	e0bfff17 	ldw	r2,-4(fp)
20025230:	00c00084 	movi	r3,2
20025234:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
20025238:	0005883a 	mov	r2,zero
2002523c:	00007806 	br	20025420 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
20025240:	d0a5f603 	ldbu	r2,-26664(gp)
20025244:	10803fcc 	andi	r2,r2,255
20025248:	10000526 	beq	r2,zero,20025260 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
2002524c:	e0bfff17 	ldw	r2,-4(fp)
20025250:	00c00344 	movi	r3,13
20025254:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
20025258:	0005883a 	mov	r2,zero
2002525c:	00007006 	br	20025420 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025260:	0005303a 	rdctl	r2,status
20025264:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025268:	e0fffc17 	ldw	r3,-16(fp)
2002526c:	00bfff84 	movi	r2,-2
20025270:	1884703a 	and	r2,r3,r2
20025274:	1001703a 	wrctl	status,r2
  
  return context;
20025278:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
2002527c:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
20025280:	e0bffd17 	ldw	r2,-12(fp)
20025284:	10800117 	ldw	r2,4(r2)
20025288:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
2002528c:	e0bff817 	ldw	r2,-32(fp)
20025290:	1080058b 	ldhu	r2,22(r2)
20025294:	10bfffcc 	andi	r2,r2,65535
20025298:	10001e26 	beq	r2,zero,20025314 <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
2002529c:	e0bff817 	ldw	r2,-32(fp)
200252a0:	10800417 	ldw	r2,16(r2)
200252a4:	11000104 	addi	r4,r2,4
200252a8:	e0fff817 	ldw	r3,-32(fp)
200252ac:	19000415 	stw	r4,16(r3)
200252b0:	10800017 	ldw	r2,0(r2)
200252b4:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
200252b8:	e0bff817 	ldw	r2,-32(fp)
200252bc:	1080058b 	ldhu	r2,22(r2)
200252c0:	10bfffc4 	addi	r2,r2,-1
200252c4:	1007883a 	mov	r3,r2
200252c8:	e0bff817 	ldw	r2,-32(fp)
200252cc:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
200252d0:	e0bff817 	ldw	r2,-32(fp)
200252d4:	10c00417 	ldw	r3,16(r2)
200252d8:	e0bff817 	ldw	r2,-32(fp)
200252dc:	10800217 	ldw	r2,8(r2)
200252e0:	1880041e 	bne	r3,r2,200252f4 <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
200252e4:	e0bff817 	ldw	r2,-32(fp)
200252e8:	10c00117 	ldw	r3,4(r2)
200252ec:	e0bff817 	ldw	r2,-32(fp)
200252f0:	10c00415 	stw	r3,16(r2)
200252f4:	e0bff617 	ldw	r2,-40(fp)
200252f8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200252fc:	e0bff717 	ldw	r2,-36(fp)
20025300:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
20025304:	e0bfff17 	ldw	r2,-4(fp)
20025308:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
2002530c:	e0bff517 	ldw	r2,-44(fp)
20025310:	00004306 	br	20025420 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
20025314:	d0a60517 	ldw	r2,-26604(gp)
20025318:	d0e60517 	ldw	r3,-26604(gp)
2002531c:	18c00c03 	ldbu	r3,48(r3)
20025320:	18c00114 	ori	r3,r3,4
20025324:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
20025328:	d0a60517 	ldw	r2,-26604(gp)
2002532c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
20025330:	d0a60517 	ldw	r2,-26604(gp)
20025334:	e0fffe0b 	ldhu	r3,-8(fp)
20025338:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
2002533c:	e13ffd17 	ldw	r4,-12(fp)
20025340:	0021c040 	call	20021c04 <OS_EventTaskWait>
20025344:	e0bff617 	ldw	r2,-40(fp)
20025348:	e0bffb15 	stw	r2,-20(fp)
2002534c:	e0bffb17 	ldw	r2,-20(fp)
20025350:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
20025354:	00224b80 	call	200224b8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025358:	0005303a 	rdctl	r2,status
2002535c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025360:	e0fff917 	ldw	r3,-28(fp)
20025364:	00bfff84 	movi	r2,-2
20025368:	1884703a 	and	r2,r3,r2
2002536c:	1001703a 	wrctl	status,r2
  
  return context;
20025370:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
20025374:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
20025378:	d0a60517 	ldw	r2,-26604(gp)
2002537c:	10800c43 	ldbu	r2,49(r2)
20025380:	10803fcc 	andi	r2,r2,255
20025384:	10000326 	beq	r2,zero,20025394 <OSQPend+0x1ec>
20025388:	108000a0 	cmpeqi	r2,r2,2
2002538c:	1000071e 	bne	r2,zero,200253ac <OSQPend+0x204>
20025390:	00000b06 	br	200253c0 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
20025394:	d0a60517 	ldw	r2,-26604(gp)
20025398:	10800917 	ldw	r2,36(r2)
2002539c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
200253a0:	e0bfff17 	ldw	r2,-4(fp)
200253a4:	10000005 	stb	zero,0(r2)
             break;
200253a8:	00000e06 	br	200253e4 <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
200253ac:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
200253b0:	e0bfff17 	ldw	r2,-4(fp)
200253b4:	00c00384 	movi	r3,14
200253b8:	10c00005 	stb	r3,0(r2)
             break;
200253bc:	00000906 	br	200253e4 <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
200253c0:	d0a60517 	ldw	r2,-26604(gp)
200253c4:	e17ffd17 	ldw	r5,-12(fp)
200253c8:	1009883a 	mov	r4,r2
200253cc:	0021e640 	call	20021e64 <OS_EventTaskRemove>
             pmsg = (void *)0;
200253d0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
200253d4:	e0bfff17 	ldw	r2,-4(fp)
200253d8:	00c00284 	movi	r3,10
200253dc:	10c00005 	stb	r3,0(r2)
             break;
200253e0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
200253e4:	d0a60517 	ldw	r2,-26604(gp)
200253e8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
200253ec:	d0a60517 	ldw	r2,-26604(gp)
200253f0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
200253f4:	d0a60517 	ldw	r2,-26604(gp)
200253f8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
200253fc:	d0a60517 	ldw	r2,-26604(gp)
20025400:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
20025404:	d0a60517 	ldw	r2,-26604(gp)
20025408:	10000915 	stw	zero,36(r2)
2002540c:	e0bff617 	ldw	r2,-40(fp)
20025410:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025414:	e0bffa17 	ldw	r2,-24(fp)
20025418:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
2002541c:	e0bff517 	ldw	r2,-44(fp)
}
20025420:	e037883a 	mov	sp,fp
20025424:	dfc00117 	ldw	ra,4(sp)
20025428:	df000017 	ldw	fp,0(sp)
2002542c:	dec00204 	addi	sp,sp,8
20025430:	f800283a 	ret

20025434 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
20025434:	defff604 	addi	sp,sp,-40
20025438:	dfc00915 	stw	ra,36(sp)
2002543c:	df000815 	stw	fp,32(sp)
20025440:	df000804 	addi	fp,sp,32
20025444:	e13ffd15 	stw	r4,-12(fp)
20025448:	2805883a 	mov	r2,r5
2002544c:	e1bfff15 	stw	r6,-4(fp)
20025450:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
20025454:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
20025458:	e0bfff17 	ldw	r2,-4(fp)
2002545c:	1000021e 	bne	r2,zero,20025468 <OSQPendAbort+0x34>
        return (0);
20025460:	0005883a 	mov	r2,zero
20025464:	00004906 	br	2002558c <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
20025468:	e0bffd17 	ldw	r2,-12(fp)
2002546c:	1000051e 	bne	r2,zero,20025484 <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
20025470:	e0bfff17 	ldw	r2,-4(fp)
20025474:	00c00104 	movi	r3,4
20025478:	10c00005 	stb	r3,0(r2)
        return (0);
2002547c:	0005883a 	mov	r2,zero
20025480:	00004206 	br	2002558c <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
20025484:	e0bffd17 	ldw	r2,-12(fp)
20025488:	10800003 	ldbu	r2,0(r2)
2002548c:	10803fcc 	andi	r2,r2,255
20025490:	108000a0 	cmpeqi	r2,r2,2
20025494:	1000051e 	bne	r2,zero,200254ac <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
20025498:	e0bfff17 	ldw	r2,-4(fp)
2002549c:	00c00044 	movi	r3,1
200254a0:	10c00005 	stb	r3,0(r2)
        return (0);
200254a4:	0005883a 	mov	r2,zero
200254a8:	00003806 	br	2002558c <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200254ac:	0005303a 	rdctl	r2,status
200254b0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200254b4:	e0fffc17 	ldw	r3,-16(fp)
200254b8:	00bfff84 	movi	r2,-2
200254bc:	1884703a 	and	r2,r3,r2
200254c0:	1001703a 	wrctl	status,r2
  
  return context;
200254c4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
200254c8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
200254cc:	e0bffd17 	ldw	r2,-12(fp)
200254d0:	10800283 	ldbu	r2,10(r2)
200254d4:	10803fcc 	andi	r2,r2,255
200254d8:	10002526 	beq	r2,zero,20025570 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
200254dc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
200254e0:	e0bffe03 	ldbu	r2,-8(fp)
200254e4:	10800060 	cmpeqi	r2,r2,1
200254e8:	10000e26 	beq	r2,zero,20025524 <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
200254ec:	00000806 	br	20025510 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
200254f0:	01c00084 	movi	r7,2
200254f4:	01800104 	movi	r6,4
200254f8:	000b883a 	mov	r5,zero
200254fc:	e13ffd17 	ldw	r4,-12(fp)
20025500:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
                     nbr_tasks++;
20025504:	e0bff803 	ldbu	r2,-32(fp)
20025508:	10800044 	addi	r2,r2,1
2002550c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
20025510:	e0bffd17 	ldw	r2,-12(fp)
20025514:	10800283 	ldbu	r2,10(r2)
20025518:	10803fcc 	andi	r2,r2,255
2002551c:	103ff41e 	bne	r2,zero,200254f0 <__alt_data_end+0xfffe54f0>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
20025520:	00000906 	br	20025548 <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
20025524:	01c00084 	movi	r7,2
20025528:	01800104 	movi	r6,4
2002552c:	000b883a 	mov	r5,zero
20025530:	e13ffd17 	ldw	r4,-12(fp)
20025534:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
                 nbr_tasks++;
20025538:	e0bff803 	ldbu	r2,-32(fp)
2002553c:	10800044 	addi	r2,r2,1
20025540:	e0bff805 	stb	r2,-32(fp)
                 break;
20025544:	0001883a 	nop
20025548:	e0bff917 	ldw	r2,-28(fp)
2002554c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025550:	e0bffa17 	ldw	r2,-24(fp)
20025554:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
20025558:	00224b80 	call	200224b8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
2002555c:	e0bfff17 	ldw	r2,-4(fp)
20025560:	00c00384 	movi	r3,14
20025564:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
20025568:	e0bff803 	ldbu	r2,-32(fp)
2002556c:	00000706 	br	2002558c <OSQPendAbort+0x158>
20025570:	e0bff917 	ldw	r2,-28(fp)
20025574:	e0bffb15 	stw	r2,-20(fp)
20025578:	e0bffb17 	ldw	r2,-20(fp)
2002557c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20025580:	e0bfff17 	ldw	r2,-4(fp)
20025584:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
20025588:	0005883a 	mov	r2,zero
}
2002558c:	e037883a 	mov	sp,fp
20025590:	dfc00117 	ldw	ra,4(sp)
20025594:	df000017 	ldw	fp,0(sp)
20025598:	dec00204 	addi	sp,sp,8
2002559c:	f800283a 	ret

200255a0 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
200255a0:	defff604 	addi	sp,sp,-40
200255a4:	dfc00915 	stw	ra,36(sp)
200255a8:	df000815 	stw	fp,32(sp)
200255ac:	df000804 	addi	fp,sp,32
200255b0:	e13ffe15 	stw	r4,-8(fp)
200255b4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
200255b8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
200255bc:	e0bffe17 	ldw	r2,-8(fp)
200255c0:	1000021e 	bne	r2,zero,200255cc <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
200255c4:	00800104 	movi	r2,4
200255c8:	00004a06 	br	200256f4 <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
200255cc:	e0bffe17 	ldw	r2,-8(fp)
200255d0:	10800003 	ldbu	r2,0(r2)
200255d4:	10803fcc 	andi	r2,r2,255
200255d8:	108000a0 	cmpeqi	r2,r2,2
200255dc:	1000021e 	bne	r2,zero,200255e8 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
200255e0:	00800044 	movi	r2,1
200255e4:	00004306 	br	200256f4 <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200255e8:	0005303a 	rdctl	r2,status
200255ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200255f0:	e0fffd17 	ldw	r3,-12(fp)
200255f4:	00bfff84 	movi	r2,-2
200255f8:	1884703a 	and	r2,r3,r2
200255fc:	1001703a 	wrctl	status,r2
  
  return context;
20025600:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
20025604:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
20025608:	e0bffe17 	ldw	r2,-8(fp)
2002560c:	10800283 	ldbu	r2,10(r2)
20025610:	10803fcc 	andi	r2,r2,255
20025614:	10000c26 	beq	r2,zero,20025648 <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
20025618:	000f883a 	mov	r7,zero
2002561c:	01800104 	movi	r6,4
20025620:	e17fff17 	ldw	r5,-4(fp)
20025624:	e13ffe17 	ldw	r4,-8(fp)
20025628:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
2002562c:	e0bff817 	ldw	r2,-32(fp)
20025630:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025634:	e0bff917 	ldw	r2,-28(fp)
20025638:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
2002563c:	00224b80 	call	200224b8 <OS_Sched>
        return (OS_ERR_NONE);
20025640:	0005883a 	mov	r2,zero
20025644:	00002b06 	br	200256f4 <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
20025648:	e0bffe17 	ldw	r2,-8(fp)
2002564c:	10800117 	ldw	r2,4(r2)
20025650:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
20025654:	e0bffb17 	ldw	r2,-20(fp)
20025658:	10c0058b 	ldhu	r3,22(r2)
2002565c:	e0bffb17 	ldw	r2,-20(fp)
20025660:	1080050b 	ldhu	r2,20(r2)
20025664:	18ffffcc 	andi	r3,r3,65535
20025668:	10bfffcc 	andi	r2,r2,65535
2002566c:	18800636 	bltu	r3,r2,20025688 <OSQPost+0xe8>
20025670:	e0bff817 	ldw	r2,-32(fp)
20025674:	e0bffa15 	stw	r2,-24(fp)
20025678:	e0bffa17 	ldw	r2,-24(fp)
2002567c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
20025680:	00800784 	movi	r2,30
20025684:	00001b06 	br	200256f4 <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
20025688:	e0bffb17 	ldw	r2,-20(fp)
2002568c:	10800317 	ldw	r2,12(r2)
20025690:	11000104 	addi	r4,r2,4
20025694:	e0fffb17 	ldw	r3,-20(fp)
20025698:	19000315 	stw	r4,12(r3)
2002569c:	e0ffff17 	ldw	r3,-4(fp)
200256a0:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
200256a4:	e0bffb17 	ldw	r2,-20(fp)
200256a8:	1080058b 	ldhu	r2,22(r2)
200256ac:	10800044 	addi	r2,r2,1
200256b0:	1007883a 	mov	r3,r2
200256b4:	e0bffb17 	ldw	r2,-20(fp)
200256b8:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
200256bc:	e0bffb17 	ldw	r2,-20(fp)
200256c0:	10c00317 	ldw	r3,12(r2)
200256c4:	e0bffb17 	ldw	r2,-20(fp)
200256c8:	10800217 	ldw	r2,8(r2)
200256cc:	1880041e 	bne	r3,r2,200256e0 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
200256d0:	e0bffb17 	ldw	r2,-20(fp)
200256d4:	10c00117 	ldw	r3,4(r2)
200256d8:	e0bffb17 	ldw	r2,-20(fp)
200256dc:	10c00315 	stw	r3,12(r2)
200256e0:	e0bff817 	ldw	r2,-32(fp)
200256e4:	e0bffc15 	stw	r2,-16(fp)
200256e8:	e0bffc17 	ldw	r2,-16(fp)
200256ec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
200256f0:	0005883a 	mov	r2,zero
}
200256f4:	e037883a 	mov	sp,fp
200256f8:	dfc00117 	ldw	ra,4(sp)
200256fc:	df000017 	ldw	fp,0(sp)
20025700:	dec00204 	addi	sp,sp,8
20025704:	f800283a 	ret

20025708 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
20025708:	defff604 	addi	sp,sp,-40
2002570c:	dfc00915 	stw	ra,36(sp)
20025710:	df000815 	stw	fp,32(sp)
20025714:	df000804 	addi	fp,sp,32
20025718:	e13ffe15 	stw	r4,-8(fp)
2002571c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20025720:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
20025724:	e0bffe17 	ldw	r2,-8(fp)
20025728:	1000021e 	bne	r2,zero,20025734 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
2002572c:	00800104 	movi	r2,4
20025730:	00004c06 	br	20025864 <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
20025734:	e0bffe17 	ldw	r2,-8(fp)
20025738:	10800003 	ldbu	r2,0(r2)
2002573c:	10803fcc 	andi	r2,r2,255
20025740:	108000a0 	cmpeqi	r2,r2,2
20025744:	1000021e 	bne	r2,zero,20025750 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
20025748:	00800044 	movi	r2,1
2002574c:	00004506 	br	20025864 <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025750:	0005303a 	rdctl	r2,status
20025754:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025758:	e0fffd17 	ldw	r3,-12(fp)
2002575c:	00bfff84 	movi	r2,-2
20025760:	1884703a 	and	r2,r3,r2
20025764:	1001703a 	wrctl	status,r2
  
  return context;
20025768:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
2002576c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
20025770:	e0bffe17 	ldw	r2,-8(fp)
20025774:	10800283 	ldbu	r2,10(r2)
20025778:	10803fcc 	andi	r2,r2,255
2002577c:	10000c26 	beq	r2,zero,200257b0 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
20025780:	000f883a 	mov	r7,zero
20025784:	01800104 	movi	r6,4
20025788:	e17fff17 	ldw	r5,-4(fp)
2002578c:	e13ffe17 	ldw	r4,-8(fp)
20025790:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
20025794:	e0bff817 	ldw	r2,-32(fp)
20025798:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002579c:	e0bff917 	ldw	r2,-28(fp)
200257a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
200257a4:	00224b80 	call	200224b8 <OS_Sched>
        return (OS_ERR_NONE);
200257a8:	0005883a 	mov	r2,zero
200257ac:	00002d06 	br	20025864 <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
200257b0:	e0bffe17 	ldw	r2,-8(fp)
200257b4:	10800117 	ldw	r2,4(r2)
200257b8:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
200257bc:	e0bffb17 	ldw	r2,-20(fp)
200257c0:	10c0058b 	ldhu	r3,22(r2)
200257c4:	e0bffb17 	ldw	r2,-20(fp)
200257c8:	1080050b 	ldhu	r2,20(r2)
200257cc:	18ffffcc 	andi	r3,r3,65535
200257d0:	10bfffcc 	andi	r2,r2,65535
200257d4:	18800636 	bltu	r3,r2,200257f0 <OSQPostFront+0xe8>
200257d8:	e0bff817 	ldw	r2,-32(fp)
200257dc:	e0bffa15 	stw	r2,-24(fp)
200257e0:	e0bffa17 	ldw	r2,-24(fp)
200257e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
200257e8:	00800784 	movi	r2,30
200257ec:	00001d06 	br	20025864 <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
200257f0:	e0bffb17 	ldw	r2,-20(fp)
200257f4:	10c00417 	ldw	r3,16(r2)
200257f8:	e0bffb17 	ldw	r2,-20(fp)
200257fc:	10800117 	ldw	r2,4(r2)
20025800:	1880041e 	bne	r3,r2,20025814 <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
20025804:	e0bffb17 	ldw	r2,-20(fp)
20025808:	10c00217 	ldw	r3,8(r2)
2002580c:	e0bffb17 	ldw	r2,-20(fp)
20025810:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
20025814:	e0bffb17 	ldw	r2,-20(fp)
20025818:	10800417 	ldw	r2,16(r2)
2002581c:	10ffff04 	addi	r3,r2,-4
20025820:	e0bffb17 	ldw	r2,-20(fp)
20025824:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
20025828:	e0bffb17 	ldw	r2,-20(fp)
2002582c:	10800417 	ldw	r2,16(r2)
20025830:	e0ffff17 	ldw	r3,-4(fp)
20025834:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
20025838:	e0bffb17 	ldw	r2,-20(fp)
2002583c:	1080058b 	ldhu	r2,22(r2)
20025840:	10800044 	addi	r2,r2,1
20025844:	1007883a 	mov	r3,r2
20025848:	e0bffb17 	ldw	r2,-20(fp)
2002584c:	10c0058d 	sth	r3,22(r2)
20025850:	e0bff817 	ldw	r2,-32(fp)
20025854:	e0bffc15 	stw	r2,-16(fp)
20025858:	e0bffc17 	ldw	r2,-16(fp)
2002585c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
20025860:	0005883a 	mov	r2,zero
}
20025864:	e037883a 	mov	sp,fp
20025868:	dfc00117 	ldw	ra,4(sp)
2002586c:	df000017 	ldw	fp,0(sp)
20025870:	dec00204 	addi	sp,sp,8
20025874:	f800283a 	ret

20025878 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
20025878:	defff504 	addi	sp,sp,-44
2002587c:	dfc00a15 	stw	ra,40(sp)
20025880:	df000915 	stw	fp,36(sp)
20025884:	df000904 	addi	fp,sp,36
20025888:	e13ffd15 	stw	r4,-12(fp)
2002588c:	e17ffe15 	stw	r5,-8(fp)
20025890:	3005883a 	mov	r2,r6
20025894:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20025898:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2002589c:	e0bffd17 	ldw	r2,-12(fp)
200258a0:	1000021e 	bne	r2,zero,200258ac <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
200258a4:	00800104 	movi	r2,4
200258a8:	00007106 	br	20025a70 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
200258ac:	e0bffd17 	ldw	r2,-12(fp)
200258b0:	10800003 	ldbu	r2,0(r2)
200258b4:	10803fcc 	andi	r2,r2,255
200258b8:	108000a0 	cmpeqi	r2,r2,2
200258bc:	1000021e 	bne	r2,zero,200258c8 <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
200258c0:	00800044 	movi	r2,1
200258c4:	00006a06 	br	20025a70 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200258c8:	0005303a 	rdctl	r2,status
200258cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200258d0:	e0fffc17 	ldw	r3,-16(fp)
200258d4:	00bfff84 	movi	r2,-2
200258d8:	1884703a 	and	r2,r3,r2
200258dc:	1001703a 	wrctl	status,r2
  
  return context;
200258e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
200258e4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
200258e8:	e0bffd17 	ldw	r2,-12(fp)
200258ec:	10800283 	ldbu	r2,10(r2)
200258f0:	10803fcc 	andi	r2,r2,255
200258f4:	10001d26 	beq	r2,zero,2002596c <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
200258f8:	e0bfff03 	ldbu	r2,-4(fp)
200258fc:	1080004c 	andi	r2,r2,1
20025900:	10000b26 	beq	r2,zero,20025930 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
20025904:	00000506 	br	2002591c <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
20025908:	000f883a 	mov	r7,zero
2002590c:	01800104 	movi	r6,4
20025910:	e17ffe17 	ldw	r5,-8(fp)
20025914:	e13ffd17 	ldw	r4,-12(fp)
20025918:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
2002591c:	e0bffd17 	ldw	r2,-12(fp)
20025920:	10800283 	ldbu	r2,10(r2)
20025924:	10803fcc 	andi	r2,r2,255
20025928:	103ff71e 	bne	r2,zero,20025908 <__alt_data_end+0xfffe5908>
2002592c:	00000506 	br	20025944 <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
20025930:	000f883a 	mov	r7,zero
20025934:	01800104 	movi	r6,4
20025938:	e17ffe17 	ldw	r5,-8(fp)
2002593c:	e13ffd17 	ldw	r4,-12(fp)
20025940:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
20025944:	e0bff717 	ldw	r2,-36(fp)
20025948:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002594c:	e0bff817 	ldw	r2,-32(fp)
20025950:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
20025954:	e0bfff03 	ldbu	r2,-4(fp)
20025958:	1080010c 	andi	r2,r2,4
2002595c:	1000011e 	bne	r2,zero,20025964 <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
20025960:	00224b80 	call	200224b8 <OS_Sched>
        }
        return (OS_ERR_NONE);
20025964:	0005883a 	mov	r2,zero
20025968:	00004106 	br	20025a70 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
2002596c:	e0bffd17 	ldw	r2,-12(fp)
20025970:	10800117 	ldw	r2,4(r2)
20025974:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
20025978:	e0bffa17 	ldw	r2,-24(fp)
2002597c:	10c0058b 	ldhu	r3,22(r2)
20025980:	e0bffa17 	ldw	r2,-24(fp)
20025984:	1080050b 	ldhu	r2,20(r2)
20025988:	18ffffcc 	andi	r3,r3,65535
2002598c:	10bfffcc 	andi	r2,r2,65535
20025990:	18800636 	bltu	r3,r2,200259ac <OSQPostOpt+0x134>
20025994:	e0bff717 	ldw	r2,-36(fp)
20025998:	e0bff915 	stw	r2,-28(fp)
2002599c:	e0bff917 	ldw	r2,-28(fp)
200259a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
200259a4:	00800784 	movi	r2,30
200259a8:	00003106 	br	20025a70 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
200259ac:	e0bfff03 	ldbu	r2,-4(fp)
200259b0:	1080008c 	andi	r2,r2,2
200259b4:	10001326 	beq	r2,zero,20025a04 <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
200259b8:	e0bffa17 	ldw	r2,-24(fp)
200259bc:	10c00417 	ldw	r3,16(r2)
200259c0:	e0bffa17 	ldw	r2,-24(fp)
200259c4:	10800117 	ldw	r2,4(r2)
200259c8:	1880041e 	bne	r3,r2,200259dc <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
200259cc:	e0bffa17 	ldw	r2,-24(fp)
200259d0:	10c00217 	ldw	r3,8(r2)
200259d4:	e0bffa17 	ldw	r2,-24(fp)
200259d8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
200259dc:	e0bffa17 	ldw	r2,-24(fp)
200259e0:	10800417 	ldw	r2,16(r2)
200259e4:	10ffff04 	addi	r3,r2,-4
200259e8:	e0bffa17 	ldw	r2,-24(fp)
200259ec:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
200259f0:	e0bffa17 	ldw	r2,-24(fp)
200259f4:	10800417 	ldw	r2,16(r2)
200259f8:	e0fffe17 	ldw	r3,-8(fp)
200259fc:	10c00015 	stw	r3,0(r2)
20025a00:	00001006 	br	20025a44 <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
20025a04:	e0bffa17 	ldw	r2,-24(fp)
20025a08:	10800317 	ldw	r2,12(r2)
20025a0c:	11000104 	addi	r4,r2,4
20025a10:	e0fffa17 	ldw	r3,-24(fp)
20025a14:	19000315 	stw	r4,12(r3)
20025a18:	e0fffe17 	ldw	r3,-8(fp)
20025a1c:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
20025a20:	e0bffa17 	ldw	r2,-24(fp)
20025a24:	10c00317 	ldw	r3,12(r2)
20025a28:	e0bffa17 	ldw	r2,-24(fp)
20025a2c:	10800217 	ldw	r2,8(r2)
20025a30:	1880041e 	bne	r3,r2,20025a44 <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
20025a34:	e0bffa17 	ldw	r2,-24(fp)
20025a38:	10c00117 	ldw	r3,4(r2)
20025a3c:	e0bffa17 	ldw	r2,-24(fp)
20025a40:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
20025a44:	e0bffa17 	ldw	r2,-24(fp)
20025a48:	1080058b 	ldhu	r2,22(r2)
20025a4c:	10800044 	addi	r2,r2,1
20025a50:	1007883a 	mov	r3,r2
20025a54:	e0bffa17 	ldw	r2,-24(fp)
20025a58:	10c0058d 	sth	r3,22(r2)
20025a5c:	e0bff717 	ldw	r2,-36(fp)
20025a60:	e0bffb15 	stw	r2,-20(fp)
20025a64:	e0bffb17 	ldw	r2,-20(fp)
20025a68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
20025a6c:	0005883a 	mov	r2,zero
}
20025a70:	e037883a 	mov	sp,fp
20025a74:	dfc00117 	ldw	ra,4(sp)
20025a78:	df000017 	ldw	fp,0(sp)
20025a7c:	dec00204 	addi	sp,sp,8
20025a80:	f800283a 	ret

20025a84 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
20025a84:	defff604 	addi	sp,sp,-40
20025a88:	df000915 	stw	fp,36(sp)
20025a8c:	df000904 	addi	fp,sp,36
20025a90:	e13ffe15 	stw	r4,-8(fp)
20025a94:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
20025a98:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
20025a9c:	e0bffe17 	ldw	r2,-8(fp)
20025aa0:	1000021e 	bne	r2,zero,20025aac <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
20025aa4:	00800104 	movi	r2,4
20025aa8:	00004906 	br	20025bd0 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
20025aac:	e0bfff17 	ldw	r2,-4(fp)
20025ab0:	1000021e 	bne	r2,zero,20025abc <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
20025ab4:	00800244 	movi	r2,9
20025ab8:	00004506 	br	20025bd0 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
20025abc:	e0bffe17 	ldw	r2,-8(fp)
20025ac0:	10800003 	ldbu	r2,0(r2)
20025ac4:	10803fcc 	andi	r2,r2,255
20025ac8:	108000a0 	cmpeqi	r2,r2,2
20025acc:	1000021e 	bne	r2,zero,20025ad8 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
20025ad0:	00800044 	movi	r2,1
20025ad4:	00003e06 	br	20025bd0 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025ad8:	0005303a 	rdctl	r2,status
20025adc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025ae0:	e0fffd17 	ldw	r3,-12(fp)
20025ae4:	00bfff84 	movi	r2,-2
20025ae8:	1884703a 	and	r2,r3,r2
20025aec:	1001703a 	wrctl	status,r2
  
  return context;
20025af0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
20025af4:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
20025af8:	e0bffe17 	ldw	r2,-8(fp)
20025afc:	10c00283 	ldbu	r3,10(r2)
20025b00:	e0bfff17 	ldw	r2,-4(fp)
20025b04:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
20025b08:	e0bffe17 	ldw	r2,-8(fp)
20025b0c:	108002c4 	addi	r2,r2,11
20025b10:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
20025b14:	e0bfff17 	ldw	r2,-4(fp)
20025b18:	10800204 	addi	r2,r2,8
20025b1c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
20025b20:	e03ff705 	stb	zero,-36(fp)
20025b24:	00000b06 	br	20025b54 <OSQQuery+0xd0>
        *pdest++ = *psrc++;
20025b28:	e0bff917 	ldw	r2,-28(fp)
20025b2c:	10c00044 	addi	r3,r2,1
20025b30:	e0fff915 	stw	r3,-28(fp)
20025b34:	e0fff817 	ldw	r3,-32(fp)
20025b38:	19000044 	addi	r4,r3,1
20025b3c:	e13ff815 	stw	r4,-32(fp)
20025b40:	18c00003 	ldbu	r3,0(r3)
20025b44:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
20025b48:	e0bff703 	ldbu	r2,-36(fp)
20025b4c:	10800044 	addi	r2,r2,1
20025b50:	e0bff705 	stb	r2,-36(fp)
20025b54:	e0bff703 	ldbu	r2,-36(fp)
20025b58:	108000f0 	cmpltui	r2,r2,3
20025b5c:	103ff21e 	bne	r2,zero,20025b28 <__alt_data_end+0xfffe5b28>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
20025b60:	e0bffe17 	ldw	r2,-8(fp)
20025b64:	10800117 	ldw	r2,4(r2)
20025b68:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
20025b6c:	e0bffc17 	ldw	r2,-16(fp)
20025b70:	1080058b 	ldhu	r2,22(r2)
20025b74:	10bfffcc 	andi	r2,r2,65535
20025b78:	10000626 	beq	r2,zero,20025b94 <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
20025b7c:	e0bffc17 	ldw	r2,-16(fp)
20025b80:	10800417 	ldw	r2,16(r2)
20025b84:	10c00017 	ldw	r3,0(r2)
20025b88:	e0bfff17 	ldw	r2,-4(fp)
20025b8c:	10c00015 	stw	r3,0(r2)
20025b90:	00000206 	br	20025b9c <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
20025b94:	e0bfff17 	ldw	r2,-4(fp)
20025b98:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
20025b9c:	e0bffc17 	ldw	r2,-16(fp)
20025ba0:	10c0058b 	ldhu	r3,22(r2)
20025ba4:	e0bfff17 	ldw	r2,-4(fp)
20025ba8:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
20025bac:	e0bffc17 	ldw	r2,-16(fp)
20025bb0:	10c0050b 	ldhu	r3,20(r2)
20025bb4:	e0bfff17 	ldw	r2,-4(fp)
20025bb8:	10c0018d 	sth	r3,6(r2)
20025bbc:	e0bffa17 	ldw	r2,-24(fp)
20025bc0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025bc4:	e0bffb17 	ldw	r2,-20(fp)
20025bc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
20025bcc:	0005883a 	mov	r2,zero
}
20025bd0:	e037883a 	mov	sp,fp
20025bd4:	df000017 	ldw	fp,0(sp)
20025bd8:	dec00104 	addi	sp,sp,4
20025bdc:	f800283a 	ret

20025be0 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
20025be0:	defffb04 	addi	sp,sp,-20
20025be4:	dfc00415 	stw	ra,16(sp)
20025be8:	df000315 	stw	fp,12(sp)
20025bec:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
20025bf0:	01407804 	movi	r5,480
20025bf4:	010800f4 	movhi	r4,8195
20025bf8:	21002904 	addi	r4,r4,164
20025bfc:	00223fc0 	call	200223fc <OS_MemClr>
    pq1 = &OSQTbl[0];
20025c00:	008800f4 	movhi	r2,8195
20025c04:	10802904 	addi	r2,r2,164
20025c08:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
20025c0c:	008800f4 	movhi	r2,8195
20025c10:	10802f04 	addi	r2,r2,188
20025c14:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
20025c18:	e03ffd0d 	sth	zero,-12(fp)
20025c1c:	00000c06 	br	20025c50 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
20025c20:	e0bffe17 	ldw	r2,-8(fp)
20025c24:	e0ffff17 	ldw	r3,-4(fp)
20025c28:	10c00015 	stw	r3,0(r2)
        pq1++;
20025c2c:	e0bffe17 	ldw	r2,-8(fp)
20025c30:	10800604 	addi	r2,r2,24
20025c34:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
20025c38:	e0bfff17 	ldw	r2,-4(fp)
20025c3c:	10800604 	addi	r2,r2,24
20025c40:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
20025c44:	e0bffd0b 	ldhu	r2,-12(fp)
20025c48:	10800044 	addi	r2,r2,1
20025c4c:	e0bffd0d 	sth	r2,-12(fp)
20025c50:	e0bffd0b 	ldhu	r2,-12(fp)
20025c54:	108004f0 	cmpltui	r2,r2,19
20025c58:	103ff11e 	bne	r2,zero,20025c20 <__alt_data_end+0xfffe5c20>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
20025c5c:	e0bffe17 	ldw	r2,-8(fp)
20025c60:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
20025c64:	008800f4 	movhi	r2,8195
20025c68:	10802904 	addi	r2,r2,164
20025c6c:	d0a60115 	stw	r2,-26620(gp)
#endif
}
20025c70:	0001883a 	nop
20025c74:	e037883a 	mov	sp,fp
20025c78:	dfc00117 	ldw	ra,4(sp)
20025c7c:	df000017 	ldw	fp,0(sp)
20025c80:	dec00204 	addi	sp,sp,8
20025c84:	f800283a 	ret

20025c88 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
20025c88:	defffa04 	addi	sp,sp,-24
20025c8c:	df000515 	stw	fp,20(sp)
20025c90:	df000504 	addi	fp,sp,20
20025c94:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20025c98:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
20025c9c:	e0bfff17 	ldw	r2,-4(fp)
20025ca0:	1000021e 	bne	r2,zero,20025cac <OSSemAccept+0x24>
        return (0);
20025ca4:	0005883a 	mov	r2,zero
20025ca8:	00001f06 	br	20025d28 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
20025cac:	e0bfff17 	ldw	r2,-4(fp)
20025cb0:	10800003 	ldbu	r2,0(r2)
20025cb4:	10803fcc 	andi	r2,r2,255
20025cb8:	108000e0 	cmpeqi	r2,r2,3
20025cbc:	1000021e 	bne	r2,zero,20025cc8 <OSSemAccept+0x40>
        return (0);
20025cc0:	0005883a 	mov	r2,zero
20025cc4:	00001806 	br	20025d28 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025cc8:	0005303a 	rdctl	r2,status
20025ccc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025cd0:	e0fffe17 	ldw	r3,-8(fp)
20025cd4:	00bfff84 	movi	r2,-2
20025cd8:	1884703a 	and	r2,r3,r2
20025cdc:	1001703a 	wrctl	status,r2
  
  return context;
20025ce0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
20025ce4:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
20025ce8:	e0bfff17 	ldw	r2,-4(fp)
20025cec:	1080020b 	ldhu	r2,8(r2)
20025cf0:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
20025cf4:	e0bffd0b 	ldhu	r2,-12(fp)
20025cf8:	10000626 	beq	r2,zero,20025d14 <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
20025cfc:	e0bfff17 	ldw	r2,-4(fp)
20025d00:	1080020b 	ldhu	r2,8(r2)
20025d04:	10bfffc4 	addi	r2,r2,-1
20025d08:	1007883a 	mov	r3,r2
20025d0c:	e0bfff17 	ldw	r2,-4(fp)
20025d10:	10c0020d 	sth	r3,8(r2)
20025d14:	e0bffb17 	ldw	r2,-20(fp)
20025d18:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025d1c:	e0bffc17 	ldw	r2,-16(fp)
20025d20:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
20025d24:	e0bffd0b 	ldhu	r2,-12(fp)
}
20025d28:	e037883a 	mov	sp,fp
20025d2c:	df000017 	ldw	fp,0(sp)
20025d30:	dec00104 	addi	sp,sp,4
20025d34:	f800283a 	ret

20025d38 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
20025d38:	defff904 	addi	sp,sp,-28
20025d3c:	dfc00615 	stw	ra,24(sp)
20025d40:	df000515 	stw	fp,20(sp)
20025d44:	df000504 	addi	fp,sp,20
20025d48:	2005883a 	mov	r2,r4
20025d4c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
20025d50:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
20025d54:	d0a60403 	ldbu	r2,-26608(gp)
20025d58:	10803fcc 	andi	r2,r2,255
20025d5c:	10000226 	beq	r2,zero,20025d68 <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
20025d60:	0005883a 	mov	r2,zero
20025d64:	00002506 	br	20025dfc <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025d68:	0005303a 	rdctl	r2,status
20025d6c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025d70:	e0fffe17 	ldw	r3,-8(fp)
20025d74:	00bfff84 	movi	r2,-2
20025d78:	1884703a 	and	r2,r3,r2
20025d7c:	1001703a 	wrctl	status,r2
  
  return context;
20025d80:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
20025d84:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
20025d88:	d0a60317 	ldw	r2,-26612(gp)
20025d8c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
20025d90:	d0a60317 	ldw	r2,-26612(gp)
20025d94:	10000326 	beq	r2,zero,20025da4 <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
20025d98:	d0a60317 	ldw	r2,-26612(gp)
20025d9c:	10800117 	ldw	r2,4(r2)
20025da0:	d0a60315 	stw	r2,-26612(gp)
20025da4:	e0bffb17 	ldw	r2,-20(fp)
20025da8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025dac:	e0bffc17 	ldw	r2,-16(fp)
20025db0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
20025db4:	e0bffd17 	ldw	r2,-12(fp)
20025db8:	10000f26 	beq	r2,zero,20025df8 <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
20025dbc:	e0bffd17 	ldw	r2,-12(fp)
20025dc0:	00c000c4 	movi	r3,3
20025dc4:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
20025dc8:	e0bffd17 	ldw	r2,-12(fp)
20025dcc:	e0ffff0b 	ldhu	r3,-4(fp)
20025dd0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
20025dd4:	e0bffd17 	ldw	r2,-12(fp)
20025dd8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
20025ddc:	e0bffd17 	ldw	r2,-12(fp)
20025de0:	00c00fc4 	movi	r3,63
20025de4:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
20025de8:	e0bffd17 	ldw	r2,-12(fp)
20025dec:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
20025df0:	e13ffd17 	ldw	r4,-12(fp)
20025df4:	002201c0 	call	2002201c <OS_EventWaitListInit>
    }
    return (pevent);
20025df8:	e0bffd17 	ldw	r2,-12(fp)
}
20025dfc:	e037883a 	mov	sp,fp
20025e00:	dfc00117 	ldw	ra,4(sp)
20025e04:	df000017 	ldw	fp,0(sp)
20025e08:	dec00204 	addi	sp,sp,8
20025e0c:	f800283a 	ret

20025e10 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
20025e10:	defff304 	addi	sp,sp,-52
20025e14:	dfc00c15 	stw	ra,48(sp)
20025e18:	df000b15 	stw	fp,44(sp)
20025e1c:	df000b04 	addi	fp,sp,44
20025e20:	e13ffd15 	stw	r4,-12(fp)
20025e24:	2805883a 	mov	r2,r5
20025e28:	e1bfff15 	stw	r6,-4(fp)
20025e2c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
20025e30:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
20025e34:	e0bfff17 	ldw	r2,-4(fp)
20025e38:	1000021e 	bne	r2,zero,20025e44 <OSSemDel+0x34>
        return (pevent);
20025e3c:	e0bffd17 	ldw	r2,-12(fp)
20025e40:	00007e06 	br	2002603c <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
20025e44:	e0bffd17 	ldw	r2,-12(fp)
20025e48:	1000051e 	bne	r2,zero,20025e60 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
20025e4c:	e0bfff17 	ldw	r2,-4(fp)
20025e50:	00c00104 	movi	r3,4
20025e54:	10c00005 	stb	r3,0(r2)
        return (pevent);
20025e58:	e0bffd17 	ldw	r2,-12(fp)
20025e5c:	00007706 	br	2002603c <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
20025e60:	e0bffd17 	ldw	r2,-12(fp)
20025e64:	10800003 	ldbu	r2,0(r2)
20025e68:	10803fcc 	andi	r2,r2,255
20025e6c:	108000e0 	cmpeqi	r2,r2,3
20025e70:	1000051e 	bne	r2,zero,20025e88 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
20025e74:	e0bfff17 	ldw	r2,-4(fp)
20025e78:	00c00044 	movi	r3,1
20025e7c:	10c00005 	stb	r3,0(r2)
        return (pevent);
20025e80:	e0bffd17 	ldw	r2,-12(fp)
20025e84:	00006d06 	br	2002603c <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
20025e88:	d0a60403 	ldbu	r2,-26608(gp)
20025e8c:	10803fcc 	andi	r2,r2,255
20025e90:	10000526 	beq	r2,zero,20025ea8 <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
20025e94:	e0bfff17 	ldw	r2,-4(fp)
20025e98:	00c003c4 	movi	r3,15
20025e9c:	10c00005 	stb	r3,0(r2)
        return (pevent);
20025ea0:	e0bffd17 	ldw	r2,-12(fp)
20025ea4:	00006506 	br	2002603c <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20025ea8:	0005303a 	rdctl	r2,status
20025eac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20025eb0:	e0fffc17 	ldw	r3,-16(fp)
20025eb4:	00bfff84 	movi	r2,-2
20025eb8:	1884703a 	and	r2,r3,r2
20025ebc:	1001703a 	wrctl	status,r2
  
  return context;
20025ec0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
20025ec4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
20025ec8:	e0bffd17 	ldw	r2,-12(fp)
20025ecc:	10800283 	ldbu	r2,10(r2)
20025ed0:	10803fcc 	andi	r2,r2,255
20025ed4:	10000326 	beq	r2,zero,20025ee4 <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
20025ed8:	00800044 	movi	r2,1
20025edc:	e0bff505 	stb	r2,-44(fp)
20025ee0:	00000106 	br	20025ee8 <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
20025ee4:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
20025ee8:	e0bffe03 	ldbu	r2,-8(fp)
20025eec:	10000326 	beq	r2,zero,20025efc <OSSemDel+0xec>
20025ef0:	10800060 	cmpeqi	r2,r2,1
20025ef4:	1000281e 	bne	r2,zero,20025f98 <OSSemDel+0x188>
20025ef8:	00004506 	br	20026010 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
20025efc:	e0bff503 	ldbu	r2,-44(fp)
20025f00:	1000161e 	bne	r2,zero,20025f5c <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
20025f04:	e0bffd17 	ldw	r2,-12(fp)
20025f08:	00c00fc4 	movi	r3,63
20025f0c:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
20025f10:	e0bffd17 	ldw	r2,-12(fp)
20025f14:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
20025f18:	e0bffd17 	ldw	r2,-12(fp)
20025f1c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
20025f20:	d0e60317 	ldw	r3,-26612(gp)
20025f24:	e0bffd17 	ldw	r2,-12(fp)
20025f28:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
20025f2c:	e0bffd17 	ldw	r2,-12(fp)
20025f30:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
20025f34:	e0bffd17 	ldw	r2,-12(fp)
20025f38:	d0a60315 	stw	r2,-26612(gp)
20025f3c:	e0bff717 	ldw	r2,-36(fp)
20025f40:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20025f44:	e0bff817 	ldw	r2,-32(fp)
20025f48:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
20025f4c:	e0bfff17 	ldw	r2,-4(fp)
20025f50:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
20025f54:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
20025f58:	00003706 	br	20026038 <OSSemDel+0x228>
20025f5c:	e0bff717 	ldw	r2,-36(fp)
20025f60:	e0bff915 	stw	r2,-28(fp)
20025f64:	e0bff917 	ldw	r2,-28(fp)
20025f68:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
20025f6c:	e0bfff17 	ldw	r2,-4(fp)
20025f70:	00c01244 	movi	r3,73
20025f74:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
20025f78:	e0bffd17 	ldw	r2,-12(fp)
20025f7c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
20025f80:	00002d06 	br	20026038 <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
20025f84:	000f883a 	mov	r7,zero
20025f88:	01800044 	movi	r6,1
20025f8c:	000b883a 	mov	r5,zero
20025f90:	e13ffd17 	ldw	r4,-12(fp)
20025f94:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
20025f98:	e0bffd17 	ldw	r2,-12(fp)
20025f9c:	10800283 	ldbu	r2,10(r2)
20025fa0:	10803fcc 	andi	r2,r2,255
20025fa4:	103ff71e 	bne	r2,zero,20025f84 <__alt_data_end+0xfffe5f84>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
20025fa8:	e0bffd17 	ldw	r2,-12(fp)
20025fac:	00c00fc4 	movi	r3,63
20025fb0:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
20025fb4:	e0bffd17 	ldw	r2,-12(fp)
20025fb8:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
20025fbc:	e0bffd17 	ldw	r2,-12(fp)
20025fc0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
20025fc4:	d0e60317 	ldw	r3,-26612(gp)
20025fc8:	e0bffd17 	ldw	r2,-12(fp)
20025fcc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
20025fd0:	e0bffd17 	ldw	r2,-12(fp)
20025fd4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
20025fd8:	e0bffd17 	ldw	r2,-12(fp)
20025fdc:	d0a60315 	stw	r2,-26612(gp)
20025fe0:	e0bff717 	ldw	r2,-36(fp)
20025fe4:	e0bffa15 	stw	r2,-24(fp)
20025fe8:	e0bffa17 	ldw	r2,-24(fp)
20025fec:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
20025ff0:	e0bff503 	ldbu	r2,-44(fp)
20025ff4:	10800058 	cmpnei	r2,r2,1
20025ff8:	1000011e 	bne	r2,zero,20026000 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
20025ffc:	00224b80 	call	200224b8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
20026000:	e0bfff17 	ldw	r2,-4(fp)
20026004:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
20026008:	e03ff615 	stw	zero,-40(fp)
             break;
2002600c:	00000a06 	br	20026038 <OSSemDel+0x228>
20026010:	e0bff717 	ldw	r2,-36(fp)
20026014:	e0bffb15 	stw	r2,-20(fp)
20026018:	e0bffb17 	ldw	r2,-20(fp)
2002601c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
20026020:	e0bfff17 	ldw	r2,-4(fp)
20026024:	00c001c4 	movi	r3,7
20026028:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
2002602c:	e0bffd17 	ldw	r2,-12(fp)
20026030:	e0bff615 	stw	r2,-40(fp)
             break;
20026034:	0001883a 	nop
    }
    return (pevent_return);
20026038:	e0bff617 	ldw	r2,-40(fp)
}
2002603c:	e037883a 	mov	sp,fp
20026040:	dfc00117 	ldw	ra,4(sp)
20026044:	df000017 	ldw	fp,0(sp)
20026048:	dec00204 	addi	sp,sp,8
2002604c:	f800283a 	ret

20026050 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
20026050:	defff504 	addi	sp,sp,-44
20026054:	dfc00a15 	stw	ra,40(sp)
20026058:	df000915 	stw	fp,36(sp)
2002605c:	df000904 	addi	fp,sp,36
20026060:	e13ffd15 	stw	r4,-12(fp)
20026064:	2805883a 	mov	r2,r5
20026068:	e1bfff15 	stw	r6,-4(fp)
2002606c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20026070:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
20026074:	e0bfff17 	ldw	r2,-4(fp)
20026078:	10007226 	beq	r2,zero,20026244 <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2002607c:	e0bffd17 	ldw	r2,-12(fp)
20026080:	1000041e 	bne	r2,zero,20026094 <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
20026084:	e0bfff17 	ldw	r2,-4(fp)
20026088:	00c00104 	movi	r3,4
2002608c:	10c00005 	stb	r3,0(r2)
        return;
20026090:	00006d06 	br	20026248 <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
20026094:	e0bffd17 	ldw	r2,-12(fp)
20026098:	10800003 	ldbu	r2,0(r2)
2002609c:	10803fcc 	andi	r2,r2,255
200260a0:	108000e0 	cmpeqi	r2,r2,3
200260a4:	1000041e 	bne	r2,zero,200260b8 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
200260a8:	e0bfff17 	ldw	r2,-4(fp)
200260ac:	00c00044 	movi	r3,1
200260b0:	10c00005 	stb	r3,0(r2)
        return;
200260b4:	00006406 	br	20026248 <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
200260b8:	d0a60403 	ldbu	r2,-26608(gp)
200260bc:	10803fcc 	andi	r2,r2,255
200260c0:	10000426 	beq	r2,zero,200260d4 <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
200260c4:	e0bfff17 	ldw	r2,-4(fp)
200260c8:	00c00084 	movi	r3,2
200260cc:	10c00005 	stb	r3,0(r2)
        return;
200260d0:	00005d06 	br	20026248 <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
200260d4:	d0a5f603 	ldbu	r2,-26664(gp)
200260d8:	10803fcc 	andi	r2,r2,255
200260dc:	10000426 	beq	r2,zero,200260f0 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
200260e0:	e0bfff17 	ldw	r2,-4(fp)
200260e4:	00c00344 	movi	r3,13
200260e8:	10c00005 	stb	r3,0(r2)
        return;
200260ec:	00005606 	br	20026248 <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200260f0:	0005303a 	rdctl	r2,status
200260f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200260f8:	e0fffc17 	ldw	r3,-16(fp)
200260fc:	00bfff84 	movi	r2,-2
20026100:	1884703a 	and	r2,r3,r2
20026104:	1001703a 	wrctl	status,r2
  
  return context;
20026108:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
2002610c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
20026110:	e0bffd17 	ldw	r2,-12(fp)
20026114:	1080020b 	ldhu	r2,8(r2)
20026118:	10bfffcc 	andi	r2,r2,65535
2002611c:	10000d26 	beq	r2,zero,20026154 <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
20026120:	e0bffd17 	ldw	r2,-12(fp)
20026124:	1080020b 	ldhu	r2,8(r2)
20026128:	10bfffc4 	addi	r2,r2,-1
2002612c:	1007883a 	mov	r3,r2
20026130:	e0bffd17 	ldw	r2,-12(fp)
20026134:	10c0020d 	sth	r3,8(r2)
20026138:	e0bff717 	ldw	r2,-36(fp)
2002613c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026140:	e0bff817 	ldw	r2,-32(fp)
20026144:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
20026148:	e0bfff17 	ldw	r2,-4(fp)
2002614c:	10000005 	stb	zero,0(r2)
        return;
20026150:	00003d06 	br	20026248 <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
20026154:	d0a60517 	ldw	r2,-26604(gp)
20026158:	d0e60517 	ldw	r3,-26604(gp)
2002615c:	18c00c03 	ldbu	r3,48(r3)
20026160:	18c00054 	ori	r3,r3,1
20026164:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
20026168:	d0a60517 	ldw	r2,-26604(gp)
2002616c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
20026170:	d0a60517 	ldw	r2,-26604(gp)
20026174:	e0fffe0b 	ldhu	r3,-8(fp)
20026178:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
2002617c:	e13ffd17 	ldw	r4,-12(fp)
20026180:	0021c040 	call	20021c04 <OS_EventTaskWait>
20026184:	e0bff717 	ldw	r2,-36(fp)
20026188:	e0bffb15 	stw	r2,-20(fp)
2002618c:	e0bffb17 	ldw	r2,-20(fp)
20026190:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
20026194:	00224b80 	call	200224b8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026198:	0005303a 	rdctl	r2,status
2002619c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200261a0:	e0fff917 	ldw	r3,-28(fp)
200261a4:	00bfff84 	movi	r2,-2
200261a8:	1884703a 	and	r2,r3,r2
200261ac:	1001703a 	wrctl	status,r2
  
  return context;
200261b0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
200261b4:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
200261b8:	d0a60517 	ldw	r2,-26604(gp)
200261bc:	10800c43 	ldbu	r2,49(r2)
200261c0:	10803fcc 	andi	r2,r2,255
200261c4:	10000326 	beq	r2,zero,200261d4 <OSSemPend+0x184>
200261c8:	108000a0 	cmpeqi	r2,r2,2
200261cc:	1000041e 	bne	r2,zero,200261e0 <OSSemPend+0x190>
200261d0:	00000706 	br	200261f0 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
200261d4:	e0bfff17 	ldw	r2,-4(fp)
200261d8:	10000005 	stb	zero,0(r2)
             break;
200261dc:	00000c06 	br	20026210 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
200261e0:	e0bfff17 	ldw	r2,-4(fp)
200261e4:	00c00384 	movi	r3,14
200261e8:	10c00005 	stb	r3,0(r2)
             break;
200261ec:	00000806 	br	20026210 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
200261f0:	d0a60517 	ldw	r2,-26604(gp)
200261f4:	e17ffd17 	ldw	r5,-12(fp)
200261f8:	1009883a 	mov	r4,r2
200261fc:	0021e640 	call	20021e64 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
20026200:	e0bfff17 	ldw	r2,-4(fp)
20026204:	00c00284 	movi	r3,10
20026208:	10c00005 	stb	r3,0(r2)
             break;
2002620c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
20026210:	d0a60517 	ldw	r2,-26604(gp)
20026214:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
20026218:	d0a60517 	ldw	r2,-26604(gp)
2002621c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
20026220:	d0a60517 	ldw	r2,-26604(gp)
20026224:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
20026228:	d0a60517 	ldw	r2,-26604(gp)
2002622c:	10000815 	stw	zero,32(r2)
20026230:	e0bff717 	ldw	r2,-36(fp)
20026234:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026238:	e0bffa17 	ldw	r2,-24(fp)
2002623c:	1001703a 	wrctl	status,r2
20026240:	00000106 	br	20026248 <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
20026244:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
20026248:	e037883a 	mov	sp,fp
2002624c:	dfc00117 	ldw	ra,4(sp)
20026250:	df000017 	ldw	fp,0(sp)
20026254:	dec00204 	addi	sp,sp,8
20026258:	f800283a 	ret

2002625c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
2002625c:	defff604 	addi	sp,sp,-40
20026260:	dfc00915 	stw	ra,36(sp)
20026264:	df000815 	stw	fp,32(sp)
20026268:	df000804 	addi	fp,sp,32
2002626c:	e13ffd15 	stw	r4,-12(fp)
20026270:	2805883a 	mov	r2,r5
20026274:	e1bfff15 	stw	r6,-4(fp)
20026278:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
2002627c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
20026280:	e0bfff17 	ldw	r2,-4(fp)
20026284:	1000021e 	bne	r2,zero,20026290 <OSSemPendAbort+0x34>
        return (0);
20026288:	0005883a 	mov	r2,zero
2002628c:	00004906 	br	200263b4 <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
20026290:	e0bffd17 	ldw	r2,-12(fp)
20026294:	1000051e 	bne	r2,zero,200262ac <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
20026298:	e0bfff17 	ldw	r2,-4(fp)
2002629c:	00c00104 	movi	r3,4
200262a0:	10c00005 	stb	r3,0(r2)
        return (0);
200262a4:	0005883a 	mov	r2,zero
200262a8:	00004206 	br	200263b4 <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
200262ac:	e0bffd17 	ldw	r2,-12(fp)
200262b0:	10800003 	ldbu	r2,0(r2)
200262b4:	10803fcc 	andi	r2,r2,255
200262b8:	108000e0 	cmpeqi	r2,r2,3
200262bc:	1000051e 	bne	r2,zero,200262d4 <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
200262c0:	e0bfff17 	ldw	r2,-4(fp)
200262c4:	00c00044 	movi	r3,1
200262c8:	10c00005 	stb	r3,0(r2)
        return (0);
200262cc:	0005883a 	mov	r2,zero
200262d0:	00003806 	br	200263b4 <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200262d4:	0005303a 	rdctl	r2,status
200262d8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200262dc:	e0fffc17 	ldw	r3,-16(fp)
200262e0:	00bfff84 	movi	r2,-2
200262e4:	1884703a 	and	r2,r3,r2
200262e8:	1001703a 	wrctl	status,r2
  
  return context;
200262ec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
200262f0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
200262f4:	e0bffd17 	ldw	r2,-12(fp)
200262f8:	10800283 	ldbu	r2,10(r2)
200262fc:	10803fcc 	andi	r2,r2,255
20026300:	10002526 	beq	r2,zero,20026398 <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
20026304:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
20026308:	e0bffe03 	ldbu	r2,-8(fp)
2002630c:	10800060 	cmpeqi	r2,r2,1
20026310:	10000e26 	beq	r2,zero,2002634c <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
20026314:	00000806 	br	20026338 <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
20026318:	01c00084 	movi	r7,2
2002631c:	01800044 	movi	r6,1
20026320:	000b883a 	mov	r5,zero
20026324:	e13ffd17 	ldw	r4,-12(fp)
20026328:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
                     nbr_tasks++;
2002632c:	e0bff803 	ldbu	r2,-32(fp)
20026330:	10800044 	addi	r2,r2,1
20026334:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
20026338:	e0bffd17 	ldw	r2,-12(fp)
2002633c:	10800283 	ldbu	r2,10(r2)
20026340:	10803fcc 	andi	r2,r2,255
20026344:	103ff41e 	bne	r2,zero,20026318 <__alt_data_end+0xfffe6318>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
20026348:	00000906 	br	20026370 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
2002634c:	01c00084 	movi	r7,2
20026350:	01800044 	movi	r6,1
20026354:	000b883a 	mov	r5,zero
20026358:	e13ffd17 	ldw	r4,-12(fp)
2002635c:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
                 nbr_tasks++;
20026360:	e0bff803 	ldbu	r2,-32(fp)
20026364:	10800044 	addi	r2,r2,1
20026368:	e0bff805 	stb	r2,-32(fp)
                 break;
2002636c:	0001883a 	nop
20026370:	e0bff917 	ldw	r2,-28(fp)
20026374:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026378:	e0bffa17 	ldw	r2,-24(fp)
2002637c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
20026380:	00224b80 	call	200224b8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
20026384:	e0bfff17 	ldw	r2,-4(fp)
20026388:	00c00384 	movi	r3,14
2002638c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
20026390:	e0bff803 	ldbu	r2,-32(fp)
20026394:	00000706 	br	200263b4 <OSSemPendAbort+0x158>
20026398:	e0bff917 	ldw	r2,-28(fp)
2002639c:	e0bffb15 	stw	r2,-20(fp)
200263a0:	e0bffb17 	ldw	r2,-20(fp)
200263a4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
200263a8:	e0bfff17 	ldw	r2,-4(fp)
200263ac:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
200263b0:	0005883a 	mov	r2,zero
}
200263b4:	e037883a 	mov	sp,fp
200263b8:	dfc00117 	ldw	ra,4(sp)
200263bc:	df000017 	ldw	fp,0(sp)
200263c0:	dec00204 	addi	sp,sp,8
200263c4:	f800283a 	ret

200263c8 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
200263c8:	defff804 	addi	sp,sp,-32
200263cc:	dfc00715 	stw	ra,28(sp)
200263d0:	df000615 	stw	fp,24(sp)
200263d4:	df000604 	addi	fp,sp,24
200263d8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
200263dc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
200263e0:	e0bfff17 	ldw	r2,-4(fp)
200263e4:	1000021e 	bne	r2,zero,200263f0 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
200263e8:	00800104 	movi	r2,4
200263ec:	00003506 	br	200264c4 <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
200263f0:	e0bfff17 	ldw	r2,-4(fp)
200263f4:	10800003 	ldbu	r2,0(r2)
200263f8:	10803fcc 	andi	r2,r2,255
200263fc:	108000e0 	cmpeqi	r2,r2,3
20026400:	1000021e 	bne	r2,zero,2002640c <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
20026404:	00800044 	movi	r2,1
20026408:	00002e06 	br	200264c4 <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002640c:	0005303a 	rdctl	r2,status
20026410:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026414:	e0fffe17 	ldw	r3,-8(fp)
20026418:	00bfff84 	movi	r2,-2
2002641c:	1884703a 	and	r2,r3,r2
20026420:	1001703a 	wrctl	status,r2
  
  return context;
20026424:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
20026428:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
2002642c:	e0bfff17 	ldw	r2,-4(fp)
20026430:	10800283 	ldbu	r2,10(r2)
20026434:	10803fcc 	andi	r2,r2,255
20026438:	10000c26 	beq	r2,zero,2002646c <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
2002643c:	000f883a 	mov	r7,zero
20026440:	01800044 	movi	r6,1
20026444:	000b883a 	mov	r5,zero
20026448:	e13fff17 	ldw	r4,-4(fp)
2002644c:	0021a6c0 	call	20021a6c <OS_EventTaskRdy>
20026450:	e0bffa17 	ldw	r2,-24(fp)
20026454:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026458:	e0bffb17 	ldw	r2,-20(fp)
2002645c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
20026460:	00224b80 	call	200224b8 <OS_Sched>
        return (OS_ERR_NONE);
20026464:	0005883a 	mov	r2,zero
20026468:	00001606 	br	200264c4 <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
2002646c:	e0bfff17 	ldw	r2,-4(fp)
20026470:	1080020b 	ldhu	r2,8(r2)
20026474:	10ffffcc 	andi	r3,r2,65535
20026478:	00bfffd4 	movui	r2,65535
2002647c:	18800c26 	beq	r3,r2,200264b0 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
20026480:	e0bfff17 	ldw	r2,-4(fp)
20026484:	1080020b 	ldhu	r2,8(r2)
20026488:	10800044 	addi	r2,r2,1
2002648c:	1007883a 	mov	r3,r2
20026490:	e0bfff17 	ldw	r2,-4(fp)
20026494:	10c0020d 	sth	r3,8(r2)
20026498:	e0bffa17 	ldw	r2,-24(fp)
2002649c:	e0bffc15 	stw	r2,-16(fp)
200264a0:	e0bffc17 	ldw	r2,-16(fp)
200264a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
200264a8:	0005883a 	mov	r2,zero
200264ac:	00000506 	br	200264c4 <OSSemPost+0xfc>
200264b0:	e0bffa17 	ldw	r2,-24(fp)
200264b4:	e0bffd15 	stw	r2,-12(fp)
200264b8:	e0bffd17 	ldw	r2,-12(fp)
200264bc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
200264c0:	00800c84 	movi	r2,50
}
200264c4:	e037883a 	mov	sp,fp
200264c8:	dfc00117 	ldw	ra,4(sp)
200264cc:	df000017 	ldw	fp,0(sp)
200264d0:	dec00204 	addi	sp,sp,8
200264d4:	f800283a 	ret

200264d8 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
200264d8:	defff704 	addi	sp,sp,-36
200264dc:	df000815 	stw	fp,32(sp)
200264e0:	df000804 	addi	fp,sp,32
200264e4:	e13ffe15 	stw	r4,-8(fp)
200264e8:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
200264ec:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
200264f0:	e0bffe17 	ldw	r2,-8(fp)
200264f4:	1000021e 	bne	r2,zero,20026500 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
200264f8:	00800104 	movi	r2,4
200264fc:	00003606 	br	200265d8 <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
20026500:	e0bfff17 	ldw	r2,-4(fp)
20026504:	1000021e 	bne	r2,zero,20026510 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
20026508:	00800244 	movi	r2,9
2002650c:	00003206 	br	200265d8 <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
20026510:	e0bffe17 	ldw	r2,-8(fp)
20026514:	10800003 	ldbu	r2,0(r2)
20026518:	10803fcc 	andi	r2,r2,255
2002651c:	108000e0 	cmpeqi	r2,r2,3
20026520:	1000021e 	bne	r2,zero,2002652c <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
20026524:	00800044 	movi	r2,1
20026528:	00002b06 	br	200265d8 <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002652c:	0005303a 	rdctl	r2,status
20026530:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026534:	e0fffd17 	ldw	r3,-12(fp)
20026538:	00bfff84 	movi	r2,-2
2002653c:	1884703a 	and	r2,r3,r2
20026540:	1001703a 	wrctl	status,r2
  
  return context;
20026544:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
20026548:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
2002654c:	e0bffe17 	ldw	r2,-8(fp)
20026550:	10c00283 	ldbu	r3,10(r2)
20026554:	e0bfff17 	ldw	r2,-4(fp)
20026558:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
2002655c:	e0bffe17 	ldw	r2,-8(fp)
20026560:	108002c4 	addi	r2,r2,11
20026564:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
20026568:	e0bfff17 	ldw	r2,-4(fp)
2002656c:	10800084 	addi	r2,r2,2
20026570:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
20026574:	e03ffa05 	stb	zero,-24(fp)
20026578:	00000b06 	br	200265a8 <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
2002657c:	e0bff917 	ldw	r2,-28(fp)
20026580:	10c00044 	addi	r3,r2,1
20026584:	e0fff915 	stw	r3,-28(fp)
20026588:	e0fff817 	ldw	r3,-32(fp)
2002658c:	19000044 	addi	r4,r3,1
20026590:	e13ff815 	stw	r4,-32(fp)
20026594:	18c00003 	ldbu	r3,0(r3)
20026598:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
2002659c:	e0bffa03 	ldbu	r2,-24(fp)
200265a0:	10800044 	addi	r2,r2,1
200265a4:	e0bffa05 	stb	r2,-24(fp)
200265a8:	e0bffa03 	ldbu	r2,-24(fp)
200265ac:	108000f0 	cmpltui	r2,r2,3
200265b0:	103ff21e 	bne	r2,zero,2002657c <__alt_data_end+0xfffe657c>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
200265b4:	e0bffe17 	ldw	r2,-8(fp)
200265b8:	10c0020b 	ldhu	r3,8(r2)
200265bc:	e0bfff17 	ldw	r2,-4(fp)
200265c0:	10c0000d 	sth	r3,0(r2)
200265c4:	e0bffb17 	ldw	r2,-20(fp)
200265c8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200265cc:	e0bffc17 	ldw	r2,-16(fp)
200265d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
200265d4:	0005883a 	mov	r2,zero
}
200265d8:	e037883a 	mov	sp,fp
200265dc:	df000017 	ldw	fp,0(sp)
200265e0:	dec00104 	addi	sp,sp,4
200265e4:	f800283a 	ret

200265e8 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
200265e8:	defff904 	addi	sp,sp,-28
200265ec:	df000615 	stw	fp,24(sp)
200265f0:	df000604 	addi	fp,sp,24
200265f4:	e13ffd15 	stw	r4,-12(fp)
200265f8:	2805883a 	mov	r2,r5
200265fc:	e1bfff15 	stw	r6,-4(fp)
20026600:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
20026604:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
20026608:	e0bfff17 	ldw	r2,-4(fp)
2002660c:	10003126 	beq	r2,zero,200266d4 <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
20026610:	e0bffd17 	ldw	r2,-12(fp)
20026614:	1000041e 	bne	r2,zero,20026628 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
20026618:	e0bfff17 	ldw	r2,-4(fp)
2002661c:	00c00104 	movi	r3,4
20026620:	10c00005 	stb	r3,0(r2)
        return;
20026624:	00002c06 	br	200266d8 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
20026628:	e0bffd17 	ldw	r2,-12(fp)
2002662c:	10800003 	ldbu	r2,0(r2)
20026630:	10803fcc 	andi	r2,r2,255
20026634:	108000e0 	cmpeqi	r2,r2,3
20026638:	1000041e 	bne	r2,zero,2002664c <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
2002663c:	e0bfff17 	ldw	r2,-4(fp)
20026640:	00c00044 	movi	r3,1
20026644:	10c00005 	stb	r3,0(r2)
        return;
20026648:	00002306 	br	200266d8 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002664c:	0005303a 	rdctl	r2,status
20026650:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026654:	e0fffc17 	ldw	r3,-16(fp)
20026658:	00bfff84 	movi	r2,-2
2002665c:	1884703a 	and	r2,r3,r2
20026660:	1001703a 	wrctl	status,r2
  
  return context;
20026664:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
20026668:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
2002666c:	e0bfff17 	ldw	r2,-4(fp)
20026670:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
20026674:	e0bffd17 	ldw	r2,-12(fp)
20026678:	1080020b 	ldhu	r2,8(r2)
2002667c:	10bfffcc 	andi	r2,r2,65535
20026680:	10000426 	beq	r2,zero,20026694 <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
20026684:	e0bffd17 	ldw	r2,-12(fp)
20026688:	e0fffe0b 	ldhu	r3,-8(fp)
2002668c:	10c0020d 	sth	r3,8(r2)
20026690:	00000b06 	br	200266c0 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
20026694:	e0bffd17 	ldw	r2,-12(fp)
20026698:	10800283 	ldbu	r2,10(r2)
2002669c:	10803fcc 	andi	r2,r2,255
200266a0:	1000041e 	bne	r2,zero,200266b4 <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
200266a4:	e0bffd17 	ldw	r2,-12(fp)
200266a8:	e0fffe0b 	ldhu	r3,-8(fp)
200266ac:	10c0020d 	sth	r3,8(r2)
200266b0:	00000306 	br	200266c0 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
200266b4:	e0bfff17 	ldw	r2,-4(fp)
200266b8:	00c01244 	movi	r3,73
200266bc:	10c00005 	stb	r3,0(r2)
200266c0:	e0bffa17 	ldw	r2,-24(fp)
200266c4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200266c8:	e0bffb17 	ldw	r2,-20(fp)
200266cc:	1001703a 	wrctl	status,r2
200266d0:	00000106 	br	200266d8 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
200266d4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
200266d8:	e037883a 	mov	sp,fp
200266dc:	df000017 	ldw	fp,0(sp)
200266e0:	dec00104 	addi	sp,sp,4
200266e4:	f800283a 	ret

200266e8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
200266e8:	defff104 	addi	sp,sp,-60
200266ec:	dfc00e15 	stw	ra,56(sp)
200266f0:	df000d15 	stw	fp,52(sp)
200266f4:	df000d04 	addi	fp,sp,52
200266f8:	2007883a 	mov	r3,r4
200266fc:	2805883a 	mov	r2,r5
20026700:	e0fffe05 	stb	r3,-8(fp)
20026704:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
20026708:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
2002670c:	e0bffe03 	ldbu	r2,-8(fp)
20026710:	10800530 	cmpltui	r2,r2,20
20026714:	1000051e 	bne	r2,zero,2002672c <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
20026718:	e0bffe03 	ldbu	r2,-8(fp)
2002671c:	10803fe0 	cmpeqi	r2,r2,255
20026720:	1000021e 	bne	r2,zero,2002672c <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
20026724:	00800a84 	movi	r2,42
20026728:	00012606 	br	20026bc4 <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
2002672c:	e0bfff03 	ldbu	r2,-4(fp)
20026730:	10800530 	cmpltui	r2,r2,20
20026734:	1000021e 	bne	r2,zero,20026740 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
20026738:	00800a84 	movi	r2,42
2002673c:	00012106 	br	20026bc4 <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026740:	0005303a 	rdctl	r2,status
20026744:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026748:	e0fffd17 	ldw	r3,-12(fp)
2002674c:	00bfff84 	movi	r2,-2
20026750:	1884703a 	and	r2,r3,r2
20026754:	1001703a 	wrctl	status,r2
  
  return context;
20026758:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
2002675c:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
20026760:	e0ffff03 	ldbu	r3,-4(fp)
20026764:	008800f4 	movhi	r2,8195
20026768:	1086b504 	addi	r2,r2,6868
2002676c:	18c7883a 	add	r3,r3,r3
20026770:	18c7883a 	add	r3,r3,r3
20026774:	10c5883a 	add	r2,r2,r3
20026778:	10800017 	ldw	r2,0(r2)
2002677c:	10000626 	beq	r2,zero,20026798 <OSTaskChangePrio+0xb0>
20026780:	e0bff517 	ldw	r2,-44(fp)
20026784:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026788:	e0bff617 	ldw	r2,-40(fp)
2002678c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
20026790:	00800a04 	movi	r2,40
20026794:	00010b06 	br	20026bc4 <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
20026798:	e0bffe03 	ldbu	r2,-8(fp)
2002679c:	10803fd8 	cmpnei	r2,r2,255
200267a0:	1000031e 	bne	r2,zero,200267b0 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
200267a4:	d0a60517 	ldw	r2,-26604(gp)
200267a8:	10800c83 	ldbu	r2,50(r2)
200267ac:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
200267b0:	e0fffe03 	ldbu	r3,-8(fp)
200267b4:	008800f4 	movhi	r2,8195
200267b8:	1086b504 	addi	r2,r2,6868
200267bc:	18c7883a 	add	r3,r3,r3
200267c0:	18c7883a 	add	r3,r3,r3
200267c4:	10c5883a 	add	r2,r2,r3
200267c8:	10800017 	ldw	r2,0(r2)
200267cc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
200267d0:	e0bff817 	ldw	r2,-32(fp)
200267d4:	1000061e 	bne	r2,zero,200267f0 <OSTaskChangePrio+0x108>
200267d8:	e0bff517 	ldw	r2,-44(fp)
200267dc:	e0bff715 	stw	r2,-36(fp)
200267e0:	e0bff717 	ldw	r2,-36(fp)
200267e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
200267e8:	00800a44 	movi	r2,41
200267ec:	0000f506 	br	20026bc4 <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
200267f0:	e0bff817 	ldw	r2,-32(fp)
200267f4:	10800058 	cmpnei	r2,r2,1
200267f8:	1000061e 	bne	r2,zero,20026814 <OSTaskChangePrio+0x12c>
200267fc:	e0bff517 	ldw	r2,-44(fp)
20026800:	e0bff915 	stw	r2,-28(fp)
20026804:	e0bff917 	ldw	r2,-28(fp)
20026808:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
2002680c:	008010c4 	movi	r2,67
20026810:	0000ec06 	br	20026bc4 <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
20026814:	e0bfff03 	ldbu	r2,-4(fp)
20026818:	1004d0fa 	srli	r2,r2,3
2002681c:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
20026820:	e0bfff03 	ldbu	r2,-4(fp)
20026824:	108001cc 	andi	r2,r2,7
20026828:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
2002682c:	e0bffb03 	ldbu	r2,-20(fp)
20026830:	00c00044 	movi	r3,1
20026834:	1884983a 	sll	r2,r3,r2
20026838:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
2002683c:	e0bffb43 	ldbu	r2,-19(fp)
20026840:	00c00044 	movi	r3,1
20026844:	1884983a 	sll	r2,r3,r2
20026848:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
2002684c:	e0fffe03 	ldbu	r3,-8(fp)
20026850:	008800f4 	movhi	r2,8195
20026854:	1086b504 	addi	r2,r2,6868
20026858:	18c7883a 	add	r3,r3,r3
2002685c:	18c7883a 	add	r3,r3,r3
20026860:	10c5883a 	add	r2,r2,r3
20026864:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
20026868:	e0ffff03 	ldbu	r3,-4(fp)
2002686c:	008800f4 	movhi	r2,8195
20026870:	1086b504 	addi	r2,r2,6868
20026874:	18c7883a 	add	r3,r3,r3
20026878:	18c7883a 	add	r3,r3,r3
2002687c:	10c5883a 	add	r2,r2,r3
20026880:	e0fff817 	ldw	r3,-32(fp)
20026884:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
20026888:	e0bff817 	ldw	r2,-32(fp)
2002688c:	10800d03 	ldbu	r2,52(r2)
20026890:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
20026894:	e0bff817 	ldw	r2,-32(fp)
20026898:	10800d83 	ldbu	r2,54(r2)
2002689c:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
200268a0:	e0bff817 	ldw	r2,-32(fp)
200268a4:	10800d43 	ldbu	r2,53(r2)
200268a8:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
200268ac:	e0fffc03 	ldbu	r3,-16(fp)
200268b0:	d0a60244 	addi	r2,gp,-26615
200268b4:	1885883a 	add	r2,r3,r2
200268b8:	10c00003 	ldbu	r3,0(r2)
200268bc:	e0bffc83 	ldbu	r2,-14(fp)
200268c0:	1884703a 	and	r2,r3,r2
200268c4:	10803fcc 	andi	r2,r2,255
200268c8:	10002826 	beq	r2,zero,2002696c <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
200268cc:	e0fffc03 	ldbu	r3,-16(fp)
200268d0:	e13ffc03 	ldbu	r4,-16(fp)
200268d4:	d0a60244 	addi	r2,gp,-26615
200268d8:	2085883a 	add	r2,r4,r2
200268dc:	10800003 	ldbu	r2,0(r2)
200268e0:	1009883a 	mov	r4,r2
200268e4:	e0bffc83 	ldbu	r2,-14(fp)
200268e8:	0084303a 	nor	r2,zero,r2
200268ec:	2084703a 	and	r2,r4,r2
200268f0:	1009883a 	mov	r4,r2
200268f4:	d0a60244 	addi	r2,gp,-26615
200268f8:	1885883a 	add	r2,r3,r2
200268fc:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
20026900:	e0fffc03 	ldbu	r3,-16(fp)
20026904:	d0a60244 	addi	r2,gp,-26615
20026908:	1885883a 	add	r2,r3,r2
2002690c:	10800003 	ldbu	r2,0(r2)
20026910:	10803fcc 	andi	r2,r2,255
20026914:	1000061e 	bne	r2,zero,20026930 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
20026918:	e0bffc43 	ldbu	r2,-15(fp)
2002691c:	0084303a 	nor	r2,zero,r2
20026920:	1007883a 	mov	r3,r2
20026924:	d0a60203 	ldbu	r2,-26616(gp)
20026928:	1884703a 	and	r2,r3,r2
2002692c:	d0a60205 	stb	r2,-26616(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
20026930:	d0e60203 	ldbu	r3,-26616(gp)
20026934:	e0bffb83 	ldbu	r2,-18(fp)
20026938:	1884b03a 	or	r2,r3,r2
2002693c:	d0a60205 	stb	r2,-26616(gp)
         OSRdyTbl[y_new] |= bitx_new;
20026940:	e0fffb03 	ldbu	r3,-20(fp)
20026944:	e13ffb03 	ldbu	r4,-20(fp)
20026948:	d0a60244 	addi	r2,gp,-26615
2002694c:	2085883a 	add	r2,r4,r2
20026950:	11000003 	ldbu	r4,0(r2)
20026954:	e0bffbc3 	ldbu	r2,-17(fp)
20026958:	2084b03a 	or	r2,r4,r2
2002695c:	1009883a 	mov	r4,r2
20026960:	d0a60244 	addi	r2,gp,-26615
20026964:	1885883a 	add	r2,r3,r2
20026968:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
2002696c:	e0bff817 	ldw	r2,-32(fp)
20026970:	10800717 	ldw	r2,28(r2)
20026974:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
20026978:	e0bff317 	ldw	r2,-52(fp)
2002697c:	10003326 	beq	r2,zero,20026a4c <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
20026980:	e0bffc03 	ldbu	r2,-16(fp)
20026984:	e0fffc03 	ldbu	r3,-16(fp)
20026988:	e13ff317 	ldw	r4,-52(fp)
2002698c:	20c7883a 	add	r3,r4,r3
20026990:	18c002c4 	addi	r3,r3,11
20026994:	18c00003 	ldbu	r3,0(r3)
20026998:	1809883a 	mov	r4,r3
2002699c:	e0fffc83 	ldbu	r3,-14(fp)
200269a0:	00c6303a 	nor	r3,zero,r3
200269a4:	20c6703a 	and	r3,r4,r3
200269a8:	1809883a 	mov	r4,r3
200269ac:	e0fff317 	ldw	r3,-52(fp)
200269b0:	1885883a 	add	r2,r3,r2
200269b4:	108002c4 	addi	r2,r2,11
200269b8:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
200269bc:	e0bffc03 	ldbu	r2,-16(fp)
200269c0:	e0fff317 	ldw	r3,-52(fp)
200269c4:	1885883a 	add	r2,r3,r2
200269c8:	108002c4 	addi	r2,r2,11
200269cc:	10800003 	ldbu	r2,0(r2)
200269d0:	10803fcc 	andi	r2,r2,255
200269d4:	1000091e 	bne	r2,zero,200269fc <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
200269d8:	e0bff317 	ldw	r2,-52(fp)
200269dc:	10800283 	ldbu	r2,10(r2)
200269e0:	1007883a 	mov	r3,r2
200269e4:	e0bffc43 	ldbu	r2,-15(fp)
200269e8:	0084303a 	nor	r2,zero,r2
200269ec:	1884703a 	and	r2,r3,r2
200269f0:	1007883a 	mov	r3,r2
200269f4:	e0bff317 	ldw	r2,-52(fp)
200269f8:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
200269fc:	e0bff317 	ldw	r2,-52(fp)
20026a00:	10c00283 	ldbu	r3,10(r2)
20026a04:	e0bffb83 	ldbu	r2,-18(fp)
20026a08:	1884b03a 	or	r2,r3,r2
20026a0c:	1007883a 	mov	r3,r2
20026a10:	e0bff317 	ldw	r2,-52(fp)
20026a14:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
20026a18:	e0bffb03 	ldbu	r2,-20(fp)
20026a1c:	e0fffb03 	ldbu	r3,-20(fp)
20026a20:	e13ff317 	ldw	r4,-52(fp)
20026a24:	20c7883a 	add	r3,r4,r3
20026a28:	18c002c4 	addi	r3,r3,11
20026a2c:	19000003 	ldbu	r4,0(r3)
20026a30:	e0fffbc3 	ldbu	r3,-17(fp)
20026a34:	20c6b03a 	or	r3,r4,r3
20026a38:	1809883a 	mov	r4,r3
20026a3c:	e0fff317 	ldw	r3,-52(fp)
20026a40:	1885883a 	add	r2,r3,r2
20026a44:	108002c4 	addi	r2,r2,11
20026a48:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
20026a4c:	e0bff817 	ldw	r2,-32(fp)
20026a50:	10800817 	ldw	r2,32(r2)
20026a54:	10004226 	beq	r2,zero,20026b60 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
20026a58:	e0bff817 	ldw	r2,-32(fp)
20026a5c:	10800817 	ldw	r2,32(r2)
20026a60:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
20026a64:	e0bff417 	ldw	r2,-48(fp)
20026a68:	10800017 	ldw	r2,0(r2)
20026a6c:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
20026a70:	00003906 	br	20026b58 <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
20026a74:	e0bffc03 	ldbu	r2,-16(fp)
20026a78:	e0fffc03 	ldbu	r3,-16(fp)
20026a7c:	e13ff317 	ldw	r4,-52(fp)
20026a80:	20c7883a 	add	r3,r4,r3
20026a84:	18c002c4 	addi	r3,r3,11
20026a88:	18c00003 	ldbu	r3,0(r3)
20026a8c:	1809883a 	mov	r4,r3
20026a90:	e0fffc83 	ldbu	r3,-14(fp)
20026a94:	00c6303a 	nor	r3,zero,r3
20026a98:	20c6703a 	and	r3,r4,r3
20026a9c:	1809883a 	mov	r4,r3
20026aa0:	e0fff317 	ldw	r3,-52(fp)
20026aa4:	1885883a 	add	r2,r3,r2
20026aa8:	108002c4 	addi	r2,r2,11
20026aac:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
20026ab0:	e0bffc03 	ldbu	r2,-16(fp)
20026ab4:	e0fff317 	ldw	r3,-52(fp)
20026ab8:	1885883a 	add	r2,r3,r2
20026abc:	108002c4 	addi	r2,r2,11
20026ac0:	10800003 	ldbu	r2,0(r2)
20026ac4:	10803fcc 	andi	r2,r2,255
20026ac8:	1000091e 	bne	r2,zero,20026af0 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
20026acc:	e0bff317 	ldw	r2,-52(fp)
20026ad0:	10800283 	ldbu	r2,10(r2)
20026ad4:	1007883a 	mov	r3,r2
20026ad8:	e0bffc43 	ldbu	r2,-15(fp)
20026adc:	0084303a 	nor	r2,zero,r2
20026ae0:	1884703a 	and	r2,r3,r2
20026ae4:	1007883a 	mov	r3,r2
20026ae8:	e0bff317 	ldw	r2,-52(fp)
20026aec:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
20026af0:	e0bff317 	ldw	r2,-52(fp)
20026af4:	10c00283 	ldbu	r3,10(r2)
20026af8:	e0bffb83 	ldbu	r2,-18(fp)
20026afc:	1884b03a 	or	r2,r3,r2
20026b00:	1007883a 	mov	r3,r2
20026b04:	e0bff317 	ldw	r2,-52(fp)
20026b08:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
20026b0c:	e0bffb03 	ldbu	r2,-20(fp)
20026b10:	e0fffb03 	ldbu	r3,-20(fp)
20026b14:	e13ff317 	ldw	r4,-52(fp)
20026b18:	20c7883a 	add	r3,r4,r3
20026b1c:	18c002c4 	addi	r3,r3,11
20026b20:	19000003 	ldbu	r4,0(r3)
20026b24:	e0fffbc3 	ldbu	r3,-17(fp)
20026b28:	20c6b03a 	or	r3,r4,r3
20026b2c:	1809883a 	mov	r4,r3
20026b30:	e0fff317 	ldw	r3,-52(fp)
20026b34:	1885883a 	add	r2,r3,r2
20026b38:	108002c4 	addi	r2,r2,11
20026b3c:	11000005 	stb	r4,0(r2)
            pevents++;
20026b40:	e0bff417 	ldw	r2,-48(fp)
20026b44:	10800104 	addi	r2,r2,4
20026b48:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
20026b4c:	e0bff417 	ldw	r2,-48(fp)
20026b50:	10800017 	ldw	r2,0(r2)
20026b54:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
20026b58:	e0bff317 	ldw	r2,-52(fp)
20026b5c:	103fc51e 	bne	r2,zero,20026a74 <__alt_data_end+0xfffe6a74>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
20026b60:	e0bff817 	ldw	r2,-32(fp)
20026b64:	e0ffff03 	ldbu	r3,-4(fp)
20026b68:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
20026b6c:	e0bff817 	ldw	r2,-32(fp)
20026b70:	e0fffb03 	ldbu	r3,-20(fp)
20026b74:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
20026b78:	e0bff817 	ldw	r2,-32(fp)
20026b7c:	e0fffb43 	ldbu	r3,-19(fp)
20026b80:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
20026b84:	e0bff817 	ldw	r2,-32(fp)
20026b88:	e0fffb83 	ldbu	r3,-18(fp)
20026b8c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
20026b90:	e0bff817 	ldw	r2,-32(fp)
20026b94:	e0fffbc3 	ldbu	r3,-17(fp)
20026b98:	10c00d45 	stb	r3,53(r2)
20026b9c:	e0bff517 	ldw	r2,-44(fp)
20026ba0:	e0bffa15 	stw	r2,-24(fp)
20026ba4:	e0bffa17 	ldw	r2,-24(fp)
20026ba8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
20026bac:	d0a5f643 	ldbu	r2,-26663(gp)
20026bb0:	10803fcc 	andi	r2,r2,255
20026bb4:	10800058 	cmpnei	r2,r2,1
20026bb8:	1000011e 	bne	r2,zero,20026bc0 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
20026bbc:	00224b80 	call	200224b8 <OS_Sched>
    }
    return (OS_ERR_NONE);
20026bc0:	0005883a 	mov	r2,zero
}
20026bc4:	e037883a 	mov	sp,fp
20026bc8:	dfc00117 	ldw	ra,4(sp)
20026bcc:	df000017 	ldw	fp,0(sp)
20026bd0:	dec00204 	addi	sp,sp,8
20026bd4:	f800283a 	ret

20026bd8 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
20026bd8:	deffee04 	addi	sp,sp,-72
20026bdc:	dfc01115 	stw	ra,68(sp)
20026be0:	df001015 	stw	fp,64(sp)
20026be4:	df001004 	addi	fp,sp,64
20026be8:	e13ffc15 	stw	r4,-16(fp)
20026bec:	e17ffd15 	stw	r5,-12(fp)
20026bf0:	e1bffe15 	stw	r6,-8(fp)
20026bf4:	3805883a 	mov	r2,r7
20026bf8:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
20026bfc:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
20026c00:	e0bfff03 	ldbu	r2,-4(fp)
20026c04:	10800570 	cmpltui	r2,r2,21
20026c08:	1000021e 	bne	r2,zero,20026c14 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
20026c0c:	00800a84 	movi	r2,42
20026c10:	00005706 	br	20026d70 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026c14:	0005303a 	rdctl	r2,status
20026c18:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026c1c:	e0fffb17 	ldw	r3,-20(fp)
20026c20:	00bfff84 	movi	r2,-2
20026c24:	1884703a 	and	r2,r3,r2
20026c28:	1001703a 	wrctl	status,r2
  
  return context;
20026c2c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
20026c30:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
20026c34:	d0a60403 	ldbu	r2,-26608(gp)
20026c38:	10803fcc 	andi	r2,r2,255
20026c3c:	10000626 	beq	r2,zero,20026c58 <OSTaskCreate+0x80>
20026c40:	e0bff317 	ldw	r2,-52(fp)
20026c44:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026c48:	e0bff417 	ldw	r2,-48(fp)
20026c4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
20026c50:	00800f04 	movi	r2,60
20026c54:	00004606 	br	20026d70 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
20026c58:	e0ffff03 	ldbu	r3,-4(fp)
20026c5c:	008800f4 	movhi	r2,8195
20026c60:	1086b504 	addi	r2,r2,6868
20026c64:	18c7883a 	add	r3,r3,r3
20026c68:	18c7883a 	add	r3,r3,r3
20026c6c:	10c5883a 	add	r2,r2,r3
20026c70:	10800017 	ldw	r2,0(r2)
20026c74:	1000391e 	bne	r2,zero,20026d5c <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
20026c78:	e0ffff03 	ldbu	r3,-4(fp)
20026c7c:	008800f4 	movhi	r2,8195
20026c80:	1086b504 	addi	r2,r2,6868
20026c84:	18c7883a 	add	r3,r3,r3
20026c88:	18c7883a 	add	r3,r3,r3
20026c8c:	10c5883a 	add	r2,r2,r3
20026c90:	00c00044 	movi	r3,1
20026c94:	10c00015 	stw	r3,0(r2)
20026c98:	e0bff317 	ldw	r2,-52(fp)
20026c9c:	e0bff515 	stw	r2,-44(fp)
20026ca0:	e0bff517 	ldw	r2,-44(fp)
20026ca4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
20026ca8:	000f883a 	mov	r7,zero
20026cac:	e1bffe17 	ldw	r6,-8(fp)
20026cb0:	e17ffd17 	ldw	r5,-12(fp)
20026cb4:	e13ffc17 	ldw	r4,-16(fp)
20026cb8:	002a2a40 	call	2002a2a4 <OSTaskStkInit>
20026cbc:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
20026cc0:	e0bfff03 	ldbu	r2,-4(fp)
20026cc4:	d8000215 	stw	zero,8(sp)
20026cc8:	d8000115 	stw	zero,4(sp)
20026ccc:	d8000015 	stw	zero,0(sp)
20026cd0:	000f883a 	mov	r7,zero
20026cd4:	000d883a 	mov	r6,zero
20026cd8:	e17ff717 	ldw	r5,-36(fp)
20026cdc:	1009883a 	mov	r4,r2
20026ce0:	00228b80 	call	200228b8 <OS_TCBInit>
20026ce4:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
20026ce8:	e0bff803 	ldbu	r2,-32(fp)
20026cec:	1000061e 	bne	r2,zero,20026d08 <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
20026cf0:	d0a5f643 	ldbu	r2,-26663(gp)
20026cf4:	10803fcc 	andi	r2,r2,255
20026cf8:	10800058 	cmpnei	r2,r2,1
20026cfc:	1000151e 	bne	r2,zero,20026d54 <OSTaskCreate+0x17c>
                OS_Sched();
20026d00:	00224b80 	call	200224b8 <OS_Sched>
20026d04:	00001306 	br	20026d54 <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026d08:	0005303a 	rdctl	r2,status
20026d0c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026d10:	e0fffa17 	ldw	r3,-24(fp)
20026d14:	00bfff84 	movi	r2,-2
20026d18:	1884703a 	and	r2,r3,r2
20026d1c:	1001703a 	wrctl	status,r2
  
  return context;
20026d20:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
20026d24:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
20026d28:	e0ffff03 	ldbu	r3,-4(fp)
20026d2c:	008800f4 	movhi	r2,8195
20026d30:	1086b504 	addi	r2,r2,6868
20026d34:	18c7883a 	add	r3,r3,r3
20026d38:	18c7883a 	add	r3,r3,r3
20026d3c:	10c5883a 	add	r2,r2,r3
20026d40:	10000015 	stw	zero,0(r2)
20026d44:	e0bff317 	ldw	r2,-52(fp)
20026d48:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026d4c:	e0bff617 	ldw	r2,-40(fp)
20026d50:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
20026d54:	e0bff803 	ldbu	r2,-32(fp)
20026d58:	00000506 	br	20026d70 <OSTaskCreate+0x198>
20026d5c:	e0bff317 	ldw	r2,-52(fp)
20026d60:	e0bff915 	stw	r2,-28(fp)
20026d64:	e0bff917 	ldw	r2,-28(fp)
20026d68:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
20026d6c:	00800a04 	movi	r2,40
}
20026d70:	e037883a 	mov	sp,fp
20026d74:	dfc00117 	ldw	ra,4(sp)
20026d78:	df000017 	ldw	fp,0(sp)
20026d7c:	dec00204 	addi	sp,sp,8
20026d80:	f800283a 	ret

20026d84 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
20026d84:	deffec04 	addi	sp,sp,-80
20026d88:	dfc01315 	stw	ra,76(sp)
20026d8c:	df001215 	stw	fp,72(sp)
20026d90:	df001204 	addi	fp,sp,72
20026d94:	e13ffa15 	stw	r4,-24(fp)
20026d98:	e17ffb15 	stw	r5,-20(fp)
20026d9c:	e1bffc15 	stw	r6,-16(fp)
20026da0:	3809883a 	mov	r4,r7
20026da4:	e0c00217 	ldw	r3,8(fp)
20026da8:	e0800617 	ldw	r2,24(fp)
20026dac:	e13ffd05 	stb	r4,-12(fp)
20026db0:	e0fffe0d 	sth	r3,-8(fp)
20026db4:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
20026db8:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
20026dbc:	e0bffd03 	ldbu	r2,-12(fp)
20026dc0:	10800570 	cmpltui	r2,r2,21
20026dc4:	1000021e 	bne	r2,zero,20026dd0 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
20026dc8:	00800a84 	movi	r2,42
20026dcc:	00006106 	br	20026f54 <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026dd0:	0005303a 	rdctl	r2,status
20026dd4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026dd8:	e0fff917 	ldw	r3,-28(fp)
20026ddc:	00bfff84 	movi	r2,-2
20026de0:	1884703a 	and	r2,r3,r2
20026de4:	1001703a 	wrctl	status,r2
  
  return context;
20026de8:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
20026dec:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
20026df0:	d0a60403 	ldbu	r2,-26608(gp)
20026df4:	10803fcc 	andi	r2,r2,255
20026df8:	10000626 	beq	r2,zero,20026e14 <OSTaskCreateExt+0x90>
20026dfc:	e0bff117 	ldw	r2,-60(fp)
20026e00:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026e04:	e0bff217 	ldw	r2,-56(fp)
20026e08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
20026e0c:	00800f04 	movi	r2,60
20026e10:	00005006 	br	20026f54 <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
20026e14:	e0fffd03 	ldbu	r3,-12(fp)
20026e18:	008800f4 	movhi	r2,8195
20026e1c:	1086b504 	addi	r2,r2,6868
20026e20:	18c7883a 	add	r3,r3,r3
20026e24:	18c7883a 	add	r3,r3,r3
20026e28:	10c5883a 	add	r2,r2,r3
20026e2c:	10800017 	ldw	r2,0(r2)
20026e30:	1000431e 	bne	r2,zero,20026f40 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
20026e34:	e0fffd03 	ldbu	r3,-12(fp)
20026e38:	008800f4 	movhi	r2,8195
20026e3c:	1086b504 	addi	r2,r2,6868
20026e40:	18c7883a 	add	r3,r3,r3
20026e44:	18c7883a 	add	r3,r3,r3
20026e48:	10c5883a 	add	r2,r2,r3
20026e4c:	00c00044 	movi	r3,1
20026e50:	10c00015 	stw	r3,0(r2)
20026e54:	e0bff117 	ldw	r2,-60(fp)
20026e58:	e0bff315 	stw	r2,-52(fp)
20026e5c:	e0bff317 	ldw	r2,-52(fp)
20026e60:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
20026e64:	e0bfff0b 	ldhu	r2,-4(fp)
20026e68:	100d883a 	mov	r6,r2
20026e6c:	e1400417 	ldw	r5,16(fp)
20026e70:	e1000317 	ldw	r4,12(fp)
20026e74:	0027de40 	call	20027de4 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
20026e78:	e0bfff0b 	ldhu	r2,-4(fp)
20026e7c:	100f883a 	mov	r7,r2
20026e80:	e1bffc17 	ldw	r6,-16(fp)
20026e84:	e17ffb17 	ldw	r5,-20(fp)
20026e88:	e13ffa17 	ldw	r4,-24(fp)
20026e8c:	002a2a40 	call	2002a2a4 <OSTaskStkInit>
20026e90:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
20026e94:	e0fffd03 	ldbu	r3,-12(fp)
20026e98:	e13ffe0b 	ldhu	r4,-8(fp)
20026e9c:	e0bfff0b 	ldhu	r2,-4(fp)
20026ea0:	d8800215 	stw	r2,8(sp)
20026ea4:	e0800517 	ldw	r2,20(fp)
20026ea8:	d8800115 	stw	r2,4(sp)
20026eac:	e0800417 	ldw	r2,16(fp)
20026eb0:	d8800015 	stw	r2,0(sp)
20026eb4:	200f883a 	mov	r7,r4
20026eb8:	e1800317 	ldw	r6,12(fp)
20026ebc:	e17ff517 	ldw	r5,-44(fp)
20026ec0:	1809883a 	mov	r4,r3
20026ec4:	00228b80 	call	200228b8 <OS_TCBInit>
20026ec8:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
20026ecc:	e0bff603 	ldbu	r2,-40(fp)
20026ed0:	1000061e 	bne	r2,zero,20026eec <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
20026ed4:	d0a5f643 	ldbu	r2,-26663(gp)
20026ed8:	10803fcc 	andi	r2,r2,255
20026edc:	10800058 	cmpnei	r2,r2,1
20026ee0:	1000151e 	bne	r2,zero,20026f38 <OSTaskCreateExt+0x1b4>
                OS_Sched();
20026ee4:	00224b80 	call	200224b8 <OS_Sched>
20026ee8:	00001306 	br	20026f38 <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026eec:	0005303a 	rdctl	r2,status
20026ef0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026ef4:	e0fff817 	ldw	r3,-32(fp)
20026ef8:	00bfff84 	movi	r2,-2
20026efc:	1884703a 	and	r2,r3,r2
20026f00:	1001703a 	wrctl	status,r2
  
  return context;
20026f04:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
20026f08:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
20026f0c:	e0fffd03 	ldbu	r3,-12(fp)
20026f10:	008800f4 	movhi	r2,8195
20026f14:	1086b504 	addi	r2,r2,6868
20026f18:	18c7883a 	add	r3,r3,r3
20026f1c:	18c7883a 	add	r3,r3,r3
20026f20:	10c5883a 	add	r2,r2,r3
20026f24:	10000015 	stw	zero,0(r2)
20026f28:	e0bff117 	ldw	r2,-60(fp)
20026f2c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20026f30:	e0bff417 	ldw	r2,-48(fp)
20026f34:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
20026f38:	e0bff603 	ldbu	r2,-40(fp)
20026f3c:	00000506 	br	20026f54 <OSTaskCreateExt+0x1d0>
20026f40:	e0bff117 	ldw	r2,-60(fp)
20026f44:	e0bff715 	stw	r2,-36(fp)
20026f48:	e0bff717 	ldw	r2,-36(fp)
20026f4c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
20026f50:	00800a04 	movi	r2,40
}
20026f54:	e037883a 	mov	sp,fp
20026f58:	dfc00117 	ldw	ra,4(sp)
20026f5c:	df000017 	ldw	fp,0(sp)
20026f60:	dec00204 	addi	sp,sp,8
20026f64:	f800283a 	ret

20026f68 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
20026f68:	defff404 	addi	sp,sp,-48
20026f6c:	dfc00b15 	stw	ra,44(sp)
20026f70:	df000a15 	stw	fp,40(sp)
20026f74:	df000a04 	addi	fp,sp,40
20026f78:	2005883a 	mov	r2,r4
20026f7c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
20026f80:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
20026f84:	d0a60403 	ldbu	r2,-26608(gp)
20026f88:	10803fcc 	andi	r2,r2,255
20026f8c:	10000226 	beq	r2,zero,20026f98 <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
20026f90:	00801004 	movi	r2,64
20026f94:	0000c006 	br	20027298 <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
20026f98:	e0bfff03 	ldbu	r2,-4(fp)
20026f9c:	10800518 	cmpnei	r2,r2,20
20026fa0:	1000021e 	bne	r2,zero,20026fac <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
20026fa4:	00800f84 	movi	r2,62
20026fa8:	0000bb06 	br	20027298 <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
20026fac:	e0bfff03 	ldbu	r2,-4(fp)
20026fb0:	10800530 	cmpltui	r2,r2,20
20026fb4:	1000051e 	bne	r2,zero,20026fcc <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
20026fb8:	e0bfff03 	ldbu	r2,-4(fp)
20026fbc:	10803fe0 	cmpeqi	r2,r2,255
20026fc0:	1000021e 	bne	r2,zero,20026fcc <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
20026fc4:	00800a84 	movi	r2,42
20026fc8:	0000b306 	br	20027298 <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20026fcc:	0005303a 	rdctl	r2,status
20026fd0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20026fd4:	e0fffe17 	ldw	r3,-8(fp)
20026fd8:	00bfff84 	movi	r2,-2
20026fdc:	1884703a 	and	r2,r3,r2
20026fe0:	1001703a 	wrctl	status,r2
  
  return context;
20026fe4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
20026fe8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
20026fec:	e0bfff03 	ldbu	r2,-4(fp)
20026ff0:	10803fd8 	cmpnei	r2,r2,255
20026ff4:	1000031e 	bne	r2,zero,20027004 <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
20026ff8:	d0a60517 	ldw	r2,-26604(gp)
20026ffc:	10800c83 	ldbu	r2,50(r2)
20027000:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
20027004:	e0ffff03 	ldbu	r3,-4(fp)
20027008:	008800f4 	movhi	r2,8195
2002700c:	1086b504 	addi	r2,r2,6868
20027010:	18c7883a 	add	r3,r3,r3
20027014:	18c7883a 	add	r3,r3,r3
20027018:	10c5883a 	add	r2,r2,r3
2002701c:	10800017 	ldw	r2,0(r2)
20027020:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
20027024:	e0bff817 	ldw	r2,-32(fp)
20027028:	1000061e 	bne	r2,zero,20027044 <OSTaskDel+0xdc>
2002702c:	e0bff617 	ldw	r2,-40(fp)
20027030:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027034:	e0bff717 	ldw	r2,-36(fp)
20027038:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
2002703c:	008010c4 	movi	r2,67
20027040:	00009506 	br	20027298 <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
20027044:	e0bff817 	ldw	r2,-32(fp)
20027048:	10800058 	cmpnei	r2,r2,1
2002704c:	1000061e 	bne	r2,zero,20027068 <OSTaskDel+0x100>
20027050:	e0bff617 	ldw	r2,-40(fp)
20027054:	e0bff915 	stw	r2,-28(fp)
20027058:	e0bff917 	ldw	r2,-28(fp)
2002705c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
20027060:	00800f44 	movi	r2,61
20027064:	00008c06 	br	20027298 <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
20027068:	e0bff817 	ldw	r2,-32(fp)
2002706c:	10800d03 	ldbu	r2,52(r2)
20027070:	10c03fcc 	andi	r3,r2,255
20027074:	e0bff817 	ldw	r2,-32(fp)
20027078:	10800d03 	ldbu	r2,52(r2)
2002707c:	11003fcc 	andi	r4,r2,255
20027080:	d0a60244 	addi	r2,gp,-26615
20027084:	2085883a 	add	r2,r4,r2
20027088:	10800003 	ldbu	r2,0(r2)
2002708c:	1009883a 	mov	r4,r2
20027090:	e0bff817 	ldw	r2,-32(fp)
20027094:	10800d43 	ldbu	r2,53(r2)
20027098:	0084303a 	nor	r2,zero,r2
2002709c:	2084703a 	and	r2,r4,r2
200270a0:	1009883a 	mov	r4,r2
200270a4:	d0a60244 	addi	r2,gp,-26615
200270a8:	1885883a 	add	r2,r3,r2
200270ac:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
200270b0:	e0bff817 	ldw	r2,-32(fp)
200270b4:	10800d03 	ldbu	r2,52(r2)
200270b8:	10c03fcc 	andi	r3,r2,255
200270bc:	d0a60244 	addi	r2,gp,-26615
200270c0:	1885883a 	add	r2,r3,r2
200270c4:	10800003 	ldbu	r2,0(r2)
200270c8:	10803fcc 	andi	r2,r2,255
200270cc:	1000071e 	bne	r2,zero,200270ec <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
200270d0:	e0bff817 	ldw	r2,-32(fp)
200270d4:	10800d83 	ldbu	r2,54(r2)
200270d8:	0084303a 	nor	r2,zero,r2
200270dc:	1007883a 	mov	r3,r2
200270e0:	d0a60203 	ldbu	r2,-26616(gp)
200270e4:	1884703a 	and	r2,r3,r2
200270e8:	d0a60205 	stb	r2,-26616(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
200270ec:	e0bff817 	ldw	r2,-32(fp)
200270f0:	10800717 	ldw	r2,28(r2)
200270f4:	10000526 	beq	r2,zero,2002710c <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
200270f8:	e0bff817 	ldw	r2,-32(fp)
200270fc:	10800717 	ldw	r2,28(r2)
20027100:	100b883a 	mov	r5,r2
20027104:	e13ff817 	ldw	r4,-32(fp)
20027108:	0021e640 	call	20021e64 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
2002710c:	e0bff817 	ldw	r2,-32(fp)
20027110:	10800817 	ldw	r2,32(r2)
20027114:	10000526 	beq	r2,zero,2002712c <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
20027118:	e0bff817 	ldw	r2,-32(fp)
2002711c:	10800817 	ldw	r2,32(r2)
20027120:	100b883a 	mov	r5,r2
20027124:	e13ff817 	ldw	r4,-32(fp)
20027128:	0021f1c0 	call	20021f1c <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
2002712c:	e0bff817 	ldw	r2,-32(fp)
20027130:	10800a17 	ldw	r2,40(r2)
20027134:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
20027138:	e0bffb17 	ldw	r2,-20(fp)
2002713c:	10000226 	beq	r2,zero,20027148 <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
20027140:	e13ffb17 	ldw	r4,-20(fp)
20027144:	002438c0 	call	2002438c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
20027148:	e0bff817 	ldw	r2,-32(fp)
2002714c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
20027150:	e0bff817 	ldw	r2,-32(fp)
20027154:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
20027158:	e0bff817 	ldw	r2,-32(fp)
2002715c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
20027160:	d0a5f603 	ldbu	r2,-26664(gp)
20027164:	10803fcc 	andi	r2,r2,255
20027168:	10803fe0 	cmpeqi	r2,r2,255
2002716c:	1000031e 	bne	r2,zero,2002717c <OSTaskDel+0x214>
        OSLockNesting++;
20027170:	d0a5f603 	ldbu	r2,-26664(gp)
20027174:	10800044 	addi	r2,r2,1
20027178:	d0a5f605 	stb	r2,-26664(gp)
2002717c:	e0bff617 	ldw	r2,-40(fp)
20027180:	e0bffd15 	stw	r2,-12(fp)
20027184:	e0bffd17 	ldw	r2,-12(fp)
20027188:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
2002718c:	0021a4c0 	call	20021a4c <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027190:	0005303a 	rdctl	r2,status
20027194:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027198:	e0fffa17 	ldw	r3,-24(fp)
2002719c:	00bfff84 	movi	r2,-2
200271a0:	1884703a 	and	r2,r3,r2
200271a4:	1001703a 	wrctl	status,r2
  
  return context;
200271a8:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
200271ac:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
200271b0:	d0a5f603 	ldbu	r2,-26664(gp)
200271b4:	10803fcc 	andi	r2,r2,255
200271b8:	10000326 	beq	r2,zero,200271c8 <OSTaskDel+0x260>
        OSLockNesting--;
200271bc:	d0a5f603 	ldbu	r2,-26664(gp)
200271c0:	10bfffc4 	addi	r2,r2,-1
200271c4:	d0a5f605 	stb	r2,-26664(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
200271c8:	e13ff817 	ldw	r4,-32(fp)
200271cc:	002a4240 	call	2002a424 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
200271d0:	d0a5fe43 	ldbu	r2,-26631(gp)
200271d4:	10bfffc4 	addi	r2,r2,-1
200271d8:	d0a5fe45 	stb	r2,-26631(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
200271dc:	e0ffff03 	ldbu	r3,-4(fp)
200271e0:	008800f4 	movhi	r2,8195
200271e4:	1086b504 	addi	r2,r2,6868
200271e8:	18c7883a 	add	r3,r3,r3
200271ec:	18c7883a 	add	r3,r3,r3
200271f0:	10c5883a 	add	r2,r2,r3
200271f4:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
200271f8:	e0bff817 	ldw	r2,-32(fp)
200271fc:	10800617 	ldw	r2,24(r2)
20027200:	1000071e 	bne	r2,zero,20027220 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
20027204:	e0bff817 	ldw	r2,-32(fp)
20027208:	10800517 	ldw	r2,20(r2)
2002720c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
20027210:	e0bff817 	ldw	r2,-32(fp)
20027214:	10800517 	ldw	r2,20(r2)
20027218:	d0a5f915 	stw	r2,-26652(gp)
2002721c:	00000a06 	br	20027248 <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
20027220:	e0bff817 	ldw	r2,-32(fp)
20027224:	10800617 	ldw	r2,24(r2)
20027228:	e0fff817 	ldw	r3,-32(fp)
2002722c:	18c00517 	ldw	r3,20(r3)
20027230:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
20027234:	e0bff817 	ldw	r2,-32(fp)
20027238:	10800517 	ldw	r2,20(r2)
2002723c:	e0fff817 	ldw	r3,-32(fp)
20027240:	18c00617 	ldw	r3,24(r3)
20027244:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
20027248:	d0e5fd17 	ldw	r3,-26636(gp)
2002724c:	e0bff817 	ldw	r2,-32(fp)
20027250:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
20027254:	e0bff817 	ldw	r2,-32(fp)
20027258:	d0a5fd15 	stw	r2,-26636(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
2002725c:	e0bff817 	ldw	r2,-32(fp)
20027260:	00c00fc4 	movi	r3,63
20027264:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
20027268:	e0bff817 	ldw	r2,-32(fp)
2002726c:	10001345 	stb	zero,77(r2)
20027270:	e0bff617 	ldw	r2,-40(fp)
20027274:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027278:	e0bffc17 	ldw	r2,-16(fp)
2002727c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
20027280:	d0a5f643 	ldbu	r2,-26663(gp)
20027284:	10803fcc 	andi	r2,r2,255
20027288:	10800058 	cmpnei	r2,r2,1
2002728c:	1000011e 	bne	r2,zero,20027294 <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
20027290:	00224b80 	call	200224b8 <OS_Sched>
    }
    return (OS_ERR_NONE);
20027294:	0005883a 	mov	r2,zero
}
20027298:	e037883a 	mov	sp,fp
2002729c:	dfc00117 	ldw	ra,4(sp)
200272a0:	df000017 	ldw	fp,0(sp)
200272a4:	dec00204 	addi	sp,sp,8
200272a8:	f800283a 	ret

200272ac <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
200272ac:	defff504 	addi	sp,sp,-44
200272b0:	df000a15 	stw	fp,40(sp)
200272b4:	df000a04 	addi	fp,sp,40
200272b8:	2005883a 	mov	r2,r4
200272bc:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200272c0:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
200272c4:	e0bfff03 	ldbu	r2,-4(fp)
200272c8:	10800518 	cmpnei	r2,r2,20
200272cc:	1000021e 	bne	r2,zero,200272d8 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
200272d0:	00800f84 	movi	r2,62
200272d4:	00004506 	br	200273ec <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
200272d8:	e0bfff03 	ldbu	r2,-4(fp)
200272dc:	10800530 	cmpltui	r2,r2,20
200272e0:	1000051e 	bne	r2,zero,200272f8 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
200272e4:	e0bfff03 	ldbu	r2,-4(fp)
200272e8:	10803fe0 	cmpeqi	r2,r2,255
200272ec:	1000021e 	bne	r2,zero,200272f8 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
200272f0:	00800a84 	movi	r2,42
200272f4:	00003d06 	br	200273ec <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
200272f8:	e0bfff03 	ldbu	r2,-4(fp)
200272fc:	10803fd8 	cmpnei	r2,r2,255
20027300:	1000111e 	bne	r2,zero,20027348 <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027304:	0005303a 	rdctl	r2,status
20027308:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2002730c:	e0fff917 	ldw	r3,-28(fp)
20027310:	00bfff84 	movi	r2,-2
20027314:	1884703a 	and	r2,r3,r2
20027318:	1001703a 	wrctl	status,r2
  
  return context;
2002731c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
20027320:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
20027324:	d0a60517 	ldw	r2,-26604(gp)
20027328:	10800dc3 	ldbu	r2,55(r2)
2002732c:	e0bff805 	stb	r2,-32(fp)
20027330:	e0bff617 	ldw	r2,-40(fp)
20027334:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027338:	e0bffe17 	ldw	r2,-8(fp)
2002733c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
20027340:	e0bff803 	ldbu	r2,-32(fp)
20027344:	00002906 	br	200273ec <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027348:	0005303a 	rdctl	r2,status
2002734c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027350:	e0fff717 	ldw	r3,-36(fp)
20027354:	00bfff84 	movi	r2,-2
20027358:	1884703a 	and	r2,r3,r2
2002735c:	1001703a 	wrctl	status,r2
  
  return context;
20027360:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
20027364:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
20027368:	e0ffff03 	ldbu	r3,-4(fp)
2002736c:	008800f4 	movhi	r2,8195
20027370:	1086b504 	addi	r2,r2,6868
20027374:	18c7883a 	add	r3,r3,r3
20027378:	18c7883a 	add	r3,r3,r3
2002737c:	10c5883a 	add	r2,r2,r3
20027380:	10800017 	ldw	r2,0(r2)
20027384:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
20027388:	e0bffb17 	ldw	r2,-20(fp)
2002738c:	1000061e 	bne	r2,zero,200273a8 <OSTaskDelReq+0xfc>
20027390:	e0bff617 	ldw	r2,-40(fp)
20027394:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027398:	e0bffa17 	ldw	r2,-24(fp)
2002739c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
200273a0:	008010c4 	movi	r2,67
200273a4:	00001106 	br	200273ec <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
200273a8:	e0bffb17 	ldw	r2,-20(fp)
200273ac:	10800058 	cmpnei	r2,r2,1
200273b0:	1000061e 	bne	r2,zero,200273cc <OSTaskDelReq+0x120>
200273b4:	e0bff617 	ldw	r2,-40(fp)
200273b8:	e0bffc15 	stw	r2,-16(fp)
200273bc:	e0bffc17 	ldw	r2,-16(fp)
200273c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
200273c4:	00800f44 	movi	r2,61
200273c8:	00000806 	br	200273ec <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
200273cc:	e0bffb17 	ldw	r2,-20(fp)
200273d0:	00c00fc4 	movi	r3,63
200273d4:	10c00dc5 	stb	r3,55(r2)
200273d8:	e0bff617 	ldw	r2,-40(fp)
200273dc:	e0bffd15 	stw	r2,-12(fp)
200273e0:	e0bffd17 	ldw	r2,-12(fp)
200273e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
200273e8:	0005883a 	mov	r2,zero
}
200273ec:	e037883a 	mov	sp,fp
200273f0:	df000017 	ldw	fp,0(sp)
200273f4:	dec00104 	addi	sp,sp,4
200273f8:	f800283a 	ret

200273fc <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
200273fc:	defff404 	addi	sp,sp,-48
20027400:	dfc00b15 	stw	ra,44(sp)
20027404:	df000a15 	stw	fp,40(sp)
20027408:	df000a04 	addi	fp,sp,40
2002740c:	2005883a 	mov	r2,r4
20027410:	e17ffe15 	stw	r5,-8(fp)
20027414:	e1bfff15 	stw	r6,-4(fp)
20027418:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
2002741c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
20027420:	e0bfff17 	ldw	r2,-4(fp)
20027424:	1000021e 	bne	r2,zero,20027430 <OSTaskNameGet+0x34>
        return (0);
20027428:	0005883a 	mov	r2,zero
2002742c:	00005406 	br	20027580 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
20027430:	e0bffd03 	ldbu	r2,-12(fp)
20027434:	10800570 	cmpltui	r2,r2,21
20027438:	1000081e 	bne	r2,zero,2002745c <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
2002743c:	e0bffd03 	ldbu	r2,-12(fp)
20027440:	10803fe0 	cmpeqi	r2,r2,255
20027444:	1000051e 	bne	r2,zero,2002745c <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
20027448:	e0bfff17 	ldw	r2,-4(fp)
2002744c:	00c00a84 	movi	r3,42
20027450:	10c00005 	stb	r3,0(r2)
            return (0);
20027454:	0005883a 	mov	r2,zero
20027458:	00004906 	br	20027580 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
2002745c:	e0bffe17 	ldw	r2,-8(fp)
20027460:	1000051e 	bne	r2,zero,20027478 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
20027464:	e0bfff17 	ldw	r2,-4(fp)
20027468:	00c00304 	movi	r3,12
2002746c:	10c00005 	stb	r3,0(r2)
        return (0);
20027470:	0005883a 	mov	r2,zero
20027474:	00004206 	br	20027580 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
20027478:	d0a60403 	ldbu	r2,-26608(gp)
2002747c:	10803fcc 	andi	r2,r2,255
20027480:	10000526 	beq	r2,zero,20027498 <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
20027484:	e0bfff17 	ldw	r2,-4(fp)
20027488:	00c00444 	movi	r3,17
2002748c:	10c00005 	stb	r3,0(r2)
        return (0);
20027490:	0005883a 	mov	r2,zero
20027494:	00003a06 	br	20027580 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027498:	0005303a 	rdctl	r2,status
2002749c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200274a0:	e0fffc17 	ldw	r3,-16(fp)
200274a4:	00bfff84 	movi	r2,-2
200274a8:	1884703a 	and	r2,r3,r2
200274ac:	1001703a 	wrctl	status,r2
  
  return context;
200274b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
200274b4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
200274b8:	e0bffd03 	ldbu	r2,-12(fp)
200274bc:	10803fd8 	cmpnei	r2,r2,255
200274c0:	1000031e 	bne	r2,zero,200274d0 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
200274c4:	d0a60517 	ldw	r2,-26604(gp)
200274c8:	10800c83 	ldbu	r2,50(r2)
200274cc:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
200274d0:	e0fffd03 	ldbu	r3,-12(fp)
200274d4:	008800f4 	movhi	r2,8195
200274d8:	1086b504 	addi	r2,r2,6868
200274dc:	18c7883a 	add	r3,r3,r3
200274e0:	18c7883a 	add	r3,r3,r3
200274e4:	10c5883a 	add	r2,r2,r3
200274e8:	10800017 	ldw	r2,0(r2)
200274ec:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
200274f0:	e0bff817 	ldw	r2,-32(fp)
200274f4:	1000091e 	bne	r2,zero,2002751c <OSTaskNameGet+0x120>
200274f8:	e0bff617 	ldw	r2,-40(fp)
200274fc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027500:	e0bff717 	ldw	r2,-36(fp)
20027504:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
20027508:	e0bfff17 	ldw	r2,-4(fp)
2002750c:	00c010c4 	movi	r3,67
20027510:	10c00005 	stb	r3,0(r2)
        return (0);
20027514:	0005883a 	mov	r2,zero
20027518:	00001906 	br	20027580 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
2002751c:	e0bff817 	ldw	r2,-32(fp)
20027520:	10800058 	cmpnei	r2,r2,1
20027524:	1000091e 	bne	r2,zero,2002754c <OSTaskNameGet+0x150>
20027528:	e0bff617 	ldw	r2,-40(fp)
2002752c:	e0bff915 	stw	r2,-28(fp)
20027530:	e0bff917 	ldw	r2,-28(fp)
20027534:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
20027538:	e0bfff17 	ldw	r2,-4(fp)
2002753c:	00c010c4 	movi	r3,67
20027540:	10c00005 	stb	r3,0(r2)
        return (0);
20027544:	0005883a 	mov	r2,zero
20027548:	00000d06 	br	20027580 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
2002754c:	e0bff817 	ldw	r2,-32(fp)
20027550:	10801304 	addi	r2,r2,76
20027554:	100b883a 	mov	r5,r2
20027558:	e13ffe17 	ldw	r4,-8(fp)
2002755c:	00225fc0 	call	200225fc <OS_StrCopy>
20027560:	e0bffb05 	stb	r2,-20(fp)
20027564:	e0bff617 	ldw	r2,-40(fp)
20027568:	e0bffa15 	stw	r2,-24(fp)
2002756c:	e0bffa17 	ldw	r2,-24(fp)
20027570:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20027574:	e0bfff17 	ldw	r2,-4(fp)
20027578:	10000005 	stb	zero,0(r2)
    return (len);
2002757c:	e0bffb03 	ldbu	r2,-20(fp)
}
20027580:	e037883a 	mov	sp,fp
20027584:	dfc00117 	ldw	ra,4(sp)
20027588:	df000017 	ldw	fp,0(sp)
2002758c:	dec00204 	addi	sp,sp,8
20027590:	f800283a 	ret

20027594 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
20027594:	defff304 	addi	sp,sp,-52
20027598:	dfc00c15 	stw	ra,48(sp)
2002759c:	df000b15 	stw	fp,44(sp)
200275a0:	df000b04 	addi	fp,sp,44
200275a4:	2005883a 	mov	r2,r4
200275a8:	e17ffe15 	stw	r5,-8(fp)
200275ac:	e1bfff15 	stw	r6,-4(fp)
200275b0:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
200275b4:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
200275b8:	e0bfff17 	ldw	r2,-4(fp)
200275bc:	10005c26 	beq	r2,zero,20027730 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
200275c0:	e0bffd03 	ldbu	r2,-12(fp)
200275c4:	10800570 	cmpltui	r2,r2,21
200275c8:	1000071e 	bne	r2,zero,200275e8 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
200275cc:	e0bffd03 	ldbu	r2,-12(fp)
200275d0:	10803fe0 	cmpeqi	r2,r2,255
200275d4:	1000041e 	bne	r2,zero,200275e8 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
200275d8:	e0bfff17 	ldw	r2,-4(fp)
200275dc:	00c00a84 	movi	r3,42
200275e0:	10c00005 	stb	r3,0(r2)
            return;
200275e4:	00005306 	br	20027734 <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
200275e8:	e0bffe17 	ldw	r2,-8(fp)
200275ec:	1000041e 	bne	r2,zero,20027600 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
200275f0:	e0bfff17 	ldw	r2,-4(fp)
200275f4:	00c00304 	movi	r3,12
200275f8:	10c00005 	stb	r3,0(r2)
        return;
200275fc:	00004d06 	br	20027734 <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
20027600:	d0a60403 	ldbu	r2,-26608(gp)
20027604:	10803fcc 	andi	r2,r2,255
20027608:	10000426 	beq	r2,zero,2002761c <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
2002760c:	e0bfff17 	ldw	r2,-4(fp)
20027610:	00c00484 	movi	r3,18
20027614:	10c00005 	stb	r3,0(r2)
        return;
20027618:	00004606 	br	20027734 <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002761c:	0005303a 	rdctl	r2,status
20027620:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027624:	e0fffc17 	ldw	r3,-16(fp)
20027628:	00bfff84 	movi	r2,-2
2002762c:	1884703a 	and	r2,r3,r2
20027630:	1001703a 	wrctl	status,r2
  
  return context;
20027634:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
20027638:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
2002763c:	e0bffd03 	ldbu	r2,-12(fp)
20027640:	10803fd8 	cmpnei	r2,r2,255
20027644:	1000031e 	bne	r2,zero,20027654 <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
20027648:	d0a60517 	ldw	r2,-26604(gp)
2002764c:	10800c83 	ldbu	r2,50(r2)
20027650:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
20027654:	e0fffd03 	ldbu	r3,-12(fp)
20027658:	008800f4 	movhi	r2,8195
2002765c:	1086b504 	addi	r2,r2,6868
20027660:	18c7883a 	add	r3,r3,r3
20027664:	18c7883a 	add	r3,r3,r3
20027668:	10c5883a 	add	r2,r2,r3
2002766c:	10800017 	ldw	r2,0(r2)
20027670:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
20027674:	e0bff717 	ldw	r2,-36(fp)
20027678:	1000081e 	bne	r2,zero,2002769c <OSTaskNameSet+0x108>
2002767c:	e0bff517 	ldw	r2,-44(fp)
20027680:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027684:	e0bff617 	ldw	r2,-40(fp)
20027688:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
2002768c:	e0bfff17 	ldw	r2,-4(fp)
20027690:	00c010c4 	movi	r3,67
20027694:	10c00005 	stb	r3,0(r2)
        return;
20027698:	00002606 	br	20027734 <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
2002769c:	e0bff717 	ldw	r2,-36(fp)
200276a0:	10800058 	cmpnei	r2,r2,1
200276a4:	1000081e 	bne	r2,zero,200276c8 <OSTaskNameSet+0x134>
200276a8:	e0bff517 	ldw	r2,-44(fp)
200276ac:	e0bff815 	stw	r2,-32(fp)
200276b0:	e0bff817 	ldw	r2,-32(fp)
200276b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
200276b8:	e0bfff17 	ldw	r2,-4(fp)
200276bc:	00c010c4 	movi	r3,67
200276c0:	10c00005 	stb	r3,0(r2)
        return;
200276c4:	00001b06 	br	20027734 <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
200276c8:	e13ffe17 	ldw	r4,-8(fp)
200276cc:	00226700 	call	20022670 <OS_StrLen>
200276d0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
200276d4:	e0bffa03 	ldbu	r2,-24(fp)
200276d8:	10800830 	cmpltui	r2,r2,32
200276dc:	1000081e 	bne	r2,zero,20027700 <OSTaskNameSet+0x16c>
200276e0:	e0bff517 	ldw	r2,-44(fp)
200276e4:	e0bff915 	stw	r2,-28(fp)
200276e8:	e0bff917 	ldw	r2,-28(fp)
200276ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
200276f0:	e0bfff17 	ldw	r2,-4(fp)
200276f4:	00c01044 	movi	r3,65
200276f8:	10c00005 	stb	r3,0(r2)
        return;
200276fc:	00000d06 	br	20027734 <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
20027700:	e0bff717 	ldw	r2,-36(fp)
20027704:	10801304 	addi	r2,r2,76
20027708:	e17ffe17 	ldw	r5,-8(fp)
2002770c:	1009883a 	mov	r4,r2
20027710:	00225fc0 	call	200225fc <OS_StrCopy>
20027714:	e0bff517 	ldw	r2,-44(fp)
20027718:	e0bffb15 	stw	r2,-20(fp)
2002771c:	e0bffb17 	ldw	r2,-20(fp)
20027720:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20027724:	e0bfff17 	ldw	r2,-4(fp)
20027728:	10000005 	stb	zero,0(r2)
2002772c:	00000106 	br	20027734 <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
20027730:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
20027734:	e037883a 	mov	sp,fp
20027738:	dfc00117 	ldw	ra,4(sp)
2002773c:	df000017 	ldw	fp,0(sp)
20027740:	dec00204 	addi	sp,sp,8
20027744:	f800283a 	ret

20027748 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
20027748:	defff404 	addi	sp,sp,-48
2002774c:	dfc00b15 	stw	ra,44(sp)
20027750:	df000a15 	stw	fp,40(sp)
20027754:	df000a04 	addi	fp,sp,40
20027758:	2005883a 	mov	r2,r4
2002775c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
20027760:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
20027764:	e0bfff03 	ldbu	r2,-4(fp)
20027768:	10800530 	cmpltui	r2,r2,20
2002776c:	1000021e 	bne	r2,zero,20027778 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
20027770:	00800a84 	movi	r2,42
20027774:	00006406 	br	20027908 <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027778:	0005303a 	rdctl	r2,status
2002777c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027780:	e0fffe17 	ldw	r3,-8(fp)
20027784:	00bfff84 	movi	r2,-2
20027788:	1884703a 	and	r2,r3,r2
2002778c:	1001703a 	wrctl	status,r2
  
  return context;
20027790:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
20027794:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
20027798:	e0ffff03 	ldbu	r3,-4(fp)
2002779c:	008800f4 	movhi	r2,8195
200277a0:	1086b504 	addi	r2,r2,6868
200277a4:	18c7883a 	add	r3,r3,r3
200277a8:	18c7883a 	add	r3,r3,r3
200277ac:	10c5883a 	add	r2,r2,r3
200277b0:	10800017 	ldw	r2,0(r2)
200277b4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
200277b8:	e0bff817 	ldw	r2,-32(fp)
200277bc:	1000061e 	bne	r2,zero,200277d8 <OSTaskResume+0x90>
200277c0:	e0bff617 	ldw	r2,-40(fp)
200277c4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200277c8:	e0bff717 	ldw	r2,-36(fp)
200277cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
200277d0:	00801184 	movi	r2,70
200277d4:	00004c06 	br	20027908 <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
200277d8:	e0bff817 	ldw	r2,-32(fp)
200277dc:	10800058 	cmpnei	r2,r2,1
200277e0:	1000061e 	bne	r2,zero,200277fc <OSTaskResume+0xb4>
200277e4:	e0bff617 	ldw	r2,-40(fp)
200277e8:	e0bff915 	stw	r2,-28(fp)
200277ec:	e0bff917 	ldw	r2,-28(fp)
200277f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
200277f4:	008010c4 	movi	r2,67
200277f8:	00004306 	br	20027908 <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
200277fc:	e0bff817 	ldw	r2,-32(fp)
20027800:	10800c03 	ldbu	r2,48(r2)
20027804:	10803fcc 	andi	r2,r2,255
20027808:	1080020c 	andi	r2,r2,8
2002780c:	10003926 	beq	r2,zero,200278f4 <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
20027810:	e0bff817 	ldw	r2,-32(fp)
20027814:	10c00c03 	ldbu	r3,48(r2)
20027818:	00bffdc4 	movi	r2,-9
2002781c:	1884703a 	and	r2,r3,r2
20027820:	1007883a 	mov	r3,r2
20027824:	e0bff817 	ldw	r2,-32(fp)
20027828:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
2002782c:	e0bff817 	ldw	r2,-32(fp)
20027830:	10800c03 	ldbu	r2,48(r2)
20027834:	10803fcc 	andi	r2,r2,255
20027838:	1000281e 	bne	r2,zero,200278dc <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
2002783c:	e0bff817 	ldw	r2,-32(fp)
20027840:	10800b8b 	ldhu	r2,46(r2)
20027844:	10bfffcc 	andi	r2,r2,65535
20027848:	10001f1e 	bne	r2,zero,200278c8 <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
2002784c:	e0bff817 	ldw	r2,-32(fp)
20027850:	10c00d83 	ldbu	r3,54(r2)
20027854:	d0a60203 	ldbu	r2,-26616(gp)
20027858:	1884b03a 	or	r2,r3,r2
2002785c:	d0a60205 	stb	r2,-26616(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
20027860:	e0bff817 	ldw	r2,-32(fp)
20027864:	10800d03 	ldbu	r2,52(r2)
20027868:	10c03fcc 	andi	r3,r2,255
2002786c:	e0bff817 	ldw	r2,-32(fp)
20027870:	10800d03 	ldbu	r2,52(r2)
20027874:	11003fcc 	andi	r4,r2,255
20027878:	d0a60244 	addi	r2,gp,-26615
2002787c:	2085883a 	add	r2,r4,r2
20027880:	11000003 	ldbu	r4,0(r2)
20027884:	e0bff817 	ldw	r2,-32(fp)
20027888:	10800d43 	ldbu	r2,53(r2)
2002788c:	2084b03a 	or	r2,r4,r2
20027890:	1009883a 	mov	r4,r2
20027894:	d0a60244 	addi	r2,gp,-26615
20027898:	1885883a 	add	r2,r3,r2
2002789c:	11000005 	stb	r4,0(r2)
200278a0:	e0bff617 	ldw	r2,-40(fp)
200278a4:	e0bffa15 	stw	r2,-24(fp)
200278a8:	e0bffa17 	ldw	r2,-24(fp)
200278ac:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
200278b0:	d0a5f643 	ldbu	r2,-26663(gp)
200278b4:	10803fcc 	andi	r2,r2,255
200278b8:	10800058 	cmpnei	r2,r2,1
200278bc:	10000b1e 	bne	r2,zero,200278ec <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
200278c0:	00224b80 	call	200224b8 <OS_Sched>
200278c4:	00000906 	br	200278ec <OSTaskResume+0x1a4>
200278c8:	e0bff617 	ldw	r2,-40(fp)
200278cc:	e0bffb15 	stw	r2,-20(fp)
200278d0:	e0bffb17 	ldw	r2,-20(fp)
200278d4:	1001703a 	wrctl	status,r2
200278d8:	00000406 	br	200278ec <OSTaskResume+0x1a4>
200278dc:	e0bff617 	ldw	r2,-40(fp)
200278e0:	e0bffc15 	stw	r2,-16(fp)
200278e4:	e0bffc17 	ldw	r2,-16(fp)
200278e8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
200278ec:	0005883a 	mov	r2,zero
200278f0:	00000506 	br	20027908 <OSTaskResume+0x1c0>
200278f4:	e0bff617 	ldw	r2,-40(fp)
200278f8:	e0bffd15 	stw	r2,-12(fp)
200278fc:	e0bffd17 	ldw	r2,-12(fp)
20027900:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
20027904:	00801104 	movi	r2,68
}
20027908:	e037883a 	mov	sp,fp
2002790c:	dfc00117 	ldw	ra,4(sp)
20027910:	df000017 	ldw	fp,0(sp)
20027914:	dec00204 	addi	sp,sp,8
20027918:	f800283a 	ret

2002791c <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
2002791c:	defff304 	addi	sp,sp,-52
20027920:	df000c15 	stw	fp,48(sp)
20027924:	df000c04 	addi	fp,sp,48
20027928:	2005883a 	mov	r2,r4
2002792c:	e17fff15 	stw	r5,-4(fp)
20027930:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
20027934:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
20027938:	e0bffe03 	ldbu	r2,-8(fp)
2002793c:	10800570 	cmpltui	r2,r2,21
20027940:	1000051e 	bne	r2,zero,20027958 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
20027944:	e0bffe03 	ldbu	r2,-8(fp)
20027948:	10803fe0 	cmpeqi	r2,r2,255
2002794c:	1000021e 	bne	r2,zero,20027958 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
20027950:	00800a84 	movi	r2,42
20027954:	00005d06 	br	20027acc <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
20027958:	e0bfff17 	ldw	r2,-4(fp)
2002795c:	1000021e 	bne	r2,zero,20027968 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
20027960:	00800244 	movi	r2,9
20027964:	00005906 	br	20027acc <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
20027968:	e0bfff17 	ldw	r2,-4(fp)
2002796c:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
20027970:	e0bfff17 	ldw	r2,-4(fp)
20027974:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027978:	0005303a 	rdctl	r2,status
2002797c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027980:	e0fffd17 	ldw	r3,-12(fp)
20027984:	00bfff84 	movi	r2,-2
20027988:	1884703a 	and	r2,r3,r2
2002798c:	1001703a 	wrctl	status,r2
  
  return context;
20027990:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
20027994:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
20027998:	e0bffe03 	ldbu	r2,-8(fp)
2002799c:	10803fd8 	cmpnei	r2,r2,255
200279a0:	1000031e 	bne	r2,zero,200279b0 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
200279a4:	d0a60517 	ldw	r2,-26604(gp)
200279a8:	10800c83 	ldbu	r2,50(r2)
200279ac:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
200279b0:	e0fffe03 	ldbu	r3,-8(fp)
200279b4:	008800f4 	movhi	r2,8195
200279b8:	1086b504 	addi	r2,r2,6868
200279bc:	18c7883a 	add	r3,r3,r3
200279c0:	18c7883a 	add	r3,r3,r3
200279c4:	10c5883a 	add	r2,r2,r3
200279c8:	10800017 	ldw	r2,0(r2)
200279cc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
200279d0:	e0bff817 	ldw	r2,-32(fp)
200279d4:	1000061e 	bne	r2,zero,200279f0 <OSTaskStkChk+0xd4>
200279d8:	e0bff617 	ldw	r2,-40(fp)
200279dc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200279e0:	e0bff717 	ldw	r2,-36(fp)
200279e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
200279e8:	008010c4 	movi	r2,67
200279ec:	00003706 	br	20027acc <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
200279f0:	e0bff817 	ldw	r2,-32(fp)
200279f4:	10800058 	cmpnei	r2,r2,1
200279f8:	1000061e 	bne	r2,zero,20027a14 <OSTaskStkChk+0xf8>
200279fc:	e0bff617 	ldw	r2,-40(fp)
20027a00:	e0bff915 	stw	r2,-28(fp)
20027a04:	e0bff917 	ldw	r2,-28(fp)
20027a08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
20027a0c:	008010c4 	movi	r2,67
20027a10:	00002e06 	br	20027acc <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
20027a14:	e0bff817 	ldw	r2,-32(fp)
20027a18:	1080040b 	ldhu	r2,16(r2)
20027a1c:	10bfffcc 	andi	r2,r2,65535
20027a20:	1080004c 	andi	r2,r2,1
20027a24:	1000061e 	bne	r2,zero,20027a40 <OSTaskStkChk+0x124>
20027a28:	e0bff617 	ldw	r2,-40(fp)
20027a2c:	e0bffa15 	stw	r2,-24(fp)
20027a30:	e0bffa17 	ldw	r2,-24(fp)
20027a34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
20027a38:	00801144 	movi	r2,69
20027a3c:	00002306 	br	20027acc <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
20027a40:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
20027a44:	e0bff817 	ldw	r2,-32(fp)
20027a48:	10800317 	ldw	r2,12(r2)
20027a4c:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
20027a50:	e0bff817 	ldw	r2,-32(fp)
20027a54:	10800217 	ldw	r2,8(r2)
20027a58:	e0bff415 	stw	r2,-48(fp)
20027a5c:	e0bff617 	ldw	r2,-40(fp)
20027a60:	e0bffb15 	stw	r2,-20(fp)
20027a64:	e0bffb17 	ldw	r2,-20(fp)
20027a68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
20027a6c:	00000306 	br	20027a7c <OSTaskStkChk+0x160>
        nfree++;
20027a70:	e0bff517 	ldw	r2,-44(fp)
20027a74:	10800044 	addi	r2,r2,1
20027a78:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
20027a7c:	e0bff417 	ldw	r2,-48(fp)
20027a80:	10c00104 	addi	r3,r2,4
20027a84:	e0fff415 	stw	r3,-48(fp)
20027a88:	10800017 	ldw	r2,0(r2)
20027a8c:	103ff826 	beq	r2,zero,20027a70 <__alt_data_end+0xfffe7a70>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
20027a90:	e0bff517 	ldw	r2,-44(fp)
20027a94:	1085883a 	add	r2,r2,r2
20027a98:	1085883a 	add	r2,r2,r2
20027a9c:	1007883a 	mov	r3,r2
20027aa0:	e0bfff17 	ldw	r2,-4(fp)
20027aa4:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
20027aa8:	e0fffc17 	ldw	r3,-16(fp)
20027aac:	e0bff517 	ldw	r2,-44(fp)
20027ab0:	1885c83a 	sub	r2,r3,r2
20027ab4:	1085883a 	add	r2,r2,r2
20027ab8:	1085883a 	add	r2,r2,r2
20027abc:	1007883a 	mov	r3,r2
20027ac0:	e0bfff17 	ldw	r2,-4(fp)
20027ac4:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
20027ac8:	0005883a 	mov	r2,zero
}
20027acc:	e037883a 	mov	sp,fp
20027ad0:	df000017 	ldw	fp,0(sp)
20027ad4:	dec00104 	addi	sp,sp,4
20027ad8:	f800283a 	ret

20027adc <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
20027adc:	defff504 	addi	sp,sp,-44
20027ae0:	dfc00a15 	stw	ra,40(sp)
20027ae4:	df000915 	stw	fp,36(sp)
20027ae8:	df000904 	addi	fp,sp,36
20027aec:	2005883a 	mov	r2,r4
20027af0:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20027af4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
20027af8:	e0bfff03 	ldbu	r2,-4(fp)
20027afc:	10800518 	cmpnei	r2,r2,20
20027b00:	1000021e 	bne	r2,zero,20027b0c <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
20027b04:	008011c4 	movi	r2,71
20027b08:	00006806 	br	20027cac <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
20027b0c:	e0bfff03 	ldbu	r2,-4(fp)
20027b10:	10800530 	cmpltui	r2,r2,20
20027b14:	1000051e 	bne	r2,zero,20027b2c <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
20027b18:	e0bfff03 	ldbu	r2,-4(fp)
20027b1c:	10803fe0 	cmpeqi	r2,r2,255
20027b20:	1000021e 	bne	r2,zero,20027b2c <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
20027b24:	00800a84 	movi	r2,42
20027b28:	00006006 	br	20027cac <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027b2c:	0005303a 	rdctl	r2,status
20027b30:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027b34:	e0fffe17 	ldw	r3,-8(fp)
20027b38:	00bfff84 	movi	r2,-2
20027b3c:	1884703a 	and	r2,r3,r2
20027b40:	1001703a 	wrctl	status,r2
  
  return context;
20027b44:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
20027b48:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
20027b4c:	e0bfff03 	ldbu	r2,-4(fp)
20027b50:	10803fd8 	cmpnei	r2,r2,255
20027b54:	1000061e 	bne	r2,zero,20027b70 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
20027b58:	d0a60517 	ldw	r2,-26604(gp)
20027b5c:	10800c83 	ldbu	r2,50(r2)
20027b60:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
20027b64:	00800044 	movi	r2,1
20027b68:	e0bff705 	stb	r2,-36(fp)
20027b6c:	00000906 	br	20027b94 <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
20027b70:	d0a60517 	ldw	r2,-26604(gp)
20027b74:	10800c83 	ldbu	r2,50(r2)
20027b78:	10c03fcc 	andi	r3,r2,255
20027b7c:	e0bfff03 	ldbu	r2,-4(fp)
20027b80:	1880031e 	bne	r3,r2,20027b90 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
20027b84:	00800044 	movi	r2,1
20027b88:	e0bff705 	stb	r2,-36(fp)
20027b8c:	00000106 	br	20027b94 <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
20027b90:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
20027b94:	e0ffff03 	ldbu	r3,-4(fp)
20027b98:	008800f4 	movhi	r2,8195
20027b9c:	1086b504 	addi	r2,r2,6868
20027ba0:	18c7883a 	add	r3,r3,r3
20027ba4:	18c7883a 	add	r3,r3,r3
20027ba8:	10c5883a 	add	r2,r2,r3
20027bac:	10800017 	ldw	r2,0(r2)
20027bb0:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
20027bb4:	e0bffa17 	ldw	r2,-24(fp)
20027bb8:	1000061e 	bne	r2,zero,20027bd4 <OSTaskSuspend+0xf8>
20027bbc:	e0bff817 	ldw	r2,-32(fp)
20027bc0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027bc4:	e0bff917 	ldw	r2,-28(fp)
20027bc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
20027bcc:	00801204 	movi	r2,72
20027bd0:	00003606 	br	20027cac <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
20027bd4:	e0bffa17 	ldw	r2,-24(fp)
20027bd8:	10800058 	cmpnei	r2,r2,1
20027bdc:	1000061e 	bne	r2,zero,20027bf8 <OSTaskSuspend+0x11c>
20027be0:	e0bff817 	ldw	r2,-32(fp)
20027be4:	e0bffb15 	stw	r2,-20(fp)
20027be8:	e0bffb17 	ldw	r2,-20(fp)
20027bec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
20027bf0:	008010c4 	movi	r2,67
20027bf4:	00002d06 	br	20027cac <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
20027bf8:	e0bffa17 	ldw	r2,-24(fp)
20027bfc:	10800d03 	ldbu	r2,52(r2)
20027c00:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
20027c04:	e0fffd03 	ldbu	r3,-12(fp)
20027c08:	e13ffd03 	ldbu	r4,-12(fp)
20027c0c:	d0a60244 	addi	r2,gp,-26615
20027c10:	2085883a 	add	r2,r4,r2
20027c14:	10800003 	ldbu	r2,0(r2)
20027c18:	1009883a 	mov	r4,r2
20027c1c:	e0bffa17 	ldw	r2,-24(fp)
20027c20:	10800d43 	ldbu	r2,53(r2)
20027c24:	0084303a 	nor	r2,zero,r2
20027c28:	2084703a 	and	r2,r4,r2
20027c2c:	1009883a 	mov	r4,r2
20027c30:	d0a60244 	addi	r2,gp,-26615
20027c34:	1885883a 	add	r2,r3,r2
20027c38:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
20027c3c:	e0fffd03 	ldbu	r3,-12(fp)
20027c40:	d0a60244 	addi	r2,gp,-26615
20027c44:	1885883a 	add	r2,r3,r2
20027c48:	10800003 	ldbu	r2,0(r2)
20027c4c:	10803fcc 	andi	r2,r2,255
20027c50:	1000071e 	bne	r2,zero,20027c70 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
20027c54:	e0bffa17 	ldw	r2,-24(fp)
20027c58:	10800d83 	ldbu	r2,54(r2)
20027c5c:	0084303a 	nor	r2,zero,r2
20027c60:	1007883a 	mov	r3,r2
20027c64:	d0a60203 	ldbu	r2,-26616(gp)
20027c68:	1884703a 	and	r2,r3,r2
20027c6c:	d0a60205 	stb	r2,-26616(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
20027c70:	e0bffa17 	ldw	r2,-24(fp)
20027c74:	10800c03 	ldbu	r2,48(r2)
20027c78:	10800214 	ori	r2,r2,8
20027c7c:	1007883a 	mov	r3,r2
20027c80:	e0bffa17 	ldw	r2,-24(fp)
20027c84:	10c00c05 	stb	r3,48(r2)
20027c88:	e0bff817 	ldw	r2,-32(fp)
20027c8c:	e0bffc15 	stw	r2,-16(fp)
20027c90:	e0bffc17 	ldw	r2,-16(fp)
20027c94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
20027c98:	e0bff703 	ldbu	r2,-36(fp)
20027c9c:	10800058 	cmpnei	r2,r2,1
20027ca0:	1000011e 	bne	r2,zero,20027ca8 <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
20027ca4:	00224b80 	call	200224b8 <OS_Sched>
    }
    return (OS_ERR_NONE);
20027ca8:	0005883a 	mov	r2,zero
}
20027cac:	e037883a 	mov	sp,fp
20027cb0:	dfc00117 	ldw	ra,4(sp)
20027cb4:	df000017 	ldw	fp,0(sp)
20027cb8:	dec00204 	addi	sp,sp,8
20027cbc:	f800283a 	ret

20027cc0 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
20027cc0:	defff604 	addi	sp,sp,-40
20027cc4:	dfc00915 	stw	ra,36(sp)
20027cc8:	df000815 	stw	fp,32(sp)
20027ccc:	df000804 	addi	fp,sp,32
20027cd0:	2005883a 	mov	r2,r4
20027cd4:	e17fff15 	stw	r5,-4(fp)
20027cd8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20027cdc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
20027ce0:	e0bffe03 	ldbu	r2,-8(fp)
20027ce4:	10800570 	cmpltui	r2,r2,21
20027ce8:	1000051e 	bne	r2,zero,20027d00 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
20027cec:	e0bffe03 	ldbu	r2,-8(fp)
20027cf0:	10803fe0 	cmpeqi	r2,r2,255
20027cf4:	1000021e 	bne	r2,zero,20027d00 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
20027cf8:	00800a84 	movi	r2,42
20027cfc:	00003406 	br	20027dd0 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
20027d00:	e0bfff17 	ldw	r2,-4(fp)
20027d04:	1000021e 	bne	r2,zero,20027d10 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
20027d08:	00800244 	movi	r2,9
20027d0c:	00003006 	br	20027dd0 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027d10:	0005303a 	rdctl	r2,status
20027d14:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027d18:	e0fffd17 	ldw	r3,-12(fp)
20027d1c:	00bfff84 	movi	r2,-2
20027d20:	1884703a 	and	r2,r3,r2
20027d24:	1001703a 	wrctl	status,r2
  
  return context;
20027d28:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
20027d2c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
20027d30:	e0bffe03 	ldbu	r2,-8(fp)
20027d34:	10803fd8 	cmpnei	r2,r2,255
20027d38:	1000031e 	bne	r2,zero,20027d48 <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
20027d3c:	d0a60517 	ldw	r2,-26604(gp)
20027d40:	10800c83 	ldbu	r2,50(r2)
20027d44:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
20027d48:	e0fffe03 	ldbu	r3,-8(fp)
20027d4c:	008800f4 	movhi	r2,8195
20027d50:	1086b504 	addi	r2,r2,6868
20027d54:	18c7883a 	add	r3,r3,r3
20027d58:	18c7883a 	add	r3,r3,r3
20027d5c:	10c5883a 	add	r2,r2,r3
20027d60:	10800017 	ldw	r2,0(r2)
20027d64:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
20027d68:	e0bffa17 	ldw	r2,-24(fp)
20027d6c:	1000061e 	bne	r2,zero,20027d88 <OSTaskQuery+0xc8>
20027d70:	e0bff817 	ldw	r2,-32(fp)
20027d74:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027d78:	e0bff917 	ldw	r2,-28(fp)
20027d7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
20027d80:	00800a44 	movi	r2,41
20027d84:	00001206 	br	20027dd0 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
20027d88:	e0bffa17 	ldw	r2,-24(fp)
20027d8c:	10800058 	cmpnei	r2,r2,1
20027d90:	1000061e 	bne	r2,zero,20027dac <OSTaskQuery+0xec>
20027d94:	e0bff817 	ldw	r2,-32(fp)
20027d98:	e0bffb15 	stw	r2,-20(fp)
20027d9c:	e0bffb17 	ldw	r2,-20(fp)
20027da0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
20027da4:	008010c4 	movi	r2,67
20027da8:	00000906 	br	20027dd0 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
20027dac:	01801b04 	movi	r6,108
20027db0:	e17ffa17 	ldw	r5,-24(fp)
20027db4:	e13fff17 	ldw	r4,-4(fp)
20027db8:	00224500 	call	20022450 <OS_MemCopy>
20027dbc:	e0bff817 	ldw	r2,-32(fp)
20027dc0:	e0bffc15 	stw	r2,-16(fp)
20027dc4:	e0bffc17 	ldw	r2,-16(fp)
20027dc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
20027dcc:	0005883a 	mov	r2,zero
}
20027dd0:	e037883a 	mov	sp,fp
20027dd4:	dfc00117 	ldw	ra,4(sp)
20027dd8:	df000017 	ldw	fp,0(sp)
20027ddc:	dec00204 	addi	sp,sp,8
20027de0:	f800283a 	ret

20027de4 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
20027de4:	defffc04 	addi	sp,sp,-16
20027de8:	df000315 	stw	fp,12(sp)
20027dec:	df000304 	addi	fp,sp,12
20027df0:	e13ffd15 	stw	r4,-12(fp)
20027df4:	e17ffe15 	stw	r5,-8(fp)
20027df8:	3005883a 	mov	r2,r6
20027dfc:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
20027e00:	e0bfff0b 	ldhu	r2,-4(fp)
20027e04:	1080004c 	andi	r2,r2,1
20027e08:	10000d26 	beq	r2,zero,20027e40 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
20027e0c:	e0bfff0b 	ldhu	r2,-4(fp)
20027e10:	1080008c 	andi	r2,r2,2
20027e14:	10000a26 	beq	r2,zero,20027e40 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
20027e18:	00000706 	br	20027e38 <OS_TaskStkClr+0x54>
                size--;
20027e1c:	e0bffe17 	ldw	r2,-8(fp)
20027e20:	10bfffc4 	addi	r2,r2,-1
20027e24:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
20027e28:	e0bffd17 	ldw	r2,-12(fp)
20027e2c:	10c00104 	addi	r3,r2,4
20027e30:	e0fffd15 	stw	r3,-12(fp)
20027e34:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
20027e38:	e0bffe17 	ldw	r2,-8(fp)
20027e3c:	103ff71e 	bne	r2,zero,20027e1c <__alt_data_end+0xfffe7e1c>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
20027e40:	0001883a 	nop
20027e44:	e037883a 	mov	sp,fp
20027e48:	df000017 	ldw	fp,0(sp)
20027e4c:	dec00104 	addi	sp,sp,4
20027e50:	f800283a 	ret

20027e54 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
20027e54:	defff904 	addi	sp,sp,-28
20027e58:	dfc00615 	stw	ra,24(sp)
20027e5c:	df000515 	stw	fp,20(sp)
20027e60:	df000504 	addi	fp,sp,20
20027e64:	2005883a 	mov	r2,r4
20027e68:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
20027e6c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
20027e70:	d0a60403 	ldbu	r2,-26608(gp)
20027e74:	10803fcc 	andi	r2,r2,255
20027e78:	1000311e 	bne	r2,zero,20027f40 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
20027e7c:	e0bfff0b 	ldhu	r2,-4(fp)
20027e80:	10003026 	beq	r2,zero,20027f44 <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20027e84:	0005303a 	rdctl	r2,status
20027e88:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20027e8c:	e0fffe17 	ldw	r3,-8(fp)
20027e90:	00bfff84 	movi	r2,-2
20027e94:	1884703a 	and	r2,r3,r2
20027e98:	1001703a 	wrctl	status,r2
  
  return context;
20027e9c:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
20027ea0:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
20027ea4:	d0a60517 	ldw	r2,-26604(gp)
20027ea8:	10800d03 	ldbu	r2,52(r2)
20027eac:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
20027eb0:	e0fffd03 	ldbu	r3,-12(fp)
20027eb4:	e13ffd03 	ldbu	r4,-12(fp)
20027eb8:	d0a60244 	addi	r2,gp,-26615
20027ebc:	2085883a 	add	r2,r4,r2
20027ec0:	10800003 	ldbu	r2,0(r2)
20027ec4:	1009883a 	mov	r4,r2
20027ec8:	d0a60517 	ldw	r2,-26604(gp)
20027ecc:	10800d43 	ldbu	r2,53(r2)
20027ed0:	0084303a 	nor	r2,zero,r2
20027ed4:	2084703a 	and	r2,r4,r2
20027ed8:	1009883a 	mov	r4,r2
20027edc:	d0a60244 	addi	r2,gp,-26615
20027ee0:	1885883a 	add	r2,r3,r2
20027ee4:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
20027ee8:	e0fffd03 	ldbu	r3,-12(fp)
20027eec:	d0a60244 	addi	r2,gp,-26615
20027ef0:	1885883a 	add	r2,r3,r2
20027ef4:	10800003 	ldbu	r2,0(r2)
20027ef8:	10803fcc 	andi	r2,r2,255
20027efc:	1000071e 	bne	r2,zero,20027f1c <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
20027f00:	d0a60517 	ldw	r2,-26604(gp)
20027f04:	10800d83 	ldbu	r2,54(r2)
20027f08:	0084303a 	nor	r2,zero,r2
20027f0c:	1007883a 	mov	r3,r2
20027f10:	d0a60203 	ldbu	r2,-26616(gp)
20027f14:	1884703a 	and	r2,r3,r2
20027f18:	d0a60205 	stb	r2,-26616(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
20027f1c:	d0a60517 	ldw	r2,-26604(gp)
20027f20:	e0ffff0b 	ldhu	r3,-4(fp)
20027f24:	10c00b8d 	sth	r3,46(r2)
20027f28:	e0bffb17 	ldw	r2,-20(fp)
20027f2c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20027f30:	e0bffc17 	ldw	r2,-16(fp)
20027f34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
20027f38:	00224b80 	call	200224b8 <OS_Sched>
20027f3c:	00000106 	br	20027f44 <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
20027f40:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
20027f44:	e037883a 	mov	sp,fp
20027f48:	dfc00117 	ldw	ra,4(sp)
20027f4c:	df000017 	ldw	fp,0(sp)
20027f50:	dec00204 	addi	sp,sp,8
20027f54:	f800283a 	ret

20027f58 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
20027f58:	defff704 	addi	sp,sp,-36
20027f5c:	dfc00815 	stw	ra,32(sp)
20027f60:	df000715 	stw	fp,28(sp)
20027f64:	dc000615 	stw	r16,24(sp)
20027f68:	df000704 	addi	fp,sp,28
20027f6c:	2011883a 	mov	r8,r4
20027f70:	2809883a 	mov	r4,r5
20027f74:	3007883a 	mov	r3,r6
20027f78:	3805883a 	mov	r2,r7
20027f7c:	e23ffb05 	stb	r8,-20(fp)
20027f80:	e13ffc05 	stb	r4,-16(fp)
20027f84:	e0fffd05 	stb	r3,-12(fp)
20027f88:	e0bffe0d 	sth	r2,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
20027f8c:	d0a60403 	ldbu	r2,-26608(gp)
20027f90:	10803fcc 	andi	r2,r2,255
20027f94:	10000226 	beq	r2,zero,20027fa0 <OSTimeDlyHMSM+0x48>
        return (OS_ERR_TIME_DLY_ISR);
20027f98:	00801544 	movi	r2,85
20027f9c:	00003d06 	br	20028094 <OSTimeDlyHMSM+0x13c>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
20027fa0:	e0bffb03 	ldbu	r2,-20(fp)
20027fa4:	1000081e 	bne	r2,zero,20027fc8 <OSTimeDlyHMSM+0x70>
        if (minutes == 0) {
20027fa8:	e0bffc03 	ldbu	r2,-16(fp)
20027fac:	1000061e 	bne	r2,zero,20027fc8 <OSTimeDlyHMSM+0x70>
            if (seconds == 0) {
20027fb0:	e0bffd03 	ldbu	r2,-12(fp)
20027fb4:	1000041e 	bne	r2,zero,20027fc8 <OSTimeDlyHMSM+0x70>
                if (ms == 0) {
20027fb8:	e0bffe0b 	ldhu	r2,-8(fp)
20027fbc:	1000021e 	bne	r2,zero,20027fc8 <OSTimeDlyHMSM+0x70>
                    return (OS_ERR_TIME_ZERO_DLY);
20027fc0:	00801504 	movi	r2,84
20027fc4:	00003306 	br	20028094 <OSTimeDlyHMSM+0x13c>
                }
            }
        }
    }
    if (minutes > 59) {
20027fc8:	e0bffc03 	ldbu	r2,-16(fp)
20027fcc:	10800f30 	cmpltui	r2,r2,60
20027fd0:	1000021e 	bne	r2,zero,20027fdc <OSTimeDlyHMSM+0x84>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
20027fd4:	00801444 	movi	r2,81
20027fd8:	00002e06 	br	20028094 <OSTimeDlyHMSM+0x13c>
    }
    if (seconds > 59) {
20027fdc:	e0bffd03 	ldbu	r2,-12(fp)
20027fe0:	10800f30 	cmpltui	r2,r2,60
20027fe4:	1000021e 	bne	r2,zero,20027ff0 <OSTimeDlyHMSM+0x98>
        return (OS_ERR_TIME_INVALID_SECONDS);
20027fe8:	00801484 	movi	r2,82
20027fec:	00002906 	br	20028094 <OSTimeDlyHMSM+0x13c>
    }
    if (ms > 999) {
20027ff0:	e0bffe0b 	ldhu	r2,-8(fp)
20027ff4:	1080fa30 	cmpltui	r2,r2,1000
20027ff8:	1000021e 	bne	r2,zero,20028004 <OSTimeDlyHMSM+0xac>
        return (OS_ERR_TIME_INVALID_MS);
20027ffc:	008014c4 	movi	r2,83
20028000:	00002406 	br	20028094 <OSTimeDlyHMSM+0x13c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
20028004:	e0bffb03 	ldbu	r2,-20(fp)
20028008:	10c38424 	muli	r3,r2,3600
2002800c:	e0bffc03 	ldbu	r2,-16(fp)
20028010:	10800f24 	muli	r2,r2,60
20028014:	1887883a 	add	r3,r3,r2
20028018:	e0bffd03 	ldbu	r2,-12(fp)
2002801c:	1885883a 	add	r2,r3,r2
20028020:	1400fa24 	muli	r16,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
20028024:	e0bffe0b 	ldhu	r2,-8(fp)
20028028:	1080fa24 	muli	r2,r2,1000
2002802c:	0140fa04 	movi	r5,1000
20028030:	1009883a 	mov	r4,r2
20028034:	002af000 	call	2002af00 <__udivsi3>
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
20028038:	8085883a 	add	r2,r16,r2
2002803c:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
20028040:	e0bffa17 	ldw	r2,-24(fp)
20028044:	1004d43a 	srli	r2,r2,16
20028048:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
2002804c:	e0bffa17 	ldw	r2,-24(fp)
20028050:	10bfffcc 	andi	r2,r2,65535
20028054:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
20028058:	e0bffa17 	ldw	r2,-24(fp)
2002805c:	10bfffcc 	andi	r2,r2,65535
20028060:	1009883a 	mov	r4,r2
20028064:	0027e540 	call	20027e54 <OSTimeDly>
    while (loops > 0) {
20028068:	00000706 	br	20028088 <OSTimeDlyHMSM+0x130>
        OSTimeDly((INT16U)32768u);
2002806c:	01200014 	movui	r4,32768
20028070:	0027e540 	call	20027e54 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
20028074:	01200014 	movui	r4,32768
20028078:	0027e540 	call	20027e54 <OSTimeDly>
        loops--;
2002807c:	e0bff90b 	ldhu	r2,-28(fp)
20028080:	10bfffc4 	addi	r2,r2,-1
20028084:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
20028088:	e0bff90b 	ldhu	r2,-28(fp)
2002808c:	103ff71e 	bne	r2,zero,2002806c <__alt_data_end+0xfffe806c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
20028090:	0005883a 	mov	r2,zero
}
20028094:	e6ffff04 	addi	sp,fp,-4
20028098:	dfc00217 	ldw	ra,8(sp)
2002809c:	df000117 	ldw	fp,4(sp)
200280a0:	dc000017 	ldw	r16,0(sp)
200280a4:	dec00304 	addi	sp,sp,12
200280a8:	f800283a 	ret

200280ac <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
200280ac:	defff504 	addi	sp,sp,-44
200280b0:	dfc00a15 	stw	ra,40(sp)
200280b4:	df000915 	stw	fp,36(sp)
200280b8:	df000904 	addi	fp,sp,36
200280bc:	2005883a 	mov	r2,r4
200280c0:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
200280c4:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
200280c8:	e0bfff03 	ldbu	r2,-4(fp)
200280cc:	10800530 	cmpltui	r2,r2,20
200280d0:	1000021e 	bne	r2,zero,200280dc <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
200280d4:	00800a84 	movi	r2,42
200280d8:	00006406 	br	2002826c <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200280dc:	0005303a 	rdctl	r2,status
200280e0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200280e4:	e0fffe17 	ldw	r3,-8(fp)
200280e8:	00bfff84 	movi	r2,-2
200280ec:	1884703a 	and	r2,r3,r2
200280f0:	1001703a 	wrctl	status,r2
  
  return context;
200280f4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
200280f8:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
200280fc:	e0ffff03 	ldbu	r3,-4(fp)
20028100:	008800f4 	movhi	r2,8195
20028104:	1086b504 	addi	r2,r2,6868
20028108:	18c7883a 	add	r3,r3,r3
2002810c:	18c7883a 	add	r3,r3,r3
20028110:	10c5883a 	add	r2,r2,r3
20028114:	10800017 	ldw	r2,0(r2)
20028118:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
2002811c:	e0bff917 	ldw	r2,-28(fp)
20028120:	1000061e 	bne	r2,zero,2002813c <OSTimeDlyResume+0x90>
20028124:	e0bff717 	ldw	r2,-36(fp)
20028128:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002812c:	e0bff817 	ldw	r2,-32(fp)
20028130:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
20028134:	008010c4 	movi	r2,67
20028138:	00004c06 	br	2002826c <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
2002813c:	e0bff917 	ldw	r2,-28(fp)
20028140:	10800058 	cmpnei	r2,r2,1
20028144:	1000061e 	bne	r2,zero,20028160 <OSTimeDlyResume+0xb4>
20028148:	e0bff717 	ldw	r2,-36(fp)
2002814c:	e0bffa15 	stw	r2,-24(fp)
20028150:	e0bffa17 	ldw	r2,-24(fp)
20028154:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
20028158:	008010c4 	movi	r2,67
2002815c:	00004306 	br	2002826c <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
20028160:	e0bff917 	ldw	r2,-28(fp)
20028164:	10800b8b 	ldhu	r2,46(r2)
20028168:	10bfffcc 	andi	r2,r2,65535
2002816c:	1000061e 	bne	r2,zero,20028188 <OSTimeDlyResume+0xdc>
20028170:	e0bff717 	ldw	r2,-36(fp)
20028174:	e0bffb15 	stw	r2,-20(fp)
20028178:	e0bffb17 	ldw	r2,-20(fp)
2002817c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
20028180:	00801404 	movi	r2,80
20028184:	00003906 	br	2002826c <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
20028188:	e0bff917 	ldw	r2,-28(fp)
2002818c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
20028190:	e0bff917 	ldw	r2,-28(fp)
20028194:	10800c03 	ldbu	r2,48(r2)
20028198:	10803fcc 	andi	r2,r2,255
2002819c:	10800dcc 	andi	r2,r2,55
200281a0:	10000b26 	beq	r2,zero,200281d0 <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
200281a4:	e0bff917 	ldw	r2,-28(fp)
200281a8:	10c00c03 	ldbu	r3,48(r2)
200281ac:	00bff204 	movi	r2,-56
200281b0:	1884703a 	and	r2,r3,r2
200281b4:	1007883a 	mov	r3,r2
200281b8:	e0bff917 	ldw	r2,-28(fp)
200281bc:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
200281c0:	e0bff917 	ldw	r2,-28(fp)
200281c4:	00c00044 	movi	r3,1
200281c8:	10c00c45 	stb	r3,49(r2)
200281cc:	00000206 	br	200281d8 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
200281d0:	e0bff917 	ldw	r2,-28(fp)
200281d4:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
200281d8:	e0bff917 	ldw	r2,-28(fp)
200281dc:	10800c03 	ldbu	r2,48(r2)
200281e0:	10803fcc 	andi	r2,r2,255
200281e4:	1080020c 	andi	r2,r2,8
200281e8:	10001b1e 	bne	r2,zero,20028258 <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
200281ec:	e0bff917 	ldw	r2,-28(fp)
200281f0:	10c00d83 	ldbu	r3,54(r2)
200281f4:	d0a60203 	ldbu	r2,-26616(gp)
200281f8:	1884b03a 	or	r2,r3,r2
200281fc:	d0a60205 	stb	r2,-26616(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
20028200:	e0bff917 	ldw	r2,-28(fp)
20028204:	10800d03 	ldbu	r2,52(r2)
20028208:	10c03fcc 	andi	r3,r2,255
2002820c:	e0bff917 	ldw	r2,-28(fp)
20028210:	10800d03 	ldbu	r2,52(r2)
20028214:	11003fcc 	andi	r4,r2,255
20028218:	d0a60244 	addi	r2,gp,-26615
2002821c:	2085883a 	add	r2,r4,r2
20028220:	11000003 	ldbu	r4,0(r2)
20028224:	e0bff917 	ldw	r2,-28(fp)
20028228:	10800d43 	ldbu	r2,53(r2)
2002822c:	2084b03a 	or	r2,r4,r2
20028230:	1009883a 	mov	r4,r2
20028234:	d0a60244 	addi	r2,gp,-26615
20028238:	1885883a 	add	r2,r3,r2
2002823c:	11000005 	stb	r4,0(r2)
20028240:	e0bff717 	ldw	r2,-36(fp)
20028244:	e0bffc15 	stw	r2,-16(fp)
20028248:	e0bffc17 	ldw	r2,-16(fp)
2002824c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
20028250:	00224b80 	call	200224b8 <OS_Sched>
20028254:	00000406 	br	20028268 <OSTimeDlyResume+0x1bc>
20028258:	e0bff717 	ldw	r2,-36(fp)
2002825c:	e0bffd15 	stw	r2,-12(fp)
20028260:	e0bffd17 	ldw	r2,-12(fp)
20028264:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
20028268:	0005883a 	mov	r2,zero
}
2002826c:	e037883a 	mov	sp,fp
20028270:	dfc00117 	ldw	ra,4(sp)
20028274:	df000017 	ldw	fp,0(sp)
20028278:	dec00204 	addi	sp,sp,8
2002827c:	f800283a 	ret

20028280 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
20028280:	defffb04 	addi	sp,sp,-20
20028284:	df000415 	stw	fp,16(sp)
20028288:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
2002828c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20028290:	0005303a 	rdctl	r2,status
20028294:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20028298:	e0fffe17 	ldw	r3,-8(fp)
2002829c:	00bfff84 	movi	r2,-2
200282a0:	1884703a 	and	r2,r3,r2
200282a4:	1001703a 	wrctl	status,r2
  
  return context;
200282a8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
200282ac:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
200282b0:	d0a60617 	ldw	r2,-26600(gp)
200282b4:	e0bffd15 	stw	r2,-12(fp)
200282b8:	e0bffc17 	ldw	r2,-16(fp)
200282bc:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200282c0:	e0bfff17 	ldw	r2,-4(fp)
200282c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
200282c8:	e0bffd17 	ldw	r2,-12(fp)
}
200282cc:	e037883a 	mov	sp,fp
200282d0:	df000017 	ldw	fp,0(sp)
200282d4:	dec00104 	addi	sp,sp,4
200282d8:	f800283a 	ret

200282dc <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
200282dc:	defffb04 	addi	sp,sp,-20
200282e0:	df000415 	stw	fp,16(sp)
200282e4:	df000404 	addi	fp,sp,16
200282e8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
200282ec:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200282f0:	0005303a 	rdctl	r2,status
200282f4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200282f8:	e0fffd17 	ldw	r3,-12(fp)
200282fc:	00bfff84 	movi	r2,-2
20028300:	1884703a 	and	r2,r3,r2
20028304:	1001703a 	wrctl	status,r2
  
  return context;
20028308:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
2002830c:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
20028310:	e0bfff17 	ldw	r2,-4(fp)
20028314:	d0a60615 	stw	r2,-26600(gp)
20028318:	e0bffc17 	ldw	r2,-16(fp)
2002831c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20028320:	e0bffe17 	ldw	r2,-8(fp)
20028324:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
20028328:	0001883a 	nop
2002832c:	e037883a 	mov	sp,fp
20028330:	df000017 	ldw	fp,0(sp)
20028334:	dec00104 	addi	sp,sp,4
20028338:	f800283a 	ret

2002833c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
2002833c:	defffd04 	addi	sp,sp,-12
20028340:	dfc00215 	stw	ra,8(sp)
20028344:	df000115 	stw	fp,4(sp)
20028348:	df000104 	addi	fp,sp,4
2002834c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
20028350:	d1602404 	addi	r5,gp,-32624
20028354:	e13fff17 	ldw	r4,-4(fp)
20028358:	00299500 	call	20029950 <alt_dev_llist_insert>
}
2002835c:	e037883a 	mov	sp,fp
20028360:	dfc00117 	ldw	ra,4(sp)
20028364:	df000017 	ldw	fp,0(sp)
20028368:	dec00204 	addi	sp,sp,8
2002836c:	f800283a 	ret

20028370 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
20028370:	defffe04 	addi	sp,sp,-8
20028374:	dfc00115 	stw	ra,4(sp)
20028378:	df000015 	stw	fp,0(sp)
2002837c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
20028380:	d0a02717 	ldw	r2,-32612(gp)
20028384:	10000326 	beq	r2,zero,20028394 <alt_get_errno+0x24>
20028388:	d0a02717 	ldw	r2,-32612(gp)
2002838c:	103ee83a 	callr	r2
20028390:	00000106 	br	20028398 <alt_get_errno+0x28>
20028394:	d0a60e04 	addi	r2,gp,-26568
}
20028398:	e037883a 	mov	sp,fp
2002839c:	dfc00117 	ldw	ra,4(sp)
200283a0:	df000017 	ldw	fp,0(sp)
200283a4:	dec00204 	addi	sp,sp,8
200283a8:	f800283a 	ret

200283ac <alt_avalon_mutex_reg>:
/*
 * Register a Mutex device
 */

static ALT_INLINE int alt_avalon_mutex_reg (alt_mutex_dev* dev)
{
200283ac:	defffa04 	addi	sp,sp,-24
200283b0:	dfc00515 	stw	ra,20(sp)
200283b4:	df000415 	stw	fp,16(sp)
200283b8:	df000404 	addi	fp,sp,16
200283bc:	e13fff15 	stw	r4,-4(fp)
  int ret_code;
  extern alt_llist alt_mutex_list;
  ret_code = ALT_SEM_CREATE (&dev->lock, 1);
200283c0:	e0bfff17 	ldw	r2,-4(fp)
200283c4:	10800404 	addi	r2,r2,16
200283c8:	e0bffd15 	stw	r2,-12(fp)
200283cc:	00800044 	movi	r2,1
200283d0:	e0bffe0d 	sth	r2,-8(fp)
200283d4:	e0bffe0b 	ldhu	r2,-8(fp)
200283d8:	1009883a 	mov	r4,r2
200283dc:	0025d380 	call	20025d38 <OSSemCreate>
200283e0:	1007883a 	mov	r3,r2
200283e4:	e0bffd17 	ldw	r2,-12(fp)
200283e8:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
200283ec:	e0bffd17 	ldw	r2,-12(fp)
200283f0:	10800017 	ldw	r2,0(r2)
200283f4:	10000226 	beq	r2,zero,20028400 <alt_avalon_mutex_reg+0x54>
200283f8:	0005883a 	mov	r2,zero
200283fc:	00000106 	br	20028404 <alt_avalon_mutex_reg+0x58>
20028400:	00bfffc4 	movi	r2,-1
20028404:	e0bffc15 	stw	r2,-16(fp)
  if (!ret_code)
20028408:	e0bffc17 	ldw	r2,-16(fp)
2002840c:	1000051e 	bne	r2,zero,20028424 <alt_avalon_mutex_reg+0x78>
  {
    ret_code = alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mutex_list);
20028410:	d1602004 	addi	r5,gp,-32640
20028414:	e13fff17 	ldw	r4,-4(fp)
20028418:	00299500 	call	20029950 <alt_dev_llist_insert>
2002841c:	e0bffc15 	stw	r2,-16(fp)
20028420:	00000606 	br	2002843c <alt_avalon_mutex_reg+0x90>
  }
  else
  {
    ALT_ERRNO = ENOMEM;
20028424:	00283700 	call	20028370 <alt_get_errno>
20028428:	1007883a 	mov	r3,r2
2002842c:	00800304 	movi	r2,12
20028430:	18800015 	stw	r2,0(r3)
    ret_code = -ENOMEM;
20028434:	00bffd04 	movi	r2,-12
20028438:	e0bffc15 	stw	r2,-16(fp)
  }

  return ret_code;
2002843c:	e0bffc17 	ldw	r2,-16(fp)
}
20028440:	e037883a 	mov	sp,fp
20028444:	dfc00117 	ldw	ra,4(sp)
20028448:	df000017 	ldw	fp,0(sp)
2002844c:	dec00204 	addi	sp,sp,8
20028450:	f800283a 	ret

20028454 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
20028454:	defffd04 	addi	sp,sp,-12
20028458:	dfc00215 	stw	ra,8(sp)
2002845c:	df000115 	stw	fp,4(sp)
20028460:	df000104 	addi	fp,sp,4
20028464:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU_1_0_NIOS2_GEN2_0, CPU_1_0_nios2_gen2_0);
20028468:	002a1b00 	call	2002a1b0 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
2002846c:	00800044 	movi	r2,1
20028470:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
20028474:	0001883a 	nop
20028478:	e037883a 	mov	sp,fp
2002847c:	dfc00117 	ldw	ra,4(sp)
20028480:	df000017 	ldw	fp,0(sp)
20028484:	dec00204 	addi	sp,sp,8
20028488:	f800283a 	ret

2002848c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
2002848c:	defffe04 	addi	sp,sp,-8
20028490:	dfc00115 	stw	ra,4(sp)
20028494:	df000015 	stw	fp,0(sp)
20028498:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( CPU_1_0_TIMER_0, CPU_1_0_timer_0);
2002849c:	01c0fa04 	movi	r7,1000
200284a0:	01800044 	movi	r6,1
200284a4:	000b883a 	mov	r5,zero
200284a8:	01080134 	movhi	r4,8196
200284ac:	21040004 	addi	r4,r4,4096
200284b0:	00295ec0 	call	200295ec <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( CPU_1_0_JTAG_UART_0, CPU_1_0_jtag_uart_0);
200284b4:	000d883a 	mov	r6,zero
200284b8:	000b883a 	mov	r5,zero
200284bc:	010800f4 	movhi	r4,8195
200284c0:	212c6904 	addi	r4,r4,-20060
200284c4:	00286600 	call	20028660 <altera_avalon_jtag_uart_init>
200284c8:	010800f4 	movhi	r4,8195
200284cc:	212c5f04 	addi	r4,r4,-20100
200284d0:	002833c0 	call	2002833c <alt_dev_reg>
    ALTERA_AVALON_MUTEX_INIT ( MUTEX_0, mutex_0);
200284d4:	010800f4 	movhi	r4,8195
200284d8:	21307a04 	addi	r4,r4,-15896
200284dc:	00283ac0 	call	200283ac <alt_avalon_mutex_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
200284e0:	0001883a 	nop
}
200284e4:	0001883a 	nop
200284e8:	e037883a 	mov	sp,fp
200284ec:	dfc00117 	ldw	ra,4(sp)
200284f0:	df000017 	ldw	fp,0(sp)
200284f4:	dec00204 	addi	sp,sp,8
200284f8:	f800283a 	ret

200284fc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
200284fc:	defffa04 	addi	sp,sp,-24
20028500:	dfc00515 	stw	ra,20(sp)
20028504:	df000415 	stw	fp,16(sp)
20028508:	df000404 	addi	fp,sp,16
2002850c:	e13ffd15 	stw	r4,-12(fp)
20028510:	e17ffe15 	stw	r5,-8(fp)
20028514:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
20028518:	e0bffd17 	ldw	r2,-12(fp)
2002851c:	10800017 	ldw	r2,0(r2)
20028520:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
20028524:	e0bffc17 	ldw	r2,-16(fp)
20028528:	10c00a04 	addi	r3,r2,40
2002852c:	e0bffd17 	ldw	r2,-12(fp)
20028530:	10800217 	ldw	r2,8(r2)
20028534:	100f883a 	mov	r7,r2
20028538:	e1bfff17 	ldw	r6,-4(fp)
2002853c:	e17ffe17 	ldw	r5,-8(fp)
20028540:	1809883a 	mov	r4,r3
20028544:	0028ca80 	call	20028ca8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
20028548:	e037883a 	mov	sp,fp
2002854c:	dfc00117 	ldw	ra,4(sp)
20028550:	df000017 	ldw	fp,0(sp)
20028554:	dec00204 	addi	sp,sp,8
20028558:	f800283a 	ret

2002855c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
2002855c:	defffa04 	addi	sp,sp,-24
20028560:	dfc00515 	stw	ra,20(sp)
20028564:	df000415 	stw	fp,16(sp)
20028568:	df000404 	addi	fp,sp,16
2002856c:	e13ffd15 	stw	r4,-12(fp)
20028570:	e17ffe15 	stw	r5,-8(fp)
20028574:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
20028578:	e0bffd17 	ldw	r2,-12(fp)
2002857c:	10800017 	ldw	r2,0(r2)
20028580:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
20028584:	e0bffc17 	ldw	r2,-16(fp)
20028588:	10c00a04 	addi	r3,r2,40
2002858c:	e0bffd17 	ldw	r2,-12(fp)
20028590:	10800217 	ldw	r2,8(r2)
20028594:	100f883a 	mov	r7,r2
20028598:	e1bfff17 	ldw	r6,-4(fp)
2002859c:	e17ffe17 	ldw	r5,-8(fp)
200285a0:	1809883a 	mov	r4,r3
200285a4:	0028f640 	call	20028f64 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
200285a8:	e037883a 	mov	sp,fp
200285ac:	dfc00117 	ldw	ra,4(sp)
200285b0:	df000017 	ldw	fp,0(sp)
200285b4:	dec00204 	addi	sp,sp,8
200285b8:	f800283a 	ret

200285bc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
200285bc:	defffc04 	addi	sp,sp,-16
200285c0:	dfc00315 	stw	ra,12(sp)
200285c4:	df000215 	stw	fp,8(sp)
200285c8:	df000204 	addi	fp,sp,8
200285cc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
200285d0:	e0bfff17 	ldw	r2,-4(fp)
200285d4:	10800017 	ldw	r2,0(r2)
200285d8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
200285dc:	e0bffe17 	ldw	r2,-8(fp)
200285e0:	10c00a04 	addi	r3,r2,40
200285e4:	e0bfff17 	ldw	r2,-4(fp)
200285e8:	10800217 	ldw	r2,8(r2)
200285ec:	100b883a 	mov	r5,r2
200285f0:	1809883a 	mov	r4,r3
200285f4:	0028b500 	call	20028b50 <altera_avalon_jtag_uart_close>
}
200285f8:	e037883a 	mov	sp,fp
200285fc:	dfc00117 	ldw	ra,4(sp)
20028600:	df000017 	ldw	fp,0(sp)
20028604:	dec00204 	addi	sp,sp,8
20028608:	f800283a 	ret

2002860c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
2002860c:	defffa04 	addi	sp,sp,-24
20028610:	dfc00515 	stw	ra,20(sp)
20028614:	df000415 	stw	fp,16(sp)
20028618:	df000404 	addi	fp,sp,16
2002861c:	e13ffd15 	stw	r4,-12(fp)
20028620:	e17ffe15 	stw	r5,-8(fp)
20028624:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
20028628:	e0bffd17 	ldw	r2,-12(fp)
2002862c:	10800017 	ldw	r2,0(r2)
20028630:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
20028634:	e0bffc17 	ldw	r2,-16(fp)
20028638:	10800a04 	addi	r2,r2,40
2002863c:	e1bfff17 	ldw	r6,-4(fp)
20028640:	e17ffe17 	ldw	r5,-8(fp)
20028644:	1009883a 	mov	r4,r2
20028648:	0028bb80 	call	20028bb8 <altera_avalon_jtag_uart_ioctl>
}
2002864c:	e037883a 	mov	sp,fp
20028650:	dfc00117 	ldw	ra,4(sp)
20028654:	df000017 	ldw	fp,0(sp)
20028658:	dec00204 	addi	sp,sp,8
2002865c:	f800283a 	ret

20028660 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
20028660:	defff104 	addi	sp,sp,-60
20028664:	dfc00e15 	stw	ra,56(sp)
20028668:	df000d15 	stw	fp,52(sp)
2002866c:	df000d04 	addi	fp,sp,52
20028670:	e13ff915 	stw	r4,-28(fp)
20028674:	e17ffa15 	stw	r5,-24(fp)
20028678:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
2002867c:	e0bff917 	ldw	r2,-28(fp)
20028680:	10800c04 	addi	r2,r2,48
20028684:	e0bff415 	stw	r2,-48(fp)
20028688:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
2002868c:	e0bff80b 	ldhu	r2,-32(fp)
20028690:	e0fff884 	addi	r3,fp,-30
20028694:	180b883a 	mov	r5,r3
20028698:	1009883a 	mov	r4,r2
2002869c:	00230240 	call	20023024 <OSFlagCreate>
200286a0:	1007883a 	mov	r3,r2
200286a4:	e0bff417 	ldw	r2,-48(fp)
200286a8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
200286ac:	e0bff917 	ldw	r2,-28(fp)
200286b0:	10800a04 	addi	r2,r2,40
200286b4:	e0bff515 	stw	r2,-44(fp)
200286b8:	00800044 	movi	r2,1
200286bc:	e0bff78d 	sth	r2,-34(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
200286c0:	e0bff78b 	ldhu	r2,-34(fp)
200286c4:	1009883a 	mov	r4,r2
200286c8:	0025d380 	call	20025d38 <OSSemCreate>
200286cc:	1007883a 	mov	r3,r2
200286d0:	e0bff517 	ldw	r2,-44(fp)
200286d4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
200286d8:	e0bff917 	ldw	r2,-28(fp)
200286dc:	10800b04 	addi	r2,r2,44
200286e0:	e0bff615 	stw	r2,-40(fp)
200286e4:	00800044 	movi	r2,1
200286e8:	e0bff70d 	sth	r2,-36(fp)
200286ec:	e0bff70b 	ldhu	r2,-36(fp)
200286f0:	1009883a 	mov	r4,r2
200286f4:	0025d380 	call	20025d38 <OSSemCreate>
200286f8:	1007883a 	mov	r3,r2
200286fc:	e0bff617 	ldw	r2,-40(fp)
20028700:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
20028704:	e0bff917 	ldw	r2,-28(fp)
20028708:	00c00044 	movi	r3,1
2002870c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
20028710:	e0bff917 	ldw	r2,-28(fp)
20028714:	10800017 	ldw	r2,0(r2)
20028718:	10800104 	addi	r2,r2,4
2002871c:	1007883a 	mov	r3,r2
20028720:	e0bff917 	ldw	r2,-28(fp)
20028724:	10800817 	ldw	r2,32(r2)
20028728:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
2002872c:	e0bffa17 	ldw	r2,-24(fp)
20028730:	e0fffb17 	ldw	r3,-20(fp)
20028734:	d8000015 	stw	zero,0(sp)
20028738:	e1fff917 	ldw	r7,-28(fp)
2002873c:	018800f4 	movhi	r6,8195
20028740:	31a1ea04 	addi	r6,r6,-30808
20028744:	180b883a 	mov	r5,r3
20028748:	1009883a 	mov	r4,r2
2002874c:	00204200 	call	20020420 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
20028750:	e0bff917 	ldw	r2,-28(fp)
20028754:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
20028758:	e0bff917 	ldw	r2,-28(fp)
2002875c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
20028760:	d0e60c17 	ldw	r3,-26576(gp)
20028764:	e1fff917 	ldw	r7,-28(fp)
20028768:	018800f4 	movhi	r6,8195
2002876c:	31a29304 	addi	r6,r6,-30132
20028770:	180b883a 	mov	r5,r3
20028774:	1009883a 	mov	r4,r2
20028778:	00296680 	call	20029668 <alt_alarm_start>
2002877c:	1000040e 	bge	r2,zero,20028790 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
20028780:	e0fff917 	ldw	r3,-28(fp)
20028784:	00a00034 	movhi	r2,32768
20028788:	10bfffc4 	addi	r2,r2,-1
2002878c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
20028790:	0001883a 	nop
20028794:	e037883a 	mov	sp,fp
20028798:	dfc00117 	ldw	ra,4(sp)
2002879c:	df000017 	ldw	fp,0(sp)
200287a0:	dec00204 	addi	sp,sp,8
200287a4:	f800283a 	ret

200287a8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
200287a8:	defff204 	addi	sp,sp,-56
200287ac:	dfc00d15 	stw	ra,52(sp)
200287b0:	df000c15 	stw	fp,48(sp)
200287b4:	df000c04 	addi	fp,sp,48
200287b8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
200287bc:	e0bfff17 	ldw	r2,-4(fp)
200287c0:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
200287c4:	e0bff617 	ldw	r2,-40(fp)
200287c8:	10800017 	ldw	r2,0(r2)
200287cc:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
200287d0:	e0bff717 	ldw	r2,-36(fp)
200287d4:	10800104 	addi	r2,r2,4
200287d8:	10800037 	ldwio	r2,0(r2)
200287dc:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
200287e0:	e0bff817 	ldw	r2,-32(fp)
200287e4:	1080c00c 	andi	r2,r2,768
200287e8:	10009126 	beq	r2,zero,20028a30 <altera_avalon_jtag_uart_irq+0x288>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
200287ec:	e0bff817 	ldw	r2,-32(fp)
200287f0:	1080400c 	andi	r2,r2,256
200287f4:	10004726 	beq	r2,zero,20028914 <altera_avalon_jtag_uart_irq+0x16c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
200287f8:	00800074 	movhi	r2,1
200287fc:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
20028800:	e0bff617 	ldw	r2,-40(fp)
20028804:	10800d17 	ldw	r2,52(r2)
20028808:	10800044 	addi	r2,r2,1
2002880c:	1081ffcc 	andi	r2,r2,2047
20028810:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
20028814:	e0bff617 	ldw	r2,-40(fp)
20028818:	10c00e17 	ldw	r3,56(r2)
2002881c:	e0bff917 	ldw	r2,-28(fp)
20028820:	18802726 	beq	r3,r2,200288c0 <altera_avalon_jtag_uart_irq+0x118>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
20028824:	e0bff717 	ldw	r2,-36(fp)
20028828:	10800037 	ldwio	r2,0(r2)
2002882c:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
20028830:	e0bff417 	ldw	r2,-48(fp)
20028834:	10a0000c 	andi	r2,r2,32768
20028838:	10002326 	beq	r2,zero,200288c8 <altera_avalon_jtag_uart_irq+0x120>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
2002883c:	e0bff617 	ldw	r2,-40(fp)
20028840:	10800d17 	ldw	r2,52(r2)
20028844:	e0fff417 	ldw	r3,-48(fp)
20028848:	1809883a 	mov	r4,r3
2002884c:	e0fff617 	ldw	r3,-40(fp)
20028850:	1885883a 	add	r2,r3,r2
20028854:	10801104 	addi	r2,r2,68
20028858:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2002885c:	e0bff617 	ldw	r2,-40(fp)
20028860:	10800d17 	ldw	r2,52(r2)
20028864:	10800044 	addi	r2,r2,1
20028868:	10c1ffcc 	andi	r3,r2,2047
2002886c:	e0bff617 	ldw	r2,-40(fp)
20028870:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
20028874:	e0bff617 	ldw	r2,-40(fp)
20028878:	10800c17 	ldw	r2,48(r2)
2002887c:	e0bffb15 	stw	r2,-20(fp)
20028880:	00800044 	movi	r2,1
20028884:	e0bffc0d 	sth	r2,-16(fp)
20028888:	00800044 	movi	r2,1
2002888c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
20028890:	d0a5f643 	ldbu	r2,-26663(gp)
20028894:	10803fcc 	andi	r2,r2,255
20028898:	103fd926 	beq	r2,zero,20028800 <__alt_data_end+0xfffe8800>
  {
    OSFlagPost (group, flags, opt, &err);
2002889c:	e0bffc0b 	ldhu	r2,-16(fp)
200288a0:	e0fffc83 	ldbu	r3,-14(fp)
200288a4:	e13ffdc4 	addi	r4,fp,-9
200288a8:	200f883a 	mov	r7,r4
200288ac:	180d883a 	mov	r6,r3
200288b0:	100b883a 	mov	r5,r2
200288b4:	e13ffb17 	ldw	r4,-20(fp)
200288b8:	0023c000 	call	20023c00 <OSFlagPost>
      }
200288bc:	003fd006 	br	20028800 <__alt_data_end+0xfffe8800>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
200288c0:	0001883a 	nop
200288c4:	00000106 	br	200288cc <altera_avalon_jtag_uart_irq+0x124>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
200288c8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
200288cc:	e0bff417 	ldw	r2,-48(fp)
200288d0:	10bfffec 	andhi	r2,r2,65535
200288d4:	10000f26 	beq	r2,zero,20028914 <altera_avalon_jtag_uart_irq+0x16c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
200288d8:	e0bff617 	ldw	r2,-40(fp)
200288dc:	10c00817 	ldw	r3,32(r2)
200288e0:	00bfff84 	movi	r2,-2
200288e4:	1886703a 	and	r3,r3,r2
200288e8:	e0bff617 	ldw	r2,-40(fp)
200288ec:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
200288f0:	e0bff717 	ldw	r2,-36(fp)
200288f4:	10800104 	addi	r2,r2,4
200288f8:	1007883a 	mov	r3,r2
200288fc:	e0bff617 	ldw	r2,-40(fp)
20028900:	10800817 	ldw	r2,32(r2)
20028904:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
20028908:	e0bff717 	ldw	r2,-36(fp)
2002890c:	10800104 	addi	r2,r2,4
20028910:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
20028914:	e0bff817 	ldw	r2,-32(fp)
20028918:	1080800c 	andi	r2,r2,512
2002891c:	103fac26 	beq	r2,zero,200287d0 <__alt_data_end+0xfffe87d0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
20028920:	e0bff817 	ldw	r2,-32(fp)
20028924:	1004d43a 	srli	r2,r2,16
20028928:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
2002892c:	00002606 	br	200289c8 <altera_avalon_jtag_uart_irq+0x220>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
20028930:	e0bff717 	ldw	r2,-36(fp)
20028934:	e0fff617 	ldw	r3,-40(fp)
20028938:	18c01017 	ldw	r3,64(r3)
2002893c:	e13ff617 	ldw	r4,-40(fp)
20028940:	20c7883a 	add	r3,r4,r3
20028944:	18c21104 	addi	r3,r3,2116
20028948:	18c00003 	ldbu	r3,0(r3)
2002894c:	18c03fcc 	andi	r3,r3,255
20028950:	18c0201c 	xori	r3,r3,128
20028954:	18ffe004 	addi	r3,r3,-128
20028958:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2002895c:	e0bff617 	ldw	r2,-40(fp)
20028960:	10801017 	ldw	r2,64(r2)
20028964:	10800044 	addi	r2,r2,1
20028968:	10c1ffcc 	andi	r3,r2,2047
2002896c:	e0bff617 	ldw	r2,-40(fp)
20028970:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
20028974:	e0bff617 	ldw	r2,-40(fp)
20028978:	10800c17 	ldw	r2,48(r2)
2002897c:	e0bffa15 	stw	r2,-24(fp)
20028980:	00800084 	movi	r2,2
20028984:	e0bffd0d 	sth	r2,-12(fp)
20028988:	00800044 	movi	r2,1
2002898c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
20028990:	d0a5f643 	ldbu	r2,-26663(gp)
20028994:	10803fcc 	andi	r2,r2,255
20028998:	10000826 	beq	r2,zero,200289bc <altera_avalon_jtag_uart_irq+0x214>
  {
    OSFlagPost (group, flags, opt, &err);
2002899c:	e0bffd0b 	ldhu	r2,-12(fp)
200289a0:	e0fffd83 	ldbu	r3,-10(fp)
200289a4:	e13ffe04 	addi	r4,fp,-8
200289a8:	200f883a 	mov	r7,r4
200289ac:	180d883a 	mov	r6,r3
200289b0:	100b883a 	mov	r5,r2
200289b4:	e13ffa17 	ldw	r4,-24(fp)
200289b8:	0023c000 	call	20023c00 <OSFlagPost>

        space--;
200289bc:	e0bff517 	ldw	r2,-44(fp)
200289c0:	10bfffc4 	addi	r2,r2,-1
200289c4:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
200289c8:	e0bff517 	ldw	r2,-44(fp)
200289cc:	10000526 	beq	r2,zero,200289e4 <altera_avalon_jtag_uart_irq+0x23c>
200289d0:	e0bff617 	ldw	r2,-40(fp)
200289d4:	10c01017 	ldw	r3,64(r2)
200289d8:	e0bff617 	ldw	r2,-40(fp)
200289dc:	10800f17 	ldw	r2,60(r2)
200289e0:	18bfd31e 	bne	r3,r2,20028930 <__alt_data_end+0xfffe8930>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
200289e4:	e0bff517 	ldw	r2,-44(fp)
200289e8:	103f7926 	beq	r2,zero,200287d0 <__alt_data_end+0xfffe87d0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
200289ec:	e0bff617 	ldw	r2,-40(fp)
200289f0:	10c00817 	ldw	r3,32(r2)
200289f4:	00bfff44 	movi	r2,-3
200289f8:	1886703a 	and	r3,r3,r2
200289fc:	e0bff617 	ldw	r2,-40(fp)
20028a00:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
20028a04:	e0bff617 	ldw	r2,-40(fp)
20028a08:	10800017 	ldw	r2,0(r2)
20028a0c:	10800104 	addi	r2,r2,4
20028a10:	1007883a 	mov	r3,r2
20028a14:	e0bff617 	ldw	r2,-40(fp)
20028a18:	10800817 	ldw	r2,32(r2)
20028a1c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
20028a20:	e0bff717 	ldw	r2,-36(fp)
20028a24:	10800104 	addi	r2,r2,4
20028a28:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
20028a2c:	003f6806 	br	200287d0 <__alt_data_end+0xfffe87d0>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
20028a30:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
20028a34:	0001883a 	nop
20028a38:	e037883a 	mov	sp,fp
20028a3c:	dfc00117 	ldw	ra,4(sp)
20028a40:	df000017 	ldw	fp,0(sp)
20028a44:	dec00204 	addi	sp,sp,8
20028a48:	f800283a 	ret

20028a4c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
20028a4c:	defff904 	addi	sp,sp,-28
20028a50:	dfc00615 	stw	ra,24(sp)
20028a54:	df000515 	stw	fp,20(sp)
20028a58:	df000504 	addi	fp,sp,20
20028a5c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
20028a60:	e0bfff17 	ldw	r2,-4(fp)
20028a64:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
20028a68:	e0bffb17 	ldw	r2,-20(fp)
20028a6c:	10800017 	ldw	r2,0(r2)
20028a70:	10800104 	addi	r2,r2,4
20028a74:	10800037 	ldwio	r2,0(r2)
20028a78:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
20028a7c:	e0bffc17 	ldw	r2,-16(fp)
20028a80:	1081000c 	andi	r2,r2,1024
20028a84:	10000b26 	beq	r2,zero,20028ab4 <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
20028a88:	e0bffb17 	ldw	r2,-20(fp)
20028a8c:	10800017 	ldw	r2,0(r2)
20028a90:	10800104 	addi	r2,r2,4
20028a94:	1007883a 	mov	r3,r2
20028a98:	e0bffb17 	ldw	r2,-20(fp)
20028a9c:	10800817 	ldw	r2,32(r2)
20028aa0:	10810014 	ori	r2,r2,1024
20028aa4:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
20028aa8:	e0bffb17 	ldw	r2,-20(fp)
20028aac:	10000915 	stw	zero,36(r2)
20028ab0:	00002106 	br	20028b38 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
20028ab4:	e0bffb17 	ldw	r2,-20(fp)
20028ab8:	10c00917 	ldw	r3,36(r2)
20028abc:	00a00034 	movhi	r2,32768
20028ac0:	10bfff04 	addi	r2,r2,-4
20028ac4:	10c01c36 	bltu	r2,r3,20028b38 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
20028ac8:	e0bffb17 	ldw	r2,-20(fp)
20028acc:	10800917 	ldw	r2,36(r2)
20028ad0:	10c00044 	addi	r3,r2,1
20028ad4:	e0bffb17 	ldw	r2,-20(fp)
20028ad8:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
20028adc:	e0bffb17 	ldw	r2,-20(fp)
20028ae0:	10c00917 	ldw	r3,36(r2)
20028ae4:	e0bffb17 	ldw	r2,-20(fp)
20028ae8:	10800117 	ldw	r2,4(r2)
20028aec:	18801236 	bltu	r3,r2,20028b38 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
20028af0:	e0bffb17 	ldw	r2,-20(fp)
20028af4:	10800c17 	ldw	r2,48(r2)
20028af8:	e0bffd15 	stw	r2,-12(fp)
20028afc:	00800104 	movi	r2,4
20028b00:	e0bffe0d 	sth	r2,-8(fp)
20028b04:	00800044 	movi	r2,1
20028b08:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
20028b0c:	d0a5f643 	ldbu	r2,-26663(gp)
20028b10:	10803fcc 	andi	r2,r2,255
20028b14:	10000826 	beq	r2,zero,20028b38 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
20028b18:	e0bffe0b 	ldhu	r2,-8(fp)
20028b1c:	e0fffe83 	ldbu	r3,-6(fp)
20028b20:	e13ffec4 	addi	r4,fp,-5
20028b24:	200f883a 	mov	r7,r4
20028b28:	180d883a 	mov	r6,r3
20028b2c:	100b883a 	mov	r5,r2
20028b30:	e13ffd17 	ldw	r4,-12(fp)
20028b34:	0023c000 	call	20023c00 <OSFlagPost>
20028b38:	d0a60c17 	ldw	r2,-26576(gp)
    }
  }

  return alt_ticks_per_second();
}
20028b3c:	e037883a 	mov	sp,fp
20028b40:	dfc00117 	ldw	ra,4(sp)
20028b44:	df000017 	ldw	fp,0(sp)
20028b48:	dec00204 	addi	sp,sp,8
20028b4c:	f800283a 	ret

20028b50 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
20028b50:	defffd04 	addi	sp,sp,-12
20028b54:	df000215 	stw	fp,8(sp)
20028b58:	df000204 	addi	fp,sp,8
20028b5c:	e13ffe15 	stw	r4,-8(fp)
20028b60:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
20028b64:	00000506 	br	20028b7c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
20028b68:	e0bfff17 	ldw	r2,-4(fp)
20028b6c:	1090000c 	andi	r2,r2,16384
20028b70:	10000226 	beq	r2,zero,20028b7c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
20028b74:	00bffd44 	movi	r2,-11
20028b78:	00000b06 	br	20028ba8 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
20028b7c:	e0bffe17 	ldw	r2,-8(fp)
20028b80:	10c01017 	ldw	r3,64(r2)
20028b84:	e0bffe17 	ldw	r2,-8(fp)
20028b88:	10800f17 	ldw	r2,60(r2)
20028b8c:	18800526 	beq	r3,r2,20028ba4 <altera_avalon_jtag_uart_close+0x54>
20028b90:	e0bffe17 	ldw	r2,-8(fp)
20028b94:	10c00917 	ldw	r3,36(r2)
20028b98:	e0bffe17 	ldw	r2,-8(fp)
20028b9c:	10800117 	ldw	r2,4(r2)
20028ba0:	18bff136 	bltu	r3,r2,20028b68 <__alt_data_end+0xfffe8b68>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
20028ba4:	0005883a 	mov	r2,zero
}
20028ba8:	e037883a 	mov	sp,fp
20028bac:	df000017 	ldw	fp,0(sp)
20028bb0:	dec00104 	addi	sp,sp,4
20028bb4:	f800283a 	ret

20028bb8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
20028bb8:	defffa04 	addi	sp,sp,-24
20028bbc:	df000515 	stw	fp,20(sp)
20028bc0:	df000504 	addi	fp,sp,20
20028bc4:	e13ffd15 	stw	r4,-12(fp)
20028bc8:	e17ffe15 	stw	r5,-8(fp)
20028bcc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
20028bd0:	00bff9c4 	movi	r2,-25
20028bd4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
20028bd8:	e0bffe17 	ldw	r2,-8(fp)
20028bdc:	10da8060 	cmpeqi	r3,r2,27137
20028be0:	1800031e 	bne	r3,zero,20028bf0 <altera_avalon_jtag_uart_ioctl+0x38>
20028be4:	109a80a0 	cmpeqi	r2,r2,27138
20028be8:	1000181e 	bne	r2,zero,20028c4c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
20028bec:	00002906 	br	20028c94 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
20028bf0:	e0bffd17 	ldw	r2,-12(fp)
20028bf4:	10c00117 	ldw	r3,4(r2)
20028bf8:	00a00034 	movhi	r2,32768
20028bfc:	10bfffc4 	addi	r2,r2,-1
20028c00:	18802126 	beq	r3,r2,20028c88 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
20028c04:	e0bfff17 	ldw	r2,-4(fp)
20028c08:	10800017 	ldw	r2,0(r2)
20028c0c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
20028c10:	e0bffc17 	ldw	r2,-16(fp)
20028c14:	10800090 	cmplti	r2,r2,2
20028c18:	1000061e 	bne	r2,zero,20028c34 <altera_avalon_jtag_uart_ioctl+0x7c>
20028c1c:	e0fffc17 	ldw	r3,-16(fp)
20028c20:	00a00034 	movhi	r2,32768
20028c24:	10bfffc4 	addi	r2,r2,-1
20028c28:	18800226 	beq	r3,r2,20028c34 <altera_avalon_jtag_uart_ioctl+0x7c>
20028c2c:	e0bffc17 	ldw	r2,-16(fp)
20028c30:	00000206 	br	20028c3c <altera_avalon_jtag_uart_ioctl+0x84>
20028c34:	00a00034 	movhi	r2,32768
20028c38:	10bfff84 	addi	r2,r2,-2
20028c3c:	e0fffd17 	ldw	r3,-12(fp)
20028c40:	18800115 	stw	r2,4(r3)
      rc = 0;
20028c44:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
20028c48:	00000f06 	br	20028c88 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
20028c4c:	e0bffd17 	ldw	r2,-12(fp)
20028c50:	10c00117 	ldw	r3,4(r2)
20028c54:	00a00034 	movhi	r2,32768
20028c58:	10bfffc4 	addi	r2,r2,-1
20028c5c:	18800c26 	beq	r3,r2,20028c90 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
20028c60:	e0bffd17 	ldw	r2,-12(fp)
20028c64:	10c00917 	ldw	r3,36(r2)
20028c68:	e0bffd17 	ldw	r2,-12(fp)
20028c6c:	10800117 	ldw	r2,4(r2)
20028c70:	1885803a 	cmpltu	r2,r3,r2
20028c74:	10c03fcc 	andi	r3,r2,255
20028c78:	e0bfff17 	ldw	r2,-4(fp)
20028c7c:	10c00015 	stw	r3,0(r2)
      rc = 0;
20028c80:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
20028c84:	00000206 	br	20028c90 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
20028c88:	0001883a 	nop
20028c8c:	00000106 	br	20028c94 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
20028c90:	0001883a 	nop

  default:
    break;
  }

  return rc;
20028c94:	e0bffb17 	ldw	r2,-20(fp)
}
20028c98:	e037883a 	mov	sp,fp
20028c9c:	df000017 	ldw	fp,0(sp)
20028ca0:	dec00104 	addi	sp,sp,4
20028ca4:	f800283a 	ret

20028ca8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
20028ca8:	deffed04 	addi	sp,sp,-76
20028cac:	dfc01215 	stw	ra,72(sp)
20028cb0:	df001115 	stw	fp,68(sp)
20028cb4:	df001104 	addi	fp,sp,68
20028cb8:	e13ffc15 	stw	r4,-16(fp)
20028cbc:	e17ffd15 	stw	r5,-12(fp)
20028cc0:	e1bffe15 	stw	r6,-8(fp)
20028cc4:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
20028cc8:	e0bffd17 	ldw	r2,-12(fp)
20028ccc:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
20028cd0:	e0bffc17 	ldw	r2,-16(fp)
20028cd4:	10800a17 	ldw	r2,40(r2)
20028cd8:	e0bff815 	stw	r2,-32(fp)
20028cdc:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
20028ce0:	e0bff90b 	ldhu	r2,-28(fp)
20028ce4:	e0fffb04 	addi	r3,fp,-20
20028ce8:	180d883a 	mov	r6,r3
20028cec:	100b883a 	mov	r5,r2
20028cf0:	e13ff817 	ldw	r4,-32(fp)
20028cf4:	00260500 	call	20026050 <OSSemPend>

  while (space > 0)
20028cf8:	00006106 	br	20028e80 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
20028cfc:	e0bffc17 	ldw	r2,-16(fp)
20028d00:	10800d17 	ldw	r2,52(r2)
20028d04:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
20028d08:	e0bffc17 	ldw	r2,-16(fp)
20028d0c:	10800e17 	ldw	r2,56(r2)
20028d10:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
20028d14:	e0fff317 	ldw	r3,-52(fp)
20028d18:	e0bff417 	ldw	r2,-48(fp)
20028d1c:	18800536 	bltu	r3,r2,20028d34 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
20028d20:	e0fff317 	ldw	r3,-52(fp)
20028d24:	e0bff417 	ldw	r2,-48(fp)
20028d28:	1885c83a 	sub	r2,r3,r2
20028d2c:	e0bff115 	stw	r2,-60(fp)
20028d30:	00000406 	br	20028d44 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
20028d34:	00c20004 	movi	r3,2048
20028d38:	e0bff417 	ldw	r2,-48(fp)
20028d3c:	1885c83a 	sub	r2,r3,r2
20028d40:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
20028d44:	e0bff117 	ldw	r2,-60(fp)
20028d48:	10001e26 	beq	r2,zero,20028dc4 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
20028d4c:	e0fffe17 	ldw	r3,-8(fp)
20028d50:	e0bff117 	ldw	r2,-60(fp)
20028d54:	1880022e 	bgeu	r3,r2,20028d60 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
20028d58:	e0bffe17 	ldw	r2,-8(fp)
20028d5c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
20028d60:	e0bffc17 	ldw	r2,-16(fp)
20028d64:	10c01104 	addi	r3,r2,68
20028d68:	e0bff417 	ldw	r2,-48(fp)
20028d6c:	1885883a 	add	r2,r3,r2
20028d70:	e1bff117 	ldw	r6,-60(fp)
20028d74:	100b883a 	mov	r5,r2
20028d78:	e13ff017 	ldw	r4,-64(fp)
20028d7c:	002a8680 	call	2002a868 <memcpy>
      ptr   += n;
20028d80:	e0fff017 	ldw	r3,-64(fp)
20028d84:	e0bff117 	ldw	r2,-60(fp)
20028d88:	1885883a 	add	r2,r3,r2
20028d8c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
20028d90:	e0fffe17 	ldw	r3,-8(fp)
20028d94:	e0bff117 	ldw	r2,-60(fp)
20028d98:	1885c83a 	sub	r2,r3,r2
20028d9c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
20028da0:	e0fff417 	ldw	r3,-48(fp)
20028da4:	e0bff117 	ldw	r2,-60(fp)
20028da8:	1885883a 	add	r2,r3,r2
20028dac:	10c1ffcc 	andi	r3,r2,2047
20028db0:	e0bffc17 	ldw	r2,-16(fp)
20028db4:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
20028db8:	e0bffe17 	ldw	r2,-8(fp)
20028dbc:	00bfcf16 	blt	zero,r2,20028cfc <__alt_data_end+0xfffe8cfc>
20028dc0:	00000106 	br	20028dc8 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
20028dc4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
20028dc8:	e0fff017 	ldw	r3,-64(fp)
20028dcc:	e0bffd17 	ldw	r2,-12(fp)
20028dd0:	18802e1e 	bne	r3,r2,20028e8c <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
20028dd4:	e0bfff17 	ldw	r2,-4(fp)
20028dd8:	1090000c 	andi	r2,r2,16384
20028ddc:	10002d1e 	bne	r2,zero,20028e94 <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
20028de0:	d0a5f643 	ldbu	r2,-26663(gp)
20028de4:	10803fcc 	andi	r2,r2,255
20028de8:	10800058 	cmpnei	r2,r2,1
20028dec:	1000161e 	bne	r2,zero,20028e48 <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
20028df0:	e0bffc17 	ldw	r2,-16(fp)
20028df4:	10800c17 	ldw	r2,48(r2)
20028df8:	e0bff215 	stw	r2,-56(fp)
20028dfc:	00800144 	movi	r2,5
20028e00:	e0bff98d 	sth	r2,-26(fp)
20028e04:	00bfe0c4 	movi	r2,-125
20028e08:	e0bffa05 	stb	r2,-24(fp)
20028e0c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
20028e10:	d0a5f643 	ldbu	r2,-26663(gp)
20028e14:	10803fcc 	andi	r2,r2,255
20028e18:	10001526 	beq	r2,zero,20028e70 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
20028e1c:	e0fff98b 	ldhu	r3,-26(fp)
20028e20:	e13ffa03 	ldbu	r4,-24(fp)
20028e24:	e17ffa8b 	ldhu	r5,-22(fp)
20028e28:	e0bffb44 	addi	r2,fp,-19
20028e2c:	d8800015 	stw	r2,0(sp)
20028e30:	280f883a 	mov	r7,r5
20028e34:	200d883a 	mov	r6,r4
20028e38:	180b883a 	mov	r5,r3
20028e3c:	e13ff217 	ldw	r4,-56(fp)
20028e40:	00235e80 	call	200235e8 <OSFlagPend>
20028e44:	00000a06 	br	20028e70 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
20028e48:	0001883a 	nop
20028e4c:	e0bffc17 	ldw	r2,-16(fp)
20028e50:	10c00d17 	ldw	r3,52(r2)
20028e54:	e0bff317 	ldw	r2,-52(fp)
20028e58:	1880051e 	bne	r3,r2,20028e70 <altera_avalon_jtag_uart_read+0x1c8>
20028e5c:	e0bffc17 	ldw	r2,-16(fp)
20028e60:	10c00917 	ldw	r3,36(r2)
20028e64:	e0bffc17 	ldw	r2,-16(fp)
20028e68:	10800117 	ldw	r2,4(r2)
20028e6c:	18bff736 	bltu	r3,r2,20028e4c <__alt_data_end+0xfffe8e4c>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
20028e70:	e0bffc17 	ldw	r2,-16(fp)
20028e74:	10c00d17 	ldw	r3,52(r2)
20028e78:	e0bff317 	ldw	r2,-52(fp)
20028e7c:	18800726 	beq	r3,r2,20028e9c <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
20028e80:	e0bffe17 	ldw	r2,-8(fp)
20028e84:	00bf9d16 	blt	zero,r2,20028cfc <__alt_data_end+0xfffe8cfc>
20028e88:	00000506 	br	20028ea0 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
20028e8c:	0001883a 	nop
20028e90:	00000306 	br	20028ea0 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
20028e94:	0001883a 	nop
20028e98:	00000106 	br	20028ea0 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
20028e9c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
20028ea0:	e0bffc17 	ldw	r2,-16(fp)
20028ea4:	10800a17 	ldw	r2,40(r2)
20028ea8:	1009883a 	mov	r4,r2
20028eac:	00263c80 	call	200263c8 <OSSemPost>

  if (ptr != buffer)
20028eb0:	e0fff017 	ldw	r3,-64(fp)
20028eb4:	e0bffd17 	ldw	r2,-12(fp)
20028eb8:	18801826 	beq	r3,r2,20028f1c <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20028ebc:	0005303a 	rdctl	r2,status
20028ec0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20028ec4:	e0fff717 	ldw	r3,-36(fp)
20028ec8:	00bfff84 	movi	r2,-2
20028ecc:	1884703a 	and	r2,r3,r2
20028ed0:	1001703a 	wrctl	status,r2
  
  return context;
20028ed4:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
20028ed8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
20028edc:	e0bffc17 	ldw	r2,-16(fp)
20028ee0:	10800817 	ldw	r2,32(r2)
20028ee4:	10c00054 	ori	r3,r2,1
20028ee8:	e0bffc17 	ldw	r2,-16(fp)
20028eec:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
20028ef0:	e0bffc17 	ldw	r2,-16(fp)
20028ef4:	10800017 	ldw	r2,0(r2)
20028ef8:	10800104 	addi	r2,r2,4
20028efc:	1007883a 	mov	r3,r2
20028f00:	e0bffc17 	ldw	r2,-16(fp)
20028f04:	10800817 	ldw	r2,32(r2)
20028f08:	18800035 	stwio	r2,0(r3)
20028f0c:	e0bff617 	ldw	r2,-40(fp)
20028f10:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20028f14:	e0bff517 	ldw	r2,-44(fp)
20028f18:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
20028f1c:	e0fff017 	ldw	r3,-64(fp)
20028f20:	e0bffd17 	ldw	r2,-12(fp)
20028f24:	18800426 	beq	r3,r2,20028f38 <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
20028f28:	e0fff017 	ldw	r3,-64(fp)
20028f2c:	e0bffd17 	ldw	r2,-12(fp)
20028f30:	1885c83a 	sub	r2,r3,r2
20028f34:	00000606 	br	20028f50 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
20028f38:	e0bfff17 	ldw	r2,-4(fp)
20028f3c:	1090000c 	andi	r2,r2,16384
20028f40:	10000226 	beq	r2,zero,20028f4c <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
20028f44:	00bffd44 	movi	r2,-11
20028f48:	00000106 	br	20028f50 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
20028f4c:	00bffec4 	movi	r2,-5
}
20028f50:	e037883a 	mov	sp,fp
20028f54:	dfc00117 	ldw	ra,4(sp)
20028f58:	df000017 	ldw	fp,0(sp)
20028f5c:	dec00204 	addi	sp,sp,8
20028f60:	f800283a 	ret

20028f64 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
20028f64:	deffed04 	addi	sp,sp,-76
20028f68:	dfc01215 	stw	ra,72(sp)
20028f6c:	df001115 	stw	fp,68(sp)
20028f70:	df001104 	addi	fp,sp,68
20028f74:	e13ffc15 	stw	r4,-16(fp)
20028f78:	e17ffd15 	stw	r5,-12(fp)
20028f7c:	e1bffe15 	stw	r6,-8(fp)
20028f80:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
20028f84:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
20028f88:	e0bffd17 	ldw	r2,-12(fp)
20028f8c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
20028f90:	e0bffc17 	ldw	r2,-16(fp)
20028f94:	10800b17 	ldw	r2,44(r2)
20028f98:	e0bff815 	stw	r2,-32(fp)
20028f9c:	e03ff90d 	sth	zero,-28(fp)
20028fa0:	e0bff90b 	ldhu	r2,-28(fp)
20028fa4:	e0fffb44 	addi	r3,fp,-19
20028fa8:	180d883a 	mov	r6,r3
20028fac:	100b883a 	mov	r5,r2
20028fb0:	e13ff817 	ldw	r4,-32(fp)
20028fb4:	00260500 	call	20026050 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
20028fb8:	00003706 	br	20029098 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
20028fbc:	e0bffc17 	ldw	r2,-16(fp)
20028fc0:	10800f17 	ldw	r2,60(r2)
20028fc4:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
20028fc8:	e0bffc17 	ldw	r2,-16(fp)
20028fcc:	10801017 	ldw	r2,64(r2)
20028fd0:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
20028fd4:	e0fff417 	ldw	r3,-48(fp)
20028fd8:	e0bff017 	ldw	r2,-64(fp)
20028fdc:	1880062e 	bgeu	r3,r2,20028ff8 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
20028fe0:	e0fff017 	ldw	r3,-64(fp)
20028fe4:	e0bff417 	ldw	r2,-48(fp)
20028fe8:	1885c83a 	sub	r2,r3,r2
20028fec:	10bfffc4 	addi	r2,r2,-1
20028ff0:	e0bff115 	stw	r2,-60(fp)
20028ff4:	00000b06 	br	20029024 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
20028ff8:	e0bff017 	ldw	r2,-64(fp)
20028ffc:	10000526 	beq	r2,zero,20029014 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
20029000:	00c20004 	movi	r3,2048
20029004:	e0bff417 	ldw	r2,-48(fp)
20029008:	1885c83a 	sub	r2,r3,r2
2002900c:	e0bff115 	stw	r2,-60(fp)
20029010:	00000406 	br	20029024 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
20029014:	00c1ffc4 	movi	r3,2047
20029018:	e0bff417 	ldw	r2,-48(fp)
2002901c:	1885c83a 	sub	r2,r3,r2
20029020:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
20029024:	e0bff117 	ldw	r2,-60(fp)
20029028:	10001e26 	beq	r2,zero,200290a4 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
2002902c:	e0fffe17 	ldw	r3,-8(fp)
20029030:	e0bff117 	ldw	r2,-60(fp)
20029034:	1880022e 	bgeu	r3,r2,20029040 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
20029038:	e0bffe17 	ldw	r2,-8(fp)
2002903c:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
20029040:	e0bffc17 	ldw	r2,-16(fp)
20029044:	10c21104 	addi	r3,r2,2116
20029048:	e0bff417 	ldw	r2,-48(fp)
2002904c:	1885883a 	add	r2,r3,r2
20029050:	e1bff117 	ldw	r6,-60(fp)
20029054:	e17ffd17 	ldw	r5,-12(fp)
20029058:	1009883a 	mov	r4,r2
2002905c:	002a8680 	call	2002a868 <memcpy>
      ptr   += n;
20029060:	e0fffd17 	ldw	r3,-12(fp)
20029064:	e0bff117 	ldw	r2,-60(fp)
20029068:	1885883a 	add	r2,r3,r2
2002906c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
20029070:	e0fffe17 	ldw	r3,-8(fp)
20029074:	e0bff117 	ldw	r2,-60(fp)
20029078:	1885c83a 	sub	r2,r3,r2
2002907c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
20029080:	e0fff417 	ldw	r3,-48(fp)
20029084:	e0bff117 	ldw	r2,-60(fp)
20029088:	1885883a 	add	r2,r3,r2
2002908c:	10c1ffcc 	andi	r3,r2,2047
20029090:	e0bffc17 	ldw	r2,-16(fp)
20029094:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
20029098:	e0bffe17 	ldw	r2,-8(fp)
2002909c:	00bfc716 	blt	zero,r2,20028fbc <__alt_data_end+0xfffe8fbc>
200290a0:	00000106 	br	200290a8 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
200290a4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200290a8:	0005303a 	rdctl	r2,status
200290ac:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200290b0:	e0fff717 	ldw	r3,-36(fp)
200290b4:	00bfff84 	movi	r2,-2
200290b8:	1884703a 	and	r2,r3,r2
200290bc:	1001703a 	wrctl	status,r2
  
  return context;
200290c0:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
200290c4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
200290c8:	e0bffc17 	ldw	r2,-16(fp)
200290cc:	10800817 	ldw	r2,32(r2)
200290d0:	10c00094 	ori	r3,r2,2
200290d4:	e0bffc17 	ldw	r2,-16(fp)
200290d8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
200290dc:	e0bffc17 	ldw	r2,-16(fp)
200290e0:	10800017 	ldw	r2,0(r2)
200290e4:	10800104 	addi	r2,r2,4
200290e8:	1007883a 	mov	r3,r2
200290ec:	e0bffc17 	ldw	r2,-16(fp)
200290f0:	10800817 	ldw	r2,32(r2)
200290f4:	18800035 	stwio	r2,0(r3)
200290f8:	e0bff617 	ldw	r2,-40(fp)
200290fc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20029100:	e0bff317 	ldw	r2,-52(fp)
20029104:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
20029108:	e0bffe17 	ldw	r2,-8(fp)
2002910c:	00802a0e 	bge	zero,r2,200291b8 <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
20029110:	e0bfff17 	ldw	r2,-4(fp)
20029114:	1090000c 	andi	r2,r2,16384
20029118:	10002a1e 	bne	r2,zero,200291c4 <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
2002911c:	d0a5f643 	ldbu	r2,-26663(gp)
20029120:	10803fcc 	andi	r2,r2,255
20029124:	10800058 	cmpnei	r2,r2,1
20029128:	1000161e 	bne	r2,zero,20029184 <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
2002912c:	e0bffc17 	ldw	r2,-16(fp)
20029130:	10800c17 	ldw	r2,48(r2)
20029134:	e0bff515 	stw	r2,-44(fp)
20029138:	00800184 	movi	r2,6
2002913c:	e0bff98d 	sth	r2,-26(fp)
20029140:	00bfe0c4 	movi	r2,-125
20029144:	e0bffa05 	stb	r2,-24(fp)
20029148:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
2002914c:	d0a5f643 	ldbu	r2,-26663(gp)
20029150:	10803fcc 	andi	r2,r2,255
20029154:	10001526 	beq	r2,zero,200291ac <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
20029158:	e0fff98b 	ldhu	r3,-26(fp)
2002915c:	e13ffa03 	ldbu	r4,-24(fp)
20029160:	e17ffa8b 	ldhu	r5,-22(fp)
20029164:	e0bffb04 	addi	r2,fp,-20
20029168:	d8800015 	stw	r2,0(sp)
2002916c:	280f883a 	mov	r7,r5
20029170:	200d883a 	mov	r6,r4
20029174:	180b883a 	mov	r5,r3
20029178:	e13ff517 	ldw	r4,-44(fp)
2002917c:	00235e80 	call	200235e8 <OSFlagPend>
20029180:	00000a06 	br	200291ac <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
20029184:	0001883a 	nop
20029188:	e0bffc17 	ldw	r2,-16(fp)
2002918c:	10c01017 	ldw	r3,64(r2)
20029190:	e0bff017 	ldw	r2,-64(fp)
20029194:	1880051e 	bne	r3,r2,200291ac <altera_avalon_jtag_uart_write+0x248>
20029198:	e0bffc17 	ldw	r2,-16(fp)
2002919c:	10c00917 	ldw	r3,36(r2)
200291a0:	e0bffc17 	ldw	r2,-16(fp)
200291a4:	10800117 	ldw	r2,4(r2)
200291a8:	18bff736 	bltu	r3,r2,20029188 <__alt_data_end+0xfffe9188>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
200291ac:	e0bffc17 	ldw	r2,-16(fp)
200291b0:	10800917 	ldw	r2,36(r2)
200291b4:	1000051e 	bne	r2,zero,200291cc <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
200291b8:	e0bffe17 	ldw	r2,-8(fp)
200291bc:	00bfb616 	blt	zero,r2,20029098 <__alt_data_end+0xfffe9098>
200291c0:	00000306 	br	200291d0 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
200291c4:	0001883a 	nop
200291c8:	00000106 	br	200291d0 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
200291cc:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
200291d0:	e0bffc17 	ldw	r2,-16(fp)
200291d4:	10800b17 	ldw	r2,44(r2)
200291d8:	1009883a 	mov	r4,r2
200291dc:	00263c80 	call	200263c8 <OSSemPost>

  if (ptr != start)
200291e0:	e0fffd17 	ldw	r3,-12(fp)
200291e4:	e0bff217 	ldw	r2,-56(fp)
200291e8:	18800426 	beq	r3,r2,200291fc <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
200291ec:	e0fffd17 	ldw	r3,-12(fp)
200291f0:	e0bff217 	ldw	r2,-56(fp)
200291f4:	1885c83a 	sub	r2,r3,r2
200291f8:	00000606 	br	20029214 <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
200291fc:	e0bfff17 	ldw	r2,-4(fp)
20029200:	1090000c 	andi	r2,r2,16384
20029204:	10000226 	beq	r2,zero,20029210 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
20029208:	00bffd44 	movi	r2,-11
2002920c:	00000106 	br	20029214 <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
20029210:	00bffec4 	movi	r2,-5
}
20029214:	e037883a 	mov	sp,fp
20029218:	dfc00117 	ldw	ra,4(sp)
2002921c:	df000017 	ldw	fp,0(sp)
20029220:	dec00204 	addi	sp,sp,8
20029224:	f800283a 	ret

20029228 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
20029228:	defffe04 	addi	sp,sp,-8
2002922c:	dfc00115 	stw	ra,4(sp)
20029230:	df000015 	stw	fp,0(sp)
20029234:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
20029238:	d0a02717 	ldw	r2,-32612(gp)
2002923c:	10000326 	beq	r2,zero,2002924c <alt_get_errno+0x24>
20029240:	d0a02717 	ldw	r2,-32612(gp)
20029244:	103ee83a 	callr	r2
20029248:	00000106 	br	20029250 <alt_get_errno+0x28>
2002924c:	d0a60e04 	addi	r2,gp,-26568
}
20029250:	e037883a 	mov	sp,fp
20029254:	dfc00117 	ldw	ra,4(sp)
20029258:	df000017 	ldw	fp,0(sp)
2002925c:	dec00204 	addi	sp,sp,8
20029260:	f800283a 	ret

20029264 <alt_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
static int alt_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
20029264:	defff904 	addi	sp,sp,-28
20029268:	df000615 	stw	fp,24(sp)
2002926c:	df000604 	addi	fp,sp,24
20029270:	e13ffe15 	stw	r4,-8(fp)
20029274:	e17fff15 	stw	r5,-4(fp)
  alt_u32 id, data, check;
  int ret_code = -1;
20029278:	00bfffc4 	movi	r2,-1
2002927c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_READ_CPUID(id);
20029280:	0005317a 	rdctl	r2,cpuid
20029284:	e0bffb15 	stw	r2,-20(fp)

  /* the data we want the mutex to hold */
  data = (id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST) | value;
20029288:	e0bffb17 	ldw	r2,-20(fp)
2002928c:	1006943a 	slli	r3,r2,16
20029290:	e0bfff17 	ldw	r2,-4(fp)
20029294:	1884b03a 	or	r2,r3,r2
20029298:	e0bffc15 	stw	r2,-16(fp)

  /* attempt to write to the mutex */
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, data);
2002929c:	e0bffe17 	ldw	r2,-8(fp)
200292a0:	10800317 	ldw	r2,12(r2)
200292a4:	e0fffc17 	ldw	r3,-16(fp)
200292a8:	10c00035 	stwio	r3,0(r2)
  
  check = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
200292ac:	e0bffe17 	ldw	r2,-8(fp)
200292b0:	10800317 	ldw	r2,12(r2)
200292b4:	10800037 	ldwio	r2,0(r2)
200292b8:	e0bffd15 	stw	r2,-12(fp)

  if ( check == data)
200292bc:	e0fffd17 	ldw	r3,-12(fp)
200292c0:	e0bffc17 	ldw	r2,-16(fp)
200292c4:	1880011e 	bne	r3,r2,200292cc <alt_mutex_trylock+0x68>
  {
    ret_code = 0;
200292c8:	e03ffa15 	stw	zero,-24(fp)
  }

  return ret_code;
200292cc:	e0bffa17 	ldw	r2,-24(fp)
}
200292d0:	e037883a 	mov	sp,fp
200292d4:	df000017 	ldw	fp,0(sp)
200292d8:	dec00104 	addi	sp,sp,4
200292dc:	f800283a 	ret

200292e0 <altera_avalon_mutex_open>:
 * Search the list of registered mutexes for one with the supplied name.
 *
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
alt_mutex_dev* altera_avalon_mutex_open (const char* name)
{
200292e0:	defffc04 	addi	sp,sp,-16
200292e4:	dfc00315 	stw	ra,12(sp)
200292e8:	df000215 	stw	fp,8(sp)
200292ec:	df000204 	addi	fp,sp,8
200292f0:	e13fff15 	stw	r4,-4(fp)
  alt_mutex_dev* dev;

  dev = (alt_mutex_dev*) alt_find_dev (name, &alt_mutex_list);
200292f4:	d1602004 	addi	r5,gp,-32640
200292f8:	e13fff17 	ldw	r4,-4(fp)
200292fc:	0029ab40 	call	20029ab4 <alt_find_dev>
20029300:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev)
20029304:	e0bffe17 	ldw	r2,-8(fp)
20029308:	1000041e 	bne	r2,zero,2002931c <altera_avalon_mutex_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
2002930c:	00292280 	call	20029228 <alt_get_errno>
20029310:	1007883a 	mov	r3,r2
20029314:	008004c4 	movi	r2,19
20029318:	18800015 	stw	r2,0(r3)
  }

  return dev;
2002931c:	e0bffe17 	ldw	r2,-8(fp)
}
20029320:	e037883a 	mov	sp,fp
20029324:	dfc00117 	ldw	ra,4(sp)
20029328:	df000017 	ldw	fp,0(sp)
2002932c:	dec00204 	addi	sp,sp,8
20029330:	f800283a 	ret

20029334 <altera_avalon_mutex_close>:
 * altera_avalon_mutex_close - Does nothing at the moment, but included for 
 * completeness
 *
 */
void altera_avalon_mutex_close (alt_mutex_dev* dev)
{
20029334:	defffe04 	addi	sp,sp,-8
20029338:	df000115 	stw	fp,4(sp)
2002933c:	df000104 	addi	fp,sp,4
20029340:	e13fff15 	stw	r4,-4(fp)
  return;
20029344:	0001883a 	nop
}
20029348:	e037883a 	mov	sp,fp
2002934c:	df000017 	ldw	fp,0(sp)
20029350:	dec00104 	addi	sp,sp,4
20029354:	f800283a 	ret

20029358 <altera_avalon_mutex_lock>:
/*
 * altera_avalon_mutex_lock - Lock the hardware mutex
 *
 */
void altera_avalon_mutex_lock( alt_mutex_dev* dev, alt_u32 value )
{
20029358:	defffa04 	addi	sp,sp,-24
2002935c:	dfc00515 	stw	ra,20(sp)
20029360:	df000415 	stw	fp,16(sp)
20029364:	df000404 	addi	fp,sp,16
20029368:	e13ffe15 	stw	r4,-8(fp)
2002936c:	e17fff15 	stw	r5,-4(fp)
  /*
   * When running in a multi threaded environment, obtain the "lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (dev->lock, 0);
20029370:	e0bffe17 	ldw	r2,-8(fp)
20029374:	10800417 	ldw	r2,16(r2)
20029378:	e0bffc15 	stw	r2,-16(fp)
2002937c:	e03ffd0d 	sth	zero,-12(fp)
20029380:	e0bffd0b 	ldhu	r2,-12(fp)
20029384:	e0fffd84 	addi	r3,fp,-10
20029388:	180d883a 	mov	r6,r3
2002938c:	100b883a 	mov	r5,r2
20029390:	e13ffc17 	ldw	r4,-16(fp)
20029394:	00260500 	call	20026050 <OSSemPend>

  while ( alt_mutex_trylock( dev, value ) != 0);
20029398:	0001883a 	nop
2002939c:	e17fff17 	ldw	r5,-4(fp)
200293a0:	e13ffe17 	ldw	r4,-8(fp)
200293a4:	00292640 	call	20029264 <alt_mutex_trylock>
200293a8:	103ffc1e 	bne	r2,zero,2002939c <__alt_data_end+0xfffe939c>
}
200293ac:	0001883a 	nop
200293b0:	e037883a 	mov	sp,fp
200293b4:	dfc00117 	ldw	ra,4(sp)
200293b8:	df000017 	ldw	fp,0(sp)
200293bc:	dec00204 	addi	sp,sp,8
200293c0:	f800283a 	ret

200293c4 <altera_avalon_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
int altera_avalon_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
200293c4:	defff904 	addi	sp,sp,-28
200293c8:	dfc00615 	stw	ra,24(sp)
200293cc:	df000515 	stw	fp,20(sp)
200293d0:	df000504 	addi	fp,sp,20
200293d4:	e13ffe15 	stw	r4,-8(fp)
200293d8:	e17fff15 	stw	r5,-4(fp)
  int ret_code;

  ALT_SEM_PEND (dev->lock, 0);
200293dc:	e0bffe17 	ldw	r2,-8(fp)
200293e0:	10800417 	ldw	r2,16(r2)
200293e4:	e0bffc15 	stw	r2,-16(fp)
200293e8:	e03ffd0d 	sth	zero,-12(fp)
200293ec:	e0bffd0b 	ldhu	r2,-12(fp)
200293f0:	e0fffd84 	addi	r3,fp,-10
200293f4:	180d883a 	mov	r6,r3
200293f8:	100b883a 	mov	r5,r2
200293fc:	e13ffc17 	ldw	r4,-16(fp)
20029400:	00260500 	call	20026050 <OSSemPend>

  ret_code = alt_mutex_trylock( dev, value);
20029404:	e17fff17 	ldw	r5,-4(fp)
20029408:	e13ffe17 	ldw	r4,-8(fp)
2002940c:	00292640 	call	20029264 <alt_mutex_trylock>
20029410:	e0bffb15 	stw	r2,-20(fp)

  /*
  * If the try failed then release the thread Mutex  
  */
  if (ret_code)
20029414:	e0bffb17 	ldw	r2,-20(fp)
20029418:	10000426 	beq	r2,zero,2002942c <altera_avalon_mutex_trylock+0x68>
  {
    ALT_SEM_POST (dev->lock);
2002941c:	e0bffe17 	ldw	r2,-8(fp)
20029420:	10800417 	ldw	r2,16(r2)
20029424:	1009883a 	mov	r4,r2
20029428:	00263c80 	call	200263c8 <OSSemPost>
  }

  return ret_code;
2002942c:	e0bffb17 	ldw	r2,-20(fp)
}
20029430:	e037883a 	mov	sp,fp
20029434:	dfc00117 	ldw	ra,4(sp)
20029438:	df000017 	ldw	fp,0(sp)
2002943c:	dec00204 	addi	sp,sp,8
20029440:	f800283a 	ret

20029444 <altera_avalon_mutex_unlock>:
 * This function does not check that you own the Mutex if you try to release
 * a Mutex you do not own the behaviour is undefined
 *
 */
void altera_avalon_mutex_unlock( alt_mutex_dev* dev )
{
20029444:	defffc04 	addi	sp,sp,-16
20029448:	dfc00315 	stw	ra,12(sp)
2002944c:	df000215 	stw	fp,8(sp)
20029450:	df000204 	addi	fp,sp,8
20029454:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id;
  NIOS2_READ_CPUID(id);
20029458:	0005317a 	rdctl	r2,cpuid
2002945c:	e0bffe15 	stw	r2,-8(fp)

  /*
  * This Mutex has been claimed and released since Reset so clear the Reset bit
  * This MUST happen before we release the MUTEX
  */
  IOWR_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base, 
20029460:	e0bfff17 	ldw	r2,-4(fp)
20029464:	10800317 	ldw	r2,12(r2)
20029468:	10800104 	addi	r2,r2,4
2002946c:	00c00044 	movi	r3,1
20029470:	10c00035 	stwio	r3,0(r2)
                                  ALTERA_AVALON_MUTEX_RESET_RESET_MSK);
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, 
20029474:	e0bfff17 	ldw	r2,-4(fp)
20029478:	10800317 	ldw	r2,12(r2)
2002947c:	e0fffe17 	ldw	r3,-8(fp)
20029480:	1806943a 	slli	r3,r3,16
20029484:	10c00035 	stwio	r3,0(r2)
                                  id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST);

  /*
  * Now that access to the hardware Mutex is complete, release the thread lock
  */
  ALT_SEM_POST (dev->lock);
20029488:	e0bfff17 	ldw	r2,-4(fp)
2002948c:	10800417 	ldw	r2,16(r2)
20029490:	1009883a 	mov	r4,r2
20029494:	00263c80 	call	200263c8 <OSSemPost>
}
20029498:	0001883a 	nop
2002949c:	e037883a 	mov	sp,fp
200294a0:	dfc00117 	ldw	ra,4(sp)
200294a4:	df000017 	ldw	fp,0(sp)
200294a8:	dec00204 	addi	sp,sp,8
200294ac:	f800283a 	ret

200294b0 <altera_avalon_mutex_is_mine>:
 * altera_avalon_mutex_is_mine - Do I own the Mutex?
 *
 *  returns non zero if the mutex is owned by this CPU
 */
int altera_avalon_mutex_is_mine( alt_mutex_dev* dev )
{
200294b0:	defff904 	addi	sp,sp,-28
200294b4:	df000615 	stw	fp,24(sp)
200294b8:	df000604 	addi	fp,sp,24
200294bc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id, data, owner, value;
  int ret_code = 0;
200294c0:	e03ffa15 	stw	zero,-24(fp)

  NIOS2_READ_CPUID(id);
200294c4:	0005317a 	rdctl	r2,cpuid
200294c8:	e0bffb15 	stw	r2,-20(fp)

  /* retrieve the contents of the mutex */
  data = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
200294cc:	e0bfff17 	ldw	r2,-4(fp)
200294d0:	10800317 	ldw	r2,12(r2)
200294d4:	10800037 	ldwio	r2,0(r2)
200294d8:	e0bffc15 	stw	r2,-16(fp)
  owner = (data & ALTERA_AVALON_MUTEX_MUTEX_OWNER_MSK) >> 
200294dc:	e0bffc17 	ldw	r2,-16(fp)
200294e0:	1004d43a 	srli	r2,r2,16
200294e4:	e0bffd15 	stw	r2,-12(fp)
              ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST;

  if (owner == id) 
200294e8:	e0fffd17 	ldw	r3,-12(fp)
200294ec:	e0bffb17 	ldw	r2,-20(fp)
200294f0:	1880071e 	bne	r3,r2,20029510 <altera_avalon_mutex_is_mine+0x60>
  {
    value = (data & ALTERA_AVALON_MUTEX_MUTEX_VALUE_MSK) >> 
200294f4:	e0bffc17 	ldw	r2,-16(fp)
200294f8:	10bfffcc 	andi	r2,r2,65535
200294fc:	e0bffe15 	stw	r2,-8(fp)
                  ALTERA_AVALON_MUTEX_MUTEX_VALUE_OFST;
    if (value != 0)
20029500:	e0bffe17 	ldw	r2,-8(fp)
20029504:	10000226 	beq	r2,zero,20029510 <altera_avalon_mutex_is_mine+0x60>
    {
      ret_code = 1;
20029508:	00800044 	movi	r2,1
2002950c:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  return ret_code;
20029510:	e0bffa17 	ldw	r2,-24(fp)
}
20029514:	e037883a 	mov	sp,fp
20029518:	df000017 	ldw	fp,0(sp)
2002951c:	dec00104 	addi	sp,sp,4
20029520:	f800283a 	ret

20029524 <altera_avalon_mutex_first_lock>:
 *
 * Has this Mutex been released since reset if not return 1
 * otherwise return 0
 */
int altera_avalon_mutex_first_lock( alt_mutex_dev* dev )
{
20029524:	defffc04 	addi	sp,sp,-16
20029528:	df000315 	stw	fp,12(sp)
2002952c:	df000304 	addi	fp,sp,12
20029530:	e13fff15 	stw	r4,-4(fp)
  alt_u32 data;
  int ret_code = 0;
20029534:	e03ffd15 	stw	zero,-12(fp)

  data = IORD_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base);
20029538:	e0bfff17 	ldw	r2,-4(fp)
2002953c:	10800317 	ldw	r2,12(r2)
20029540:	10800104 	addi	r2,r2,4
20029544:	10800037 	ldwio	r2,0(r2)
20029548:	e0bffe15 	stw	r2,-8(fp)

  if (data & ALTERA_AVALON_MUTEX_RESET_RESET_MSK) 
2002954c:	e0bffe17 	ldw	r2,-8(fp)
20029550:	1080004c 	andi	r2,r2,1
20029554:	10000226 	beq	r2,zero,20029560 <altera_avalon_mutex_first_lock+0x3c>
  {
    ret_code = 1;
20029558:	00800044 	movi	r2,1
2002955c:	e0bffd15 	stw	r2,-12(fp)
  }

  return ret_code;
20029560:	e0bffd17 	ldw	r2,-12(fp)
}
20029564:	e037883a 	mov	sp,fp
20029568:	df000017 	ldw	fp,0(sp)
2002956c:	dec00104 	addi	sp,sp,4
20029570:	f800283a 	ret

20029574 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
20029574:	defffa04 	addi	sp,sp,-24
20029578:	dfc00515 	stw	ra,20(sp)
2002957c:	df000415 	stw	fp,16(sp)
20029580:	df000404 	addi	fp,sp,16
20029584:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
20029588:	0007883a 	mov	r3,zero
2002958c:	e0bfff17 	ldw	r2,-4(fp)
20029590:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
20029594:	e0bfff17 	ldw	r2,-4(fp)
20029598:	10800104 	addi	r2,r2,4
2002959c:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200295a0:	0005303a 	rdctl	r2,status
200295a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200295a8:	e0fffd17 	ldw	r3,-12(fp)
200295ac:	00bfff84 	movi	r2,-2
200295b0:	1884703a 	and	r2,r3,r2
200295b4:	1001703a 	wrctl	status,r2
  
  return context;
200295b8:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
200295bc:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
200295c0:	002a0a80 	call	2002a0a8 <alt_tick>
200295c4:	e0bffc17 	ldw	r2,-16(fp)
200295c8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200295cc:	e0bffe17 	ldw	r2,-8(fp)
200295d0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
200295d4:	0001883a 	nop
200295d8:	e037883a 	mov	sp,fp
200295dc:	dfc00117 	ldw	ra,4(sp)
200295e0:	df000017 	ldw	fp,0(sp)
200295e4:	dec00204 	addi	sp,sp,8
200295e8:	f800283a 	ret

200295ec <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
200295ec:	defff804 	addi	sp,sp,-32
200295f0:	dfc00715 	stw	ra,28(sp)
200295f4:	df000615 	stw	fp,24(sp)
200295f8:	df000604 	addi	fp,sp,24
200295fc:	e13ffc15 	stw	r4,-16(fp)
20029600:	e17ffd15 	stw	r5,-12(fp)
20029604:	e1bffe15 	stw	r6,-8(fp)
20029608:	e1ffff15 	stw	r7,-4(fp)
2002960c:	e0bfff17 	ldw	r2,-4(fp)
20029610:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
20029614:	d0a60c17 	ldw	r2,-26576(gp)
20029618:	1000021e 	bne	r2,zero,20029624 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
2002961c:	e0bffb17 	ldw	r2,-20(fp)
20029620:	d0a60c15 	stw	r2,-26576(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
20029624:	e0bffc17 	ldw	r2,-16(fp)
20029628:	10800104 	addi	r2,r2,4
2002962c:	00c001c4 	movi	r3,7
20029630:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
20029634:	d8000015 	stw	zero,0(sp)
20029638:	e1fffc17 	ldw	r7,-16(fp)
2002963c:	018800f4 	movhi	r6,8195
20029640:	31a55d04 	addi	r6,r6,-27276
20029644:	e17ffe17 	ldw	r5,-8(fp)
20029648:	e13ffd17 	ldw	r4,-12(fp)
2002964c:	00204200 	call	20020420 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
20029650:	0001883a 	nop
20029654:	e037883a 	mov	sp,fp
20029658:	dfc00117 	ldw	ra,4(sp)
2002965c:	df000017 	ldw	fp,0(sp)
20029660:	dec00204 	addi	sp,sp,8
20029664:	f800283a 	ret

20029668 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
20029668:	defff504 	addi	sp,sp,-44
2002966c:	df000a15 	stw	fp,40(sp)
20029670:	df000a04 	addi	fp,sp,40
20029674:	e13ffc15 	stw	r4,-16(fp)
20029678:	e17ffd15 	stw	r5,-12(fp)
2002967c:	e1bffe15 	stw	r6,-8(fp)
20029680:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
20029684:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
20029688:	d0a60c17 	ldw	r2,-26576(gp)
  
  if (alt_ticks_per_second ())
2002968c:	10003c26 	beq	r2,zero,20029780 <alt_alarm_start+0x118>
  {
    if (alarm)
20029690:	e0bffc17 	ldw	r2,-16(fp)
20029694:	10003826 	beq	r2,zero,20029778 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
20029698:	e0bffc17 	ldw	r2,-16(fp)
2002969c:	e0fffe17 	ldw	r3,-8(fp)
200296a0:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
200296a4:	e0bffc17 	ldw	r2,-16(fp)
200296a8:	e0ffff17 	ldw	r3,-4(fp)
200296ac:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200296b0:	0005303a 	rdctl	r2,status
200296b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200296b8:	e0fff917 	ldw	r3,-28(fp)
200296bc:	00bfff84 	movi	r2,-2
200296c0:	1884703a 	and	r2,r3,r2
200296c4:	1001703a 	wrctl	status,r2
  
  return context;
200296c8:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
200296cc:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
200296d0:	d0a60d17 	ldw	r2,-26572(gp)
      
      current_nticks = alt_nticks();
200296d4:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
200296d8:	e0fffd17 	ldw	r3,-12(fp)
200296dc:	e0bff617 	ldw	r2,-40(fp)
200296e0:	1885883a 	add	r2,r3,r2
200296e4:	10c00044 	addi	r3,r2,1
200296e8:	e0bffc17 	ldw	r2,-16(fp)
200296ec:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
200296f0:	e0bffc17 	ldw	r2,-16(fp)
200296f4:	10c00217 	ldw	r3,8(r2)
200296f8:	e0bff617 	ldw	r2,-40(fp)
200296fc:	1880042e 	bgeu	r3,r2,20029710 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
20029700:	e0bffc17 	ldw	r2,-16(fp)
20029704:	00c00044 	movi	r3,1
20029708:	10c00405 	stb	r3,16(r2)
2002970c:	00000206 	br	20029718 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
20029710:	e0bffc17 	ldw	r2,-16(fp)
20029714:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
20029718:	e0bffc17 	ldw	r2,-16(fp)
2002971c:	d0e02804 	addi	r3,gp,-32608
20029720:	e0fffa15 	stw	r3,-24(fp)
20029724:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
20029728:	e0bffb17 	ldw	r2,-20(fp)
2002972c:	e0fffa17 	ldw	r3,-24(fp)
20029730:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
20029734:	e0bffa17 	ldw	r2,-24(fp)
20029738:	10c00017 	ldw	r3,0(r2)
2002973c:	e0bffb17 	ldw	r2,-20(fp)
20029740:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
20029744:	e0bffa17 	ldw	r2,-24(fp)
20029748:	10800017 	ldw	r2,0(r2)
2002974c:	e0fffb17 	ldw	r3,-20(fp)
20029750:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
20029754:	e0bffa17 	ldw	r2,-24(fp)
20029758:	e0fffb17 	ldw	r3,-20(fp)
2002975c:	10c00015 	stw	r3,0(r2)
20029760:	e0bff817 	ldw	r2,-32(fp)
20029764:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20029768:	e0bff717 	ldw	r2,-36(fp)
2002976c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
20029770:	0005883a 	mov	r2,zero
20029774:	00000306 	br	20029784 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
20029778:	00bffa84 	movi	r2,-22
2002977c:	00000106 	br	20029784 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
20029780:	00bfde84 	movi	r2,-134
  }
}
20029784:	e037883a 	mov	sp,fp
20029788:	df000017 	ldw	fp,0(sp)
2002978c:	dec00104 	addi	sp,sp,4
20029790:	f800283a 	ret

20029794 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
20029794:	defffe04 	addi	sp,sp,-8
20029798:	dfc00115 	stw	ra,4(sp)
2002979c:	df000015 	stw	fp,0(sp)
200297a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
200297a4:	d0a02717 	ldw	r2,-32612(gp)
200297a8:	10000326 	beq	r2,zero,200297b8 <alt_get_errno+0x24>
200297ac:	d0a02717 	ldw	r2,-32612(gp)
200297b0:	103ee83a 	callr	r2
200297b4:	00000106 	br	200297bc <alt_get_errno+0x28>
200297b8:	d0a60e04 	addi	r2,gp,-26568
}
200297bc:	e037883a 	mov	sp,fp
200297c0:	dfc00117 	ldw	ra,4(sp)
200297c4:	df000017 	ldw	fp,0(sp)
200297c8:	dec00204 	addi	sp,sp,8
200297cc:	f800283a 	ret

200297d0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
200297d0:	defffb04 	addi	sp,sp,-20
200297d4:	dfc00415 	stw	ra,16(sp)
200297d8:	df000315 	stw	fp,12(sp)
200297dc:	df000304 	addi	fp,sp,12
200297e0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
200297e4:	e0bfff17 	ldw	r2,-4(fp)
200297e8:	10000616 	blt	r2,zero,20029804 <close+0x34>
200297ec:	e0bfff17 	ldw	r2,-4(fp)
200297f0:	10c00324 	muli	r3,r2,12
200297f4:	008800f4 	movhi	r2,8195
200297f8:	10b08904 	addi	r2,r2,-15836
200297fc:	1885883a 	add	r2,r3,r2
20029800:	00000106 	br	20029808 <close+0x38>
20029804:	0005883a 	mov	r2,zero
20029808:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
2002980c:	e0bffd17 	ldw	r2,-12(fp)
20029810:	10001926 	beq	r2,zero,20029878 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
20029814:	e0bffd17 	ldw	r2,-12(fp)
20029818:	10800017 	ldw	r2,0(r2)
2002981c:	10800417 	ldw	r2,16(r2)
20029820:	10000626 	beq	r2,zero,2002983c <close+0x6c>
20029824:	e0bffd17 	ldw	r2,-12(fp)
20029828:	10800017 	ldw	r2,0(r2)
2002982c:	10800417 	ldw	r2,16(r2)
20029830:	e13ffd17 	ldw	r4,-12(fp)
20029834:	103ee83a 	callr	r2
20029838:	00000106 	br	20029840 <close+0x70>
2002983c:	0005883a 	mov	r2,zero
20029840:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
20029844:	e13fff17 	ldw	r4,-4(fp)
20029848:	0029fa80 	call	20029fa8 <alt_release_fd>
    if (rval < 0)
2002984c:	e0bffe17 	ldw	r2,-8(fp)
20029850:	1000070e 	bge	r2,zero,20029870 <close+0xa0>
    {
      ALT_ERRNO = -rval;
20029854:	00297940 	call	20029794 <alt_get_errno>
20029858:	1007883a 	mov	r3,r2
2002985c:	e0bffe17 	ldw	r2,-8(fp)
20029860:	0085c83a 	sub	r2,zero,r2
20029864:	18800015 	stw	r2,0(r3)
      return -1;
20029868:	00bfffc4 	movi	r2,-1
2002986c:	00000706 	br	2002988c <close+0xbc>
    }
    return 0;
20029870:	0005883a 	mov	r2,zero
20029874:	00000506 	br	2002988c <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
20029878:	00297940 	call	20029794 <alt_get_errno>
2002987c:	1007883a 	mov	r3,r2
20029880:	00801444 	movi	r2,81
20029884:	18800015 	stw	r2,0(r3)
    return -1;
20029888:	00bfffc4 	movi	r2,-1
  }
}
2002988c:	e037883a 	mov	sp,fp
20029890:	dfc00117 	ldw	ra,4(sp)
20029894:	df000017 	ldw	fp,0(sp)
20029898:	dec00204 	addi	sp,sp,8
2002989c:	f800283a 	ret

200298a0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
200298a0:	defffe04 	addi	sp,sp,-8
200298a4:	df000115 	stw	fp,4(sp)
200298a8:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
200298ac:	e03fff15 	stw	zero,-4(fp)
200298b0:	00000506 	br	200298c8 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
200298b4:	e0bfff17 	ldw	r2,-4(fp)
200298b8:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
200298bc:	e0bfff17 	ldw	r2,-4(fp)
200298c0:	10800804 	addi	r2,r2,32
200298c4:	e0bfff15 	stw	r2,-4(fp)
200298c8:	e0bfff17 	ldw	r2,-4(fp)
200298cc:	10820030 	cmpltui	r2,r2,2048
200298d0:	103ff81e 	bne	r2,zero,200298b4 <__alt_data_end+0xfffe98b4>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
200298d4:	0001883a 	nop
200298d8:	e037883a 	mov	sp,fp
200298dc:	df000017 	ldw	fp,0(sp)
200298e0:	dec00104 	addi	sp,sp,4
200298e4:	f800283a 	ret

200298e8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
200298e8:	defffc04 	addi	sp,sp,-16
200298ec:	df000315 	stw	fp,12(sp)
200298f0:	df000304 	addi	fp,sp,12
200298f4:	e13ffd15 	stw	r4,-12(fp)
200298f8:	e17ffe15 	stw	r5,-8(fp)
200298fc:	e1bfff15 	stw	r6,-4(fp)
  return len;
20029900:	e0bfff17 	ldw	r2,-4(fp)
}
20029904:	e037883a 	mov	sp,fp
20029908:	df000017 	ldw	fp,0(sp)
2002990c:	dec00104 	addi	sp,sp,4
20029910:	f800283a 	ret

20029914 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
20029914:	defffe04 	addi	sp,sp,-8
20029918:	dfc00115 	stw	ra,4(sp)
2002991c:	df000015 	stw	fp,0(sp)
20029920:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
20029924:	d0a02717 	ldw	r2,-32612(gp)
20029928:	10000326 	beq	r2,zero,20029938 <alt_get_errno+0x24>
2002992c:	d0a02717 	ldw	r2,-32612(gp)
20029930:	103ee83a 	callr	r2
20029934:	00000106 	br	2002993c <alt_get_errno+0x28>
20029938:	d0a60e04 	addi	r2,gp,-26568
}
2002993c:	e037883a 	mov	sp,fp
20029940:	dfc00117 	ldw	ra,4(sp)
20029944:	df000017 	ldw	fp,0(sp)
20029948:	dec00204 	addi	sp,sp,8
2002994c:	f800283a 	ret

20029950 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
20029950:	defffa04 	addi	sp,sp,-24
20029954:	dfc00515 	stw	ra,20(sp)
20029958:	df000415 	stw	fp,16(sp)
2002995c:	df000404 	addi	fp,sp,16
20029960:	e13ffe15 	stw	r4,-8(fp)
20029964:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
20029968:	e0bffe17 	ldw	r2,-8(fp)
2002996c:	10000326 	beq	r2,zero,2002997c <alt_dev_llist_insert+0x2c>
20029970:	e0bffe17 	ldw	r2,-8(fp)
20029974:	10800217 	ldw	r2,8(r2)
20029978:	1000061e 	bne	r2,zero,20029994 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
2002997c:	00299140 	call	20029914 <alt_get_errno>
20029980:	1007883a 	mov	r3,r2
20029984:	00800584 	movi	r2,22
20029988:	18800015 	stw	r2,0(r3)
    return -EINVAL;
2002998c:	00bffa84 	movi	r2,-22
20029990:	00001306 	br	200299e0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
20029994:	e0bffe17 	ldw	r2,-8(fp)
20029998:	e0ffff17 	ldw	r3,-4(fp)
2002999c:	e0fffc15 	stw	r3,-16(fp)
200299a0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
200299a4:	e0bffd17 	ldw	r2,-12(fp)
200299a8:	e0fffc17 	ldw	r3,-16(fp)
200299ac:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
200299b0:	e0bffc17 	ldw	r2,-16(fp)
200299b4:	10c00017 	ldw	r3,0(r2)
200299b8:	e0bffd17 	ldw	r2,-12(fp)
200299bc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
200299c0:	e0bffc17 	ldw	r2,-16(fp)
200299c4:	10800017 	ldw	r2,0(r2)
200299c8:	e0fffd17 	ldw	r3,-12(fp)
200299cc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
200299d0:	e0bffc17 	ldw	r2,-16(fp)
200299d4:	e0fffd17 	ldw	r3,-12(fp)
200299d8:	10c00015 	stw	r3,0(r2)

  return 0;  
200299dc:	0005883a 	mov	r2,zero
}
200299e0:	e037883a 	mov	sp,fp
200299e4:	dfc00117 	ldw	ra,4(sp)
200299e8:	df000017 	ldw	fp,0(sp)
200299ec:	dec00204 	addi	sp,sp,8
200299f0:	f800283a 	ret

200299f4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
200299f4:	defffd04 	addi	sp,sp,-12
200299f8:	dfc00215 	stw	ra,8(sp)
200299fc:	df000115 	stw	fp,4(sp)
20029a00:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
20029a04:	008800f4 	movhi	r2,8195
20029a08:	10abfb04 	addi	r2,r2,-20500
20029a0c:	e0bfff15 	stw	r2,-4(fp)
20029a10:	00000606 	br	20029a2c <_do_ctors+0x38>
        (*ctor) (); 
20029a14:	e0bfff17 	ldw	r2,-4(fp)
20029a18:	10800017 	ldw	r2,0(r2)
20029a1c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
20029a20:	e0bfff17 	ldw	r2,-4(fp)
20029a24:	10bfff04 	addi	r2,r2,-4
20029a28:	e0bfff15 	stw	r2,-4(fp)
20029a2c:	e0ffff17 	ldw	r3,-4(fp)
20029a30:	008800f4 	movhi	r2,8195
20029a34:	10abfc04 	addi	r2,r2,-20496
20029a38:	18bff62e 	bgeu	r3,r2,20029a14 <__alt_data_end+0xfffe9a14>
        (*ctor) (); 
}
20029a3c:	0001883a 	nop
20029a40:	e037883a 	mov	sp,fp
20029a44:	dfc00117 	ldw	ra,4(sp)
20029a48:	df000017 	ldw	fp,0(sp)
20029a4c:	dec00204 	addi	sp,sp,8
20029a50:	f800283a 	ret

20029a54 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
20029a54:	defffd04 	addi	sp,sp,-12
20029a58:	dfc00215 	stw	ra,8(sp)
20029a5c:	df000115 	stw	fp,4(sp)
20029a60:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
20029a64:	008800f4 	movhi	r2,8195
20029a68:	10abfb04 	addi	r2,r2,-20500
20029a6c:	e0bfff15 	stw	r2,-4(fp)
20029a70:	00000606 	br	20029a8c <_do_dtors+0x38>
        (*dtor) (); 
20029a74:	e0bfff17 	ldw	r2,-4(fp)
20029a78:	10800017 	ldw	r2,0(r2)
20029a7c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
20029a80:	e0bfff17 	ldw	r2,-4(fp)
20029a84:	10bfff04 	addi	r2,r2,-4
20029a88:	e0bfff15 	stw	r2,-4(fp)
20029a8c:	e0ffff17 	ldw	r3,-4(fp)
20029a90:	008800f4 	movhi	r2,8195
20029a94:	10abfc04 	addi	r2,r2,-20496
20029a98:	18bff62e 	bgeu	r3,r2,20029a74 <__alt_data_end+0xfffe9a74>
        (*dtor) (); 
}
20029a9c:	0001883a 	nop
20029aa0:	e037883a 	mov	sp,fp
20029aa4:	dfc00117 	ldw	ra,4(sp)
20029aa8:	df000017 	ldw	fp,0(sp)
20029aac:	dec00204 	addi	sp,sp,8
20029ab0:	f800283a 	ret

20029ab4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
20029ab4:	defffa04 	addi	sp,sp,-24
20029ab8:	dfc00515 	stw	ra,20(sp)
20029abc:	df000415 	stw	fp,16(sp)
20029ac0:	df000404 	addi	fp,sp,16
20029ac4:	e13ffe15 	stw	r4,-8(fp)
20029ac8:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
20029acc:	e0bfff17 	ldw	r2,-4(fp)
20029ad0:	10800017 	ldw	r2,0(r2)
20029ad4:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
20029ad8:	e13ffe17 	ldw	r4,-8(fp)
20029adc:	002aad80 	call	2002aad8 <strlen>
20029ae0:	10800044 	addi	r2,r2,1
20029ae4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
20029ae8:	00000d06 	br	20029b20 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
20029aec:	e0bffc17 	ldw	r2,-16(fp)
20029af0:	10800217 	ldw	r2,8(r2)
20029af4:	e0fffd17 	ldw	r3,-12(fp)
20029af8:	180d883a 	mov	r6,r3
20029afc:	e17ffe17 	ldw	r5,-8(fp)
20029b00:	1009883a 	mov	r4,r2
20029b04:	002a7ec0 	call	2002a7ec <memcmp>
20029b08:	1000021e 	bne	r2,zero,20029b14 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
20029b0c:	e0bffc17 	ldw	r2,-16(fp)
20029b10:	00000706 	br	20029b30 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
20029b14:	e0bffc17 	ldw	r2,-16(fp)
20029b18:	10800017 	ldw	r2,0(r2)
20029b1c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
20029b20:	e0fffc17 	ldw	r3,-16(fp)
20029b24:	e0bfff17 	ldw	r2,-4(fp)
20029b28:	18bff01e 	bne	r3,r2,20029aec <__alt_data_end+0xfffe9aec>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
20029b2c:	0005883a 	mov	r2,zero
}
20029b30:	e037883a 	mov	sp,fp
20029b34:	dfc00117 	ldw	ra,4(sp)
20029b38:	df000017 	ldw	fp,0(sp)
20029b3c:	dec00204 	addi	sp,sp,8
20029b40:	f800283a 	ret

20029b44 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
20029b44:	defffe04 	addi	sp,sp,-8
20029b48:	dfc00115 	stw	ra,4(sp)
20029b4c:	df000015 	stw	fp,0(sp)
20029b50:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
20029b54:	01440004 	movi	r5,4096
20029b58:	0009883a 	mov	r4,zero
20029b5c:	002a7100 	call	2002a710 <alt_icache_flush>
#endif
}
20029b60:	0001883a 	nop
20029b64:	e037883a 	mov	sp,fp
20029b68:	dfc00117 	ldw	ra,4(sp)
20029b6c:	df000017 	ldw	fp,0(sp)
20029b70:	dec00204 	addi	sp,sp,8
20029b74:	f800283a 	ret

20029b78 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
20029b78:	defffe04 	addi	sp,sp,-8
20029b7c:	df000115 	stw	fp,4(sp)
20029b80:	df000104 	addi	fp,sp,4
20029b84:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
20029b88:	e0bfff17 	ldw	r2,-4(fp)
20029b8c:	10bffe84 	addi	r2,r2,-6
20029b90:	10c00428 	cmpgeui	r3,r2,16
20029b94:	18001a1e 	bne	r3,zero,20029c00 <alt_exception_cause_generated_bad_addr+0x88>
20029b98:	100690ba 	slli	r3,r2,2
20029b9c:	008800f4 	movhi	r2,8195
20029ba0:	10a6ec04 	addi	r2,r2,-25680
20029ba4:	1885883a 	add	r2,r3,r2
20029ba8:	10800017 	ldw	r2,0(r2)
20029bac:	1000683a 	jmp	r2
20029bb0:	20029bf0 	cmpltui	zero,r4,2671
20029bb4:	20029bf0 	cmpltui	zero,r4,2671
20029bb8:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029bbc:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029bc0:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029bc4:	20029bf0 	cmpltui	zero,r4,2671
20029bc8:	20029bf8 	rdprs	zero,r4,2671
20029bcc:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029bd0:	20029bf0 	cmpltui	zero,r4,2671
20029bd4:	20029bf0 	cmpltui	zero,r4,2671
20029bd8:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029bdc:	20029bf0 	cmpltui	zero,r4,2671
20029be0:	20029bf8 	rdprs	zero,r4,2671
20029be4:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029be8:	20029c00 	call	220029c0 <__alt_data_end+0x1fc29c0>
20029bec:	20029bf0 	cmpltui	zero,r4,2671
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
20029bf0:	00800044 	movi	r2,1
20029bf4:	00000306 	br	20029c04 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
20029bf8:	0005883a 	mov	r2,zero
20029bfc:	00000106 	br	20029c04 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
20029c00:	0005883a 	mov	r2,zero
  }
}
20029c04:	e037883a 	mov	sp,fp
20029c08:	df000017 	ldw	fp,0(sp)
20029c0c:	dec00104 	addi	sp,sp,4
20029c10:	f800283a 	ret

20029c14 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
20029c14:	defff904 	addi	sp,sp,-28
20029c18:	dfc00615 	stw	ra,24(sp)
20029c1c:	df000515 	stw	fp,20(sp)
20029c20:	df000504 	addi	fp,sp,20
20029c24:	e13ffc15 	stw	r4,-16(fp)
20029c28:	e17ffd15 	stw	r5,-12(fp)
20029c2c:	e1bffe15 	stw	r6,-8(fp)
20029c30:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
20029c34:	e1bfff17 	ldw	r6,-4(fp)
20029c38:	e17ffe17 	ldw	r5,-8(fp)
20029c3c:	e13ffd17 	ldw	r4,-12(fp)
20029c40:	0029e540 	call	20029e54 <open>
20029c44:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
20029c48:	e0bffb17 	ldw	r2,-20(fp)
20029c4c:	10001c16 	blt	r2,zero,20029cc0 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
20029c50:	008800f4 	movhi	r2,8195
20029c54:	10b08904 	addi	r2,r2,-15836
20029c58:	e0fffb17 	ldw	r3,-20(fp)
20029c5c:	18c00324 	muli	r3,r3,12
20029c60:	10c5883a 	add	r2,r2,r3
20029c64:	10c00017 	ldw	r3,0(r2)
20029c68:	e0bffc17 	ldw	r2,-16(fp)
20029c6c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
20029c70:	008800f4 	movhi	r2,8195
20029c74:	10b08904 	addi	r2,r2,-15836
20029c78:	e0fffb17 	ldw	r3,-20(fp)
20029c7c:	18c00324 	muli	r3,r3,12
20029c80:	10c5883a 	add	r2,r2,r3
20029c84:	10800104 	addi	r2,r2,4
20029c88:	10c00017 	ldw	r3,0(r2)
20029c8c:	e0bffc17 	ldw	r2,-16(fp)
20029c90:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
20029c94:	008800f4 	movhi	r2,8195
20029c98:	10b08904 	addi	r2,r2,-15836
20029c9c:	e0fffb17 	ldw	r3,-20(fp)
20029ca0:	18c00324 	muli	r3,r3,12
20029ca4:	10c5883a 	add	r2,r2,r3
20029ca8:	10800204 	addi	r2,r2,8
20029cac:	10c00017 	ldw	r3,0(r2)
20029cb0:	e0bffc17 	ldw	r2,-16(fp)
20029cb4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
20029cb8:	e13ffb17 	ldw	r4,-20(fp)
20029cbc:	0029fa80 	call	20029fa8 <alt_release_fd>
  }
} 
20029cc0:	0001883a 	nop
20029cc4:	e037883a 	mov	sp,fp
20029cc8:	dfc00117 	ldw	ra,4(sp)
20029ccc:	df000017 	ldw	fp,0(sp)
20029cd0:	dec00204 	addi	sp,sp,8
20029cd4:	f800283a 	ret

20029cd8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
20029cd8:	defffb04 	addi	sp,sp,-20
20029cdc:	dfc00415 	stw	ra,16(sp)
20029ce0:	df000315 	stw	fp,12(sp)
20029ce4:	df000304 	addi	fp,sp,12
20029ce8:	e13ffd15 	stw	r4,-12(fp)
20029cec:	e17ffe15 	stw	r5,-8(fp)
20029cf0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
20029cf4:	01c07fc4 	movi	r7,511
20029cf8:	01800044 	movi	r6,1
20029cfc:	e17ffd17 	ldw	r5,-12(fp)
20029d00:	010800f4 	movhi	r4,8195
20029d04:	21308c04 	addi	r4,r4,-15824
20029d08:	0029c140 	call	20029c14 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
20029d0c:	01c07fc4 	movi	r7,511
20029d10:	000d883a 	mov	r6,zero
20029d14:	e17ffe17 	ldw	r5,-8(fp)
20029d18:	010800f4 	movhi	r4,8195
20029d1c:	21308904 	addi	r4,r4,-15836
20029d20:	0029c140 	call	20029c14 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
20029d24:	01c07fc4 	movi	r7,511
20029d28:	01800044 	movi	r6,1
20029d2c:	e17fff17 	ldw	r5,-4(fp)
20029d30:	010800f4 	movhi	r4,8195
20029d34:	21308f04 	addi	r4,r4,-15812
20029d38:	0029c140 	call	20029c14 <alt_open_fd>
}  
20029d3c:	0001883a 	nop
20029d40:	e037883a 	mov	sp,fp
20029d44:	dfc00117 	ldw	ra,4(sp)
20029d48:	df000017 	ldw	fp,0(sp)
20029d4c:	dec00204 	addi	sp,sp,8
20029d50:	f800283a 	ret

20029d54 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
20029d54:	defffe04 	addi	sp,sp,-8
20029d58:	dfc00115 	stw	ra,4(sp)
20029d5c:	df000015 	stw	fp,0(sp)
20029d60:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
20029d64:	d0a02717 	ldw	r2,-32612(gp)
20029d68:	10000326 	beq	r2,zero,20029d78 <alt_get_errno+0x24>
20029d6c:	d0a02717 	ldw	r2,-32612(gp)
20029d70:	103ee83a 	callr	r2
20029d74:	00000106 	br	20029d7c <alt_get_errno+0x28>
20029d78:	d0a60e04 	addi	r2,gp,-26568
}
20029d7c:	e037883a 	mov	sp,fp
20029d80:	dfc00117 	ldw	ra,4(sp)
20029d84:	df000017 	ldw	fp,0(sp)
20029d88:	dec00204 	addi	sp,sp,8
20029d8c:	f800283a 	ret

20029d90 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
20029d90:	defffd04 	addi	sp,sp,-12
20029d94:	df000215 	stw	fp,8(sp)
20029d98:	df000204 	addi	fp,sp,8
20029d9c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
20029da0:	e0bfff17 	ldw	r2,-4(fp)
20029da4:	10800217 	ldw	r2,8(r2)
20029da8:	10d00034 	orhi	r3,r2,16384
20029dac:	e0bfff17 	ldw	r2,-4(fp)
20029db0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
20029db4:	e03ffe15 	stw	zero,-8(fp)
20029db8:	00001d06 	br	20029e30 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
20029dbc:	008800f4 	movhi	r2,8195
20029dc0:	10b08904 	addi	r2,r2,-15836
20029dc4:	e0fffe17 	ldw	r3,-8(fp)
20029dc8:	18c00324 	muli	r3,r3,12
20029dcc:	10c5883a 	add	r2,r2,r3
20029dd0:	10c00017 	ldw	r3,0(r2)
20029dd4:	e0bfff17 	ldw	r2,-4(fp)
20029dd8:	10800017 	ldw	r2,0(r2)
20029ddc:	1880111e 	bne	r3,r2,20029e24 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
20029de0:	008800f4 	movhi	r2,8195
20029de4:	10b08904 	addi	r2,r2,-15836
20029de8:	e0fffe17 	ldw	r3,-8(fp)
20029dec:	18c00324 	muli	r3,r3,12
20029df0:	10c5883a 	add	r2,r2,r3
20029df4:	10800204 	addi	r2,r2,8
20029df8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
20029dfc:	1000090e 	bge	r2,zero,20029e24 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
20029e00:	e0bffe17 	ldw	r2,-8(fp)
20029e04:	10c00324 	muli	r3,r2,12
20029e08:	008800f4 	movhi	r2,8195
20029e0c:	10b08904 	addi	r2,r2,-15836
20029e10:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
20029e14:	e0bfff17 	ldw	r2,-4(fp)
20029e18:	18800226 	beq	r3,r2,20029e24 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
20029e1c:	00bffcc4 	movi	r2,-13
20029e20:	00000806 	br	20029e44 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
20029e24:	e0bffe17 	ldw	r2,-8(fp)
20029e28:	10800044 	addi	r2,r2,1
20029e2c:	e0bffe15 	stw	r2,-8(fp)
20029e30:	d0a02617 	ldw	r2,-32616(gp)
20029e34:	1007883a 	mov	r3,r2
20029e38:	e0bffe17 	ldw	r2,-8(fp)
20029e3c:	18bfdf2e 	bgeu	r3,r2,20029dbc <__alt_data_end+0xfffe9dbc>
    }
  }
  
  /* The device is not locked */
 
  return 0;
20029e40:	0005883a 	mov	r2,zero
}
20029e44:	e037883a 	mov	sp,fp
20029e48:	df000017 	ldw	fp,0(sp)
20029e4c:	dec00104 	addi	sp,sp,4
20029e50:	f800283a 	ret

20029e54 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
20029e54:	defff604 	addi	sp,sp,-40
20029e58:	dfc00915 	stw	ra,36(sp)
20029e5c:	df000815 	stw	fp,32(sp)
20029e60:	df000804 	addi	fp,sp,32
20029e64:	e13ffd15 	stw	r4,-12(fp)
20029e68:	e17ffe15 	stw	r5,-8(fp)
20029e6c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
20029e70:	00bfffc4 	movi	r2,-1
20029e74:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
20029e78:	00bffb44 	movi	r2,-19
20029e7c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
20029e80:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
20029e84:	d1602404 	addi	r5,gp,-32624
20029e88:	e13ffd17 	ldw	r4,-12(fp)
20029e8c:	0029ab40 	call	20029ab4 <alt_find_dev>
20029e90:	e0bff815 	stw	r2,-32(fp)
20029e94:	e0bff817 	ldw	r2,-32(fp)
20029e98:	1000051e 	bne	r2,zero,20029eb0 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
20029e9c:	e13ffd17 	ldw	r4,-12(fp)
20029ea0:	002a52c0 	call	2002a52c <alt_find_file>
20029ea4:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
20029ea8:	00800044 	movi	r2,1
20029eac:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
20029eb0:	e0bff817 	ldw	r2,-32(fp)
20029eb4:	10002926 	beq	r2,zero,20029f5c <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
20029eb8:	e13ff817 	ldw	r4,-32(fp)
20029ebc:	002a6340 	call	2002a634 <alt_get_fd>
20029ec0:	e0bff915 	stw	r2,-28(fp)
20029ec4:	e0bff917 	ldw	r2,-28(fp)
20029ec8:	1000030e 	bge	r2,zero,20029ed8 <open+0x84>
    {
      status = index;
20029ecc:	e0bff917 	ldw	r2,-28(fp)
20029ed0:	e0bffa15 	stw	r2,-24(fp)
20029ed4:	00002306 	br	20029f64 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
20029ed8:	e0bff917 	ldw	r2,-28(fp)
20029edc:	10c00324 	muli	r3,r2,12
20029ee0:	008800f4 	movhi	r2,8195
20029ee4:	10b08904 	addi	r2,r2,-15836
20029ee8:	1885883a 	add	r2,r3,r2
20029eec:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
20029ef0:	e0fffe17 	ldw	r3,-8(fp)
20029ef4:	00900034 	movhi	r2,16384
20029ef8:	10bfffc4 	addi	r2,r2,-1
20029efc:	1886703a 	and	r3,r3,r2
20029f00:	e0bffc17 	ldw	r2,-16(fp)
20029f04:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
20029f08:	e0bffb17 	ldw	r2,-20(fp)
20029f0c:	1000051e 	bne	r2,zero,20029f24 <open+0xd0>
20029f10:	e13ffc17 	ldw	r4,-16(fp)
20029f14:	0029d900 	call	20029d90 <alt_file_locked>
20029f18:	e0bffa15 	stw	r2,-24(fp)
20029f1c:	e0bffa17 	ldw	r2,-24(fp)
20029f20:	10001016 	blt	r2,zero,20029f64 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
20029f24:	e0bff817 	ldw	r2,-32(fp)
20029f28:	10800317 	ldw	r2,12(r2)
20029f2c:	10000826 	beq	r2,zero,20029f50 <open+0xfc>
20029f30:	e0bff817 	ldw	r2,-32(fp)
20029f34:	10800317 	ldw	r2,12(r2)
20029f38:	e1ffff17 	ldw	r7,-4(fp)
20029f3c:	e1bffe17 	ldw	r6,-8(fp)
20029f40:	e17ffd17 	ldw	r5,-12(fp)
20029f44:	e13ffc17 	ldw	r4,-16(fp)
20029f48:	103ee83a 	callr	r2
20029f4c:	00000106 	br	20029f54 <open+0x100>
20029f50:	0005883a 	mov	r2,zero
20029f54:	e0bffa15 	stw	r2,-24(fp)
20029f58:	00000206 	br	20029f64 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
20029f5c:	00bffb44 	movi	r2,-19
20029f60:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
20029f64:	e0bffa17 	ldw	r2,-24(fp)
20029f68:	1000090e 	bge	r2,zero,20029f90 <open+0x13c>
  {
    alt_release_fd (index);  
20029f6c:	e13ff917 	ldw	r4,-28(fp)
20029f70:	0029fa80 	call	20029fa8 <alt_release_fd>
    ALT_ERRNO = -status;
20029f74:	0029d540 	call	20029d54 <alt_get_errno>
20029f78:	1007883a 	mov	r3,r2
20029f7c:	e0bffa17 	ldw	r2,-24(fp)
20029f80:	0085c83a 	sub	r2,zero,r2
20029f84:	18800015 	stw	r2,0(r3)
    return -1;
20029f88:	00bfffc4 	movi	r2,-1
20029f8c:	00000106 	br	20029f94 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
20029f90:	e0bff917 	ldw	r2,-28(fp)
}
20029f94:	e037883a 	mov	sp,fp
20029f98:	dfc00117 	ldw	ra,4(sp)
20029f9c:	df000017 	ldw	fp,0(sp)
20029fa0:	dec00204 	addi	sp,sp,8
20029fa4:	f800283a 	ret

20029fa8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
20029fa8:	defffe04 	addi	sp,sp,-8
20029fac:	df000115 	stw	fp,4(sp)
20029fb0:	df000104 	addi	fp,sp,4
20029fb4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
20029fb8:	e0bfff17 	ldw	r2,-4(fp)
20029fbc:	108000d0 	cmplti	r2,r2,3
20029fc0:	10000d1e 	bne	r2,zero,20029ff8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
20029fc4:	008800f4 	movhi	r2,8195
20029fc8:	10b08904 	addi	r2,r2,-15836
20029fcc:	e0ffff17 	ldw	r3,-4(fp)
20029fd0:	18c00324 	muli	r3,r3,12
20029fd4:	10c5883a 	add	r2,r2,r3
20029fd8:	10800204 	addi	r2,r2,8
20029fdc:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
20029fe0:	008800f4 	movhi	r2,8195
20029fe4:	10b08904 	addi	r2,r2,-15836
20029fe8:	e0ffff17 	ldw	r3,-4(fp)
20029fec:	18c00324 	muli	r3,r3,12
20029ff0:	10c5883a 	add	r2,r2,r3
20029ff4:	10000015 	stw	zero,0(r2)
  }
}
20029ff8:	0001883a 	nop
20029ffc:	e037883a 	mov	sp,fp
2002a000:	df000017 	ldw	fp,0(sp)
2002a004:	dec00104 	addi	sp,sp,4
2002a008:	f800283a 	ret

2002a00c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
2002a00c:	defffa04 	addi	sp,sp,-24
2002a010:	df000515 	stw	fp,20(sp)
2002a014:	df000504 	addi	fp,sp,20
2002a018:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2002a01c:	0005303a 	rdctl	r2,status
2002a020:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2002a024:	e0fffc17 	ldw	r3,-16(fp)
2002a028:	00bfff84 	movi	r2,-2
2002a02c:	1884703a 	and	r2,r3,r2
2002a030:	1001703a 	wrctl	status,r2
  
  return context;
2002a034:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
2002a038:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
2002a03c:	e0bfff17 	ldw	r2,-4(fp)
2002a040:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
2002a044:	e0bffd17 	ldw	r2,-12(fp)
2002a048:	10800017 	ldw	r2,0(r2)
2002a04c:	e0fffd17 	ldw	r3,-12(fp)
2002a050:	18c00117 	ldw	r3,4(r3)
2002a054:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
2002a058:	e0bffd17 	ldw	r2,-12(fp)
2002a05c:	10800117 	ldw	r2,4(r2)
2002a060:	e0fffd17 	ldw	r3,-12(fp)
2002a064:	18c00017 	ldw	r3,0(r3)
2002a068:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
2002a06c:	e0bffd17 	ldw	r2,-12(fp)
2002a070:	e0fffd17 	ldw	r3,-12(fp)
2002a074:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
2002a078:	e0bffd17 	ldw	r2,-12(fp)
2002a07c:	e0fffd17 	ldw	r3,-12(fp)
2002a080:	10c00015 	stw	r3,0(r2)
2002a084:	e0bffb17 	ldw	r2,-20(fp)
2002a088:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2002a08c:	e0bffe17 	ldw	r2,-8(fp)
2002a090:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
2002a094:	0001883a 	nop
2002a098:	e037883a 	mov	sp,fp
2002a09c:	df000017 	ldw	fp,0(sp)
2002a0a0:	dec00104 	addi	sp,sp,4
2002a0a4:	f800283a 	ret

2002a0a8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
2002a0a8:	defffb04 	addi	sp,sp,-20
2002a0ac:	dfc00415 	stw	ra,16(sp)
2002a0b0:	df000315 	stw	fp,12(sp)
2002a0b4:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
2002a0b8:	d0a02817 	ldw	r2,-32608(gp)
2002a0bc:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2002a0c0:	d0a60d17 	ldw	r2,-26572(gp)
2002a0c4:	10800044 	addi	r2,r2,1
2002a0c8:	d0a60d15 	stw	r2,-26572(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2002a0cc:	00002e06 	br	2002a188 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
2002a0d0:	e0bffd17 	ldw	r2,-12(fp)
2002a0d4:	10800017 	ldw	r2,0(r2)
2002a0d8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
2002a0dc:	e0bffd17 	ldw	r2,-12(fp)
2002a0e0:	10800403 	ldbu	r2,16(r2)
2002a0e4:	10803fcc 	andi	r2,r2,255
2002a0e8:	10000426 	beq	r2,zero,2002a0fc <alt_tick+0x54>
2002a0ec:	d0a60d17 	ldw	r2,-26572(gp)
2002a0f0:	1000021e 	bne	r2,zero,2002a0fc <alt_tick+0x54>
    {
      alarm->rollover = 0;
2002a0f4:	e0bffd17 	ldw	r2,-12(fp)
2002a0f8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
2002a0fc:	e0bffd17 	ldw	r2,-12(fp)
2002a100:	10800217 	ldw	r2,8(r2)
2002a104:	d0e60d17 	ldw	r3,-26572(gp)
2002a108:	18801d36 	bltu	r3,r2,2002a180 <alt_tick+0xd8>
2002a10c:	e0bffd17 	ldw	r2,-12(fp)
2002a110:	10800403 	ldbu	r2,16(r2)
2002a114:	10803fcc 	andi	r2,r2,255
2002a118:	1000191e 	bne	r2,zero,2002a180 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
2002a11c:	e0bffd17 	ldw	r2,-12(fp)
2002a120:	10800317 	ldw	r2,12(r2)
2002a124:	e0fffd17 	ldw	r3,-12(fp)
2002a128:	18c00517 	ldw	r3,20(r3)
2002a12c:	1809883a 	mov	r4,r3
2002a130:	103ee83a 	callr	r2
2002a134:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
2002a138:	e0bfff17 	ldw	r2,-4(fp)
2002a13c:	1000031e 	bne	r2,zero,2002a14c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
2002a140:	e13ffd17 	ldw	r4,-12(fp)
2002a144:	002a00c0 	call	2002a00c <alt_alarm_stop>
2002a148:	00000d06 	br	2002a180 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
2002a14c:	e0bffd17 	ldw	r2,-12(fp)
2002a150:	10c00217 	ldw	r3,8(r2)
2002a154:	e0bfff17 	ldw	r2,-4(fp)
2002a158:	1887883a 	add	r3,r3,r2
2002a15c:	e0bffd17 	ldw	r2,-12(fp)
2002a160:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
2002a164:	e0bffd17 	ldw	r2,-12(fp)
2002a168:	10c00217 	ldw	r3,8(r2)
2002a16c:	d0a60d17 	ldw	r2,-26572(gp)
2002a170:	1880032e 	bgeu	r3,r2,2002a180 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
2002a174:	e0bffd17 	ldw	r2,-12(fp)
2002a178:	00c00044 	movi	r3,1
2002a17c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
2002a180:	e0bffe17 	ldw	r2,-8(fp)
2002a184:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2002a188:	e0fffd17 	ldw	r3,-12(fp)
2002a18c:	d0a02804 	addi	r2,gp,-32608
2002a190:	18bfcf1e 	bne	r3,r2,2002a0d0 <__alt_data_end+0xfffea0d0>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
2002a194:	002180c0 	call	2002180c <OSTimeTick>
}
2002a198:	0001883a 	nop
2002a19c:	e037883a 	mov	sp,fp
2002a1a0:	dfc00117 	ldw	ra,4(sp)
2002a1a4:	df000017 	ldw	fp,0(sp)
2002a1a8:	dec00204 	addi	sp,sp,8
2002a1ac:	f800283a 	ret

2002a1b0 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
2002a1b0:	deffff04 	addi	sp,sp,-4
2002a1b4:	df000015 	stw	fp,0(sp)
2002a1b8:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
2002a1bc:	000170fa 	wrctl	ienable,zero
}
2002a1c0:	0001883a 	nop
2002a1c4:	e037883a 	mov	sp,fp
2002a1c8:	df000017 	ldw	fp,0(sp)
2002a1cc:	dec00104 	addi	sp,sp,4
2002a1d0:	f800283a 	ret

2002a1d4 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
2002a1d4:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
2002a1d8:	d0e02b17 	ldw	r3,-32596(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
2002a1dc:	d1260517 	ldw	r4,-26604(gp)

      stw ra,  0(sp)
2002a1e0:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
2002a1e4:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
2002a1e8:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
2002a1ec:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
2002a1f0:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
2002a1f4:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
2002a1f8:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
2002a1fc:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
2002a200:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
2002a204:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
2002a208:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
2002a20c:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
2002a210:	002a4480 	call	2002a448 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
2002a214:	d1260017 	ldw	r4,-26624(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
2002a218:	d165f807 	ldb	r5,-26656(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
2002a21c:	d1260515 	stw	r4,-26604(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
2002a220:	d165f845 	stb	r5,-26655(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
2002a224:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
2002a228:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
2002a22c:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
2002a230:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
2002a234:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
2002a238:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
2002a23c:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
2002a240:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
2002a244:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
2002a248:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
2002a24c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
2002a250:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
2002a254:	d0e02b15 	stw	r3,-32596(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
2002a258:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
2002a25c:	f800283a 	ret

2002a260 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
2002a260:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
2002a264:	047fff84 	movi	r17,-2
      and   r18, r18, r17
2002a268:	9464703a 	and	r18,r18,r17
      wrctl status, r18
2002a26c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
2002a270:	002a4480 	call	2002a448 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
2002a274:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
2002a278:	d4a5f645 	stb	r18,-26663(gp)

      /*
       * start execution of the new task.
       */

      br 9b
2002a27c:	003fe506 	br	2002a214 <__alt_data_end+0xfffea214>

2002a280 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
2002a280:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
2002a284:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
2002a288:	10800054 	ori	r2,r2,1
      wrctl status, r2
2002a28c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
2002a290:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
2002a294:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
2002a298:	dec00204 	addi	sp,sp,8

      callr r2
2002a29c:	103ee83a 	callr	r2

      nop
2002a2a0:	0001883a 	nop

2002a2a4 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
2002a2a4:	defff704 	addi	sp,sp,-36
2002a2a8:	dfc00815 	stw	ra,32(sp)
2002a2ac:	df000715 	stw	fp,28(sp)
2002a2b0:	df000704 	addi	fp,sp,28
2002a2b4:	e13ffc15 	stw	r4,-16(fp)
2002a2b8:	e17ffd15 	stw	r5,-12(fp)
2002a2bc:	e1bffe15 	stw	r6,-8(fp)
2002a2c0:	3805883a 	mov	r2,r7
2002a2c4:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
2002a2c8:	e0fffe17 	ldw	r3,-8(fp)
2002a2cc:	00bfff04 	movi	r2,-4
2002a2d0:	1884703a 	and	r2,r3,r2
2002a2d4:	10bef704 	addi	r2,r2,-1060
2002a2d8:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
2002a2dc:	01810904 	movi	r6,1060
2002a2e0:	000b883a 	mov	r5,zero
2002a2e4:	e13ff917 	ldw	r4,-28(fp)
2002a2e8:	002a9b00 	call	2002a9b0 <memset>
2002a2ec:	e0bff917 	ldw	r2,-28(fp)
2002a2f0:	10c0bb04 	addi	r3,r2,748
2002a2f4:	e0bff917 	ldw	r2,-28(fp)
2002a2f8:	10c00115 	stw	r3,4(r2)
2002a2fc:	e0bff917 	ldw	r2,-28(fp)
2002a300:	10c0d504 	addi	r3,r2,852
2002a304:	e0bff917 	ldw	r2,-28(fp)
2002a308:	10c00215 	stw	r3,8(r2)
2002a30c:	e0bff917 	ldw	r2,-28(fp)
2002a310:	10c0ef04 	addi	r3,r2,956
2002a314:	e0bff917 	ldw	r2,-28(fp)
2002a318:	10c00315 	stw	r3,12(r2)
2002a31c:	e0fff917 	ldw	r3,-28(fp)
2002a320:	008800f4 	movhi	r2,8195
2002a324:	10ac5d04 	addi	r2,r2,-20108
2002a328:	18800d15 	stw	r2,52(r3)
2002a32c:	e0bff917 	ldw	r2,-28(fp)
2002a330:	00c00044 	movi	r3,1
2002a334:	10c02915 	stw	r3,164(r2)
2002a338:	10002a15 	stw	zero,168(r2)
2002a33c:	e0bff917 	ldw	r2,-28(fp)
2002a340:	00ccc384 	movi	r3,13070
2002a344:	10c02b0d 	sth	r3,172(r2)
2002a348:	e0bff917 	ldw	r2,-28(fp)
2002a34c:	00eaf344 	movi	r3,-21555
2002a350:	10c02b8d 	sth	r3,174(r2)
2002a354:	e0bff917 	ldw	r2,-28(fp)
2002a358:	00c48d04 	movi	r3,4660
2002a35c:	10c02c0d 	sth	r3,176(r2)
2002a360:	e0bff917 	ldw	r2,-28(fp)
2002a364:	00f99b44 	movi	r3,-6547
2002a368:	10c02c8d 	sth	r3,178(r2)
2002a36c:	e0bff917 	ldw	r2,-28(fp)
2002a370:	00f7bb04 	movi	r3,-8468
2002a374:	10c02d0d 	sth	r3,180(r2)
2002a378:	e0bff917 	ldw	r2,-28(fp)
2002a37c:	00c00144 	movi	r3,5
2002a380:	10c02d8d 	sth	r3,182(r2)
2002a384:	e0bff917 	ldw	r2,-28(fp)
2002a388:	00c002c4 	movi	r3,11
2002a38c:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
2002a390:	e0bff917 	ldw	r2,-28(fp)
2002a394:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
2002a398:	e0bffa17 	ldw	r2,-24(fp)
2002a39c:	10bff304 	addi	r2,r2,-52
2002a3a0:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
2002a3a4:	e0bffb17 	ldw	r2,-20(fp)
2002a3a8:	10800c04 	addi	r2,r2,48
2002a3ac:	e0fffc17 	ldw	r3,-16(fp)
2002a3b0:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
2002a3b4:	e0bffb17 	ldw	r2,-20(fp)
2002a3b8:	10800b04 	addi	r2,r2,44
2002a3bc:	e0fffd17 	ldw	r3,-12(fp)
2002a3c0:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
2002a3c4:	e0bffb17 	ldw	r2,-20(fp)
2002a3c8:	10800a04 	addi	r2,r2,40
2002a3cc:	e0fff917 	ldw	r3,-28(fp)
2002a3d0:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
2002a3d4:	008800f4 	movhi	r2,8195
2002a3d8:	10a8a004 	addi	r2,r2,-23936
2002a3dc:	10c00104 	addi	r3,r2,4
2002a3e0:	e0bffb17 	ldw	r2,-20(fp)
2002a3e4:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
2002a3e8:	e0bffb17 	ldw	r2,-20(fp)
}
2002a3ec:	e037883a 	mov	sp,fp
2002a3f0:	dfc00117 	ldw	ra,4(sp)
2002a3f4:	df000017 	ldw	fp,0(sp)
2002a3f8:	dec00204 	addi	sp,sp,8
2002a3fc:	f800283a 	ret

2002a400 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
2002a400:	defffe04 	addi	sp,sp,-8
2002a404:	df000115 	stw	fp,4(sp)
2002a408:	df000104 	addi	fp,sp,4
2002a40c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
2002a410:	0001883a 	nop
2002a414:	e037883a 	mov	sp,fp
2002a418:	df000017 	ldw	fp,0(sp)
2002a41c:	dec00104 	addi	sp,sp,4
2002a420:	f800283a 	ret

2002a424 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
2002a424:	defffe04 	addi	sp,sp,-8
2002a428:	df000115 	stw	fp,4(sp)
2002a42c:	df000104 	addi	fp,sp,4
2002a430:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
2002a434:	0001883a 	nop
2002a438:	e037883a 	mov	sp,fp
2002a43c:	df000017 	ldw	fp,0(sp)
2002a440:	dec00104 	addi	sp,sp,4
2002a444:	f800283a 	ret

2002a448 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
2002a448:	deffff04 	addi	sp,sp,-4
2002a44c:	df000015 	stw	fp,0(sp)
2002a450:	d839883a 	mov	fp,sp
}
2002a454:	0001883a 	nop
2002a458:	e037883a 	mov	sp,fp
2002a45c:	df000017 	ldw	fp,0(sp)
2002a460:	dec00104 	addi	sp,sp,4
2002a464:	f800283a 	ret

2002a468 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
2002a468:	deffff04 	addi	sp,sp,-4
2002a46c:	df000015 	stw	fp,0(sp)
2002a470:	d839883a 	mov	fp,sp
}
2002a474:	0001883a 	nop
2002a478:	e037883a 	mov	sp,fp
2002a47c:	df000017 	ldw	fp,0(sp)
2002a480:	dec00104 	addi	sp,sp,4
2002a484:	f800283a 	ret

2002a488 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
2002a488:	deffff04 	addi	sp,sp,-4
2002a48c:	df000015 	stw	fp,0(sp)
2002a490:	d839883a 	mov	fp,sp
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
2002a494:	0001883a 	nop
2002a498:	e037883a 	mov	sp,fp
2002a49c:	df000017 	ldw	fp,0(sp)
2002a4a0:	dec00104 	addi	sp,sp,4
2002a4a4:	f800283a 	ret

2002a4a8 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
2002a4a8:	deffff04 	addi	sp,sp,-4
2002a4ac:	df000015 	stw	fp,0(sp)
2002a4b0:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
2002a4b4:	0001883a 	nop
2002a4b8:	e037883a 	mov	sp,fp
2002a4bc:	df000017 	ldw	fp,0(sp)
2002a4c0:	dec00104 	addi	sp,sp,4
2002a4c4:	f800283a 	ret

2002a4c8 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
2002a4c8:	deffff04 	addi	sp,sp,-4
2002a4cc:	df000015 	stw	fp,0(sp)
2002a4d0:	d839883a 	mov	fp,sp
}
2002a4d4:	0001883a 	nop
2002a4d8:	e037883a 	mov	sp,fp
2002a4dc:	df000017 	ldw	fp,0(sp)
2002a4e0:	dec00104 	addi	sp,sp,4
2002a4e4:	f800283a 	ret

2002a4e8 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
2002a4e8:	deffff04 	addi	sp,sp,-4
2002a4ec:	df000015 	stw	fp,0(sp)
2002a4f0:	d839883a 	mov	fp,sp
}
2002a4f4:	0001883a 	nop
2002a4f8:	e037883a 	mov	sp,fp
2002a4fc:	df000017 	ldw	fp,0(sp)
2002a500:	dec00104 	addi	sp,sp,4
2002a504:	f800283a 	ret

2002a508 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
2002a508:	defffe04 	addi	sp,sp,-8
2002a50c:	df000115 	stw	fp,4(sp)
2002a510:	df000104 	addi	fp,sp,4
2002a514:	e13fff15 	stw	r4,-4(fp)
}
2002a518:	0001883a 	nop
2002a51c:	e037883a 	mov	sp,fp
2002a520:	df000017 	ldw	fp,0(sp)
2002a524:	dec00104 	addi	sp,sp,4
2002a528:	f800283a 	ret

2002a52c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2002a52c:	defffb04 	addi	sp,sp,-20
2002a530:	dfc00415 	stw	ra,16(sp)
2002a534:	df000315 	stw	fp,12(sp)
2002a538:	df000304 	addi	fp,sp,12
2002a53c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
2002a540:	d0a02217 	ldw	r2,-32632(gp)
2002a544:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
2002a548:	00003106 	br	2002a610 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
2002a54c:	e0bffd17 	ldw	r2,-12(fp)
2002a550:	10800217 	ldw	r2,8(r2)
2002a554:	1009883a 	mov	r4,r2
2002a558:	002aad80 	call	2002aad8 <strlen>
2002a55c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
2002a560:	e0bffd17 	ldw	r2,-12(fp)
2002a564:	10c00217 	ldw	r3,8(r2)
2002a568:	e0bffe17 	ldw	r2,-8(fp)
2002a56c:	10bfffc4 	addi	r2,r2,-1
2002a570:	1885883a 	add	r2,r3,r2
2002a574:	10800003 	ldbu	r2,0(r2)
2002a578:	10803fcc 	andi	r2,r2,255
2002a57c:	1080201c 	xori	r2,r2,128
2002a580:	10bfe004 	addi	r2,r2,-128
2002a584:	10800bd8 	cmpnei	r2,r2,47
2002a588:	1000031e 	bne	r2,zero,2002a598 <alt_find_file+0x6c>
    {
      len -= 1;
2002a58c:	e0bffe17 	ldw	r2,-8(fp)
2002a590:	10bfffc4 	addi	r2,r2,-1
2002a594:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
2002a598:	e0bffe17 	ldw	r2,-8(fp)
2002a59c:	e0ffff17 	ldw	r3,-4(fp)
2002a5a0:	1885883a 	add	r2,r3,r2
2002a5a4:	10800003 	ldbu	r2,0(r2)
2002a5a8:	10803fcc 	andi	r2,r2,255
2002a5ac:	1080201c 	xori	r2,r2,128
2002a5b0:	10bfe004 	addi	r2,r2,-128
2002a5b4:	10800be0 	cmpeqi	r2,r2,47
2002a5b8:	1000081e 	bne	r2,zero,2002a5dc <alt_find_file+0xb0>
2002a5bc:	e0bffe17 	ldw	r2,-8(fp)
2002a5c0:	e0ffff17 	ldw	r3,-4(fp)
2002a5c4:	1885883a 	add	r2,r3,r2
2002a5c8:	10800003 	ldbu	r2,0(r2)
2002a5cc:	10803fcc 	andi	r2,r2,255
2002a5d0:	1080201c 	xori	r2,r2,128
2002a5d4:	10bfe004 	addi	r2,r2,-128
2002a5d8:	10000a1e 	bne	r2,zero,2002a604 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
2002a5dc:	e0bffd17 	ldw	r2,-12(fp)
2002a5e0:	10800217 	ldw	r2,8(r2)
2002a5e4:	e0fffe17 	ldw	r3,-8(fp)
2002a5e8:	180d883a 	mov	r6,r3
2002a5ec:	e17fff17 	ldw	r5,-4(fp)
2002a5f0:	1009883a 	mov	r4,r2
2002a5f4:	002a7ec0 	call	2002a7ec <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
2002a5f8:	1000021e 	bne	r2,zero,2002a604 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
2002a5fc:	e0bffd17 	ldw	r2,-12(fp)
2002a600:	00000706 	br	2002a620 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
2002a604:	e0bffd17 	ldw	r2,-12(fp)
2002a608:	10800017 	ldw	r2,0(r2)
2002a60c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
2002a610:	e0fffd17 	ldw	r3,-12(fp)
2002a614:	d0a02204 	addi	r2,gp,-32632
2002a618:	18bfcc1e 	bne	r3,r2,2002a54c <__alt_data_end+0xfffea54c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
2002a61c:	0005883a 	mov	r2,zero
}
2002a620:	e037883a 	mov	sp,fp
2002a624:	dfc00117 	ldw	ra,4(sp)
2002a628:	df000017 	ldw	fp,0(sp)
2002a62c:	dec00204 	addi	sp,sp,8
2002a630:	f800283a 	ret

2002a634 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
2002a634:	defff904 	addi	sp,sp,-28
2002a638:	dfc00615 	stw	ra,24(sp)
2002a63c:	df000515 	stw	fp,20(sp)
2002a640:	df000504 	addi	fp,sp,20
2002a644:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
2002a648:	00bffa04 	movi	r2,-24
2002a64c:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
2002a650:	d0a60a17 	ldw	r2,-26584(gp)
2002a654:	e0bffd15 	stw	r2,-12(fp)
2002a658:	e03ffe0d 	sth	zero,-8(fp)
2002a65c:	e0bffe0b 	ldhu	r2,-8(fp)
2002a660:	e0fffe84 	addi	r3,fp,-6
2002a664:	180d883a 	mov	r6,r3
2002a668:	100b883a 	mov	r5,r2
2002a66c:	e13ffd17 	ldw	r4,-12(fp)
2002a670:	00260500 	call	20026050 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
2002a674:	e03ffb15 	stw	zero,-20(fp)
2002a678:	00001906 	br	2002a6e0 <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
2002a67c:	008800f4 	movhi	r2,8195
2002a680:	10b08904 	addi	r2,r2,-15836
2002a684:	e0fffb17 	ldw	r3,-20(fp)
2002a688:	18c00324 	muli	r3,r3,12
2002a68c:	10c5883a 	add	r2,r2,r3
2002a690:	10800017 	ldw	r2,0(r2)
2002a694:	10000f1e 	bne	r2,zero,2002a6d4 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
2002a698:	008800f4 	movhi	r2,8195
2002a69c:	10b08904 	addi	r2,r2,-15836
2002a6a0:	e0fffb17 	ldw	r3,-20(fp)
2002a6a4:	18c00324 	muli	r3,r3,12
2002a6a8:	10c5883a 	add	r2,r2,r3
2002a6ac:	e0ffff17 	ldw	r3,-4(fp)
2002a6b0:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
2002a6b4:	d0e02617 	ldw	r3,-32616(gp)
2002a6b8:	e0bffb17 	ldw	r2,-20(fp)
2002a6bc:	1880020e 	bge	r3,r2,2002a6c8 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
2002a6c0:	e0bffb17 	ldw	r2,-20(fp)
2002a6c4:	d0a02615 	stw	r2,-32616(gp)
      }
      rc = i;
2002a6c8:	e0bffb17 	ldw	r2,-20(fp)
2002a6cc:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
2002a6d0:	00000606 	br	2002a6ec <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
2002a6d4:	e0bffb17 	ldw	r2,-20(fp)
2002a6d8:	10800044 	addi	r2,r2,1
2002a6dc:	e0bffb15 	stw	r2,-20(fp)
2002a6e0:	e0bffb17 	ldw	r2,-20(fp)
2002a6e4:	10800810 	cmplti	r2,r2,32
2002a6e8:	103fe41e 	bne	r2,zero,2002a67c <__alt_data_end+0xfffea67c>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
2002a6ec:	d0a60a17 	ldw	r2,-26584(gp)
2002a6f0:	1009883a 	mov	r4,r2
2002a6f4:	00263c80 	call	200263c8 <OSSemPost>

  return rc;
2002a6f8:	e0bffc17 	ldw	r2,-16(fp)
}
2002a6fc:	e037883a 	mov	sp,fp
2002a700:	dfc00117 	ldw	ra,4(sp)
2002a704:	df000017 	ldw	fp,0(sp)
2002a708:	dec00204 	addi	sp,sp,8
2002a70c:	f800283a 	ret

2002a710 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
2002a710:	defffb04 	addi	sp,sp,-20
2002a714:	df000415 	stw	fp,16(sp)
2002a718:	df000404 	addi	fp,sp,16
2002a71c:	e13ffe15 	stw	r4,-8(fp)
2002a720:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
2002a724:	e0bfff17 	ldw	r2,-4(fp)
2002a728:	10840070 	cmpltui	r2,r2,4097
2002a72c:	1000021e 	bne	r2,zero,2002a738 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
2002a730:	00840004 	movi	r2,4096
2002a734:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
2002a738:	e0fffe17 	ldw	r3,-8(fp)
2002a73c:	e0bfff17 	ldw	r2,-4(fp)
2002a740:	1885883a 	add	r2,r3,r2
2002a744:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
2002a748:	e0bffe17 	ldw	r2,-8(fp)
2002a74c:	e0bffc15 	stw	r2,-16(fp)
2002a750:	00000506 	br	2002a768 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
2002a754:	e0bffc17 	ldw	r2,-16(fp)
2002a758:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
2002a75c:	e0bffc17 	ldw	r2,-16(fp)
2002a760:	10800804 	addi	r2,r2,32
2002a764:	e0bffc15 	stw	r2,-16(fp)
2002a768:	e0fffc17 	ldw	r3,-16(fp)
2002a76c:	e0bffd17 	ldw	r2,-12(fp)
2002a770:	18bff836 	bltu	r3,r2,2002a754 <__alt_data_end+0xfffea754>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
2002a774:	e0bffe17 	ldw	r2,-8(fp)
2002a778:	108007cc 	andi	r2,r2,31
2002a77c:	10000226 	beq	r2,zero,2002a788 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
2002a780:	e0bffc17 	ldw	r2,-16(fp)
2002a784:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
2002a788:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
2002a78c:	0001883a 	nop
2002a790:	e037883a 	mov	sp,fp
2002a794:	df000017 	ldw	fp,0(sp)
2002a798:	dec00104 	addi	sp,sp,4
2002a79c:	f800283a 	ret

2002a7a0 <atexit>:
2002a7a0:	200b883a 	mov	r5,r4
2002a7a4:	000f883a 	mov	r7,zero
2002a7a8:	000d883a 	mov	r6,zero
2002a7ac:	0009883a 	mov	r4,zero
2002a7b0:	002ab701 	jmpi	2002ab70 <__register_exitproc>

2002a7b4 <exit>:
2002a7b4:	defffe04 	addi	sp,sp,-8
2002a7b8:	000b883a 	mov	r5,zero
2002a7bc:	dc000015 	stw	r16,0(sp)
2002a7c0:	dfc00115 	stw	ra,4(sp)
2002a7c4:	2021883a 	mov	r16,r4
2002a7c8:	002ac880 	call	2002ac88 <__call_exitprocs>
2002a7cc:	008800f4 	movhi	r2,8195
2002a7d0:	10b21c04 	addi	r2,r2,-14224
2002a7d4:	11000017 	ldw	r4,0(r2)
2002a7d8:	20800f17 	ldw	r2,60(r4)
2002a7dc:	10000126 	beq	r2,zero,2002a7e4 <exit+0x30>
2002a7e0:	103ee83a 	callr	r2
2002a7e4:	8009883a 	mov	r4,r16
2002a7e8:	002afbc0 	call	2002afbc <_exit>

2002a7ec <memcmp>:
2002a7ec:	01c000c4 	movi	r7,3
2002a7f0:	3980192e 	bgeu	r7,r6,2002a858 <memcmp+0x6c>
2002a7f4:	2144b03a 	or	r2,r4,r5
2002a7f8:	11c4703a 	and	r2,r2,r7
2002a7fc:	10000f26 	beq	r2,zero,2002a83c <memcmp+0x50>
2002a800:	20800003 	ldbu	r2,0(r4)
2002a804:	28c00003 	ldbu	r3,0(r5)
2002a808:	10c0151e 	bne	r2,r3,2002a860 <memcmp+0x74>
2002a80c:	31bfff84 	addi	r6,r6,-2
2002a810:	01ffffc4 	movi	r7,-1
2002a814:	00000406 	br	2002a828 <memcmp+0x3c>
2002a818:	20800003 	ldbu	r2,0(r4)
2002a81c:	28c00003 	ldbu	r3,0(r5)
2002a820:	31bfffc4 	addi	r6,r6,-1
2002a824:	10c00e1e 	bne	r2,r3,2002a860 <memcmp+0x74>
2002a828:	21000044 	addi	r4,r4,1
2002a82c:	29400044 	addi	r5,r5,1
2002a830:	31fff91e 	bne	r6,r7,2002a818 <__alt_data_end+0xfffea818>
2002a834:	0005883a 	mov	r2,zero
2002a838:	f800283a 	ret
2002a83c:	20c00017 	ldw	r3,0(r4)
2002a840:	28800017 	ldw	r2,0(r5)
2002a844:	18bfee1e 	bne	r3,r2,2002a800 <__alt_data_end+0xfffea800>
2002a848:	31bfff04 	addi	r6,r6,-4
2002a84c:	21000104 	addi	r4,r4,4
2002a850:	29400104 	addi	r5,r5,4
2002a854:	39bff936 	bltu	r7,r6,2002a83c <__alt_data_end+0xfffea83c>
2002a858:	303fe91e 	bne	r6,zero,2002a800 <__alt_data_end+0xfffea800>
2002a85c:	003ff506 	br	2002a834 <__alt_data_end+0xfffea834>
2002a860:	10c5c83a 	sub	r2,r2,r3
2002a864:	f800283a 	ret

2002a868 <memcpy>:
2002a868:	defffd04 	addi	sp,sp,-12
2002a86c:	dfc00215 	stw	ra,8(sp)
2002a870:	dc400115 	stw	r17,4(sp)
2002a874:	dc000015 	stw	r16,0(sp)
2002a878:	00c003c4 	movi	r3,15
2002a87c:	2005883a 	mov	r2,r4
2002a880:	1980452e 	bgeu	r3,r6,2002a998 <memcpy+0x130>
2002a884:	2906b03a 	or	r3,r5,r4
2002a888:	18c000cc 	andi	r3,r3,3
2002a88c:	1800441e 	bne	r3,zero,2002a9a0 <memcpy+0x138>
2002a890:	347ffc04 	addi	r17,r6,-16
2002a894:	8822d13a 	srli	r17,r17,4
2002a898:	28c00104 	addi	r3,r5,4
2002a89c:	23400104 	addi	r13,r4,4
2002a8a0:	8820913a 	slli	r16,r17,4
2002a8a4:	2b000204 	addi	r12,r5,8
2002a8a8:	22c00204 	addi	r11,r4,8
2002a8ac:	84000504 	addi	r16,r16,20
2002a8b0:	2a800304 	addi	r10,r5,12
2002a8b4:	22400304 	addi	r9,r4,12
2002a8b8:	2c21883a 	add	r16,r5,r16
2002a8bc:	2811883a 	mov	r8,r5
2002a8c0:	200f883a 	mov	r7,r4
2002a8c4:	41000017 	ldw	r4,0(r8)
2002a8c8:	1fc00017 	ldw	ra,0(r3)
2002a8cc:	63c00017 	ldw	r15,0(r12)
2002a8d0:	39000015 	stw	r4,0(r7)
2002a8d4:	53800017 	ldw	r14,0(r10)
2002a8d8:	6fc00015 	stw	ra,0(r13)
2002a8dc:	5bc00015 	stw	r15,0(r11)
2002a8e0:	4b800015 	stw	r14,0(r9)
2002a8e4:	18c00404 	addi	r3,r3,16
2002a8e8:	39c00404 	addi	r7,r7,16
2002a8ec:	42000404 	addi	r8,r8,16
2002a8f0:	6b400404 	addi	r13,r13,16
2002a8f4:	63000404 	addi	r12,r12,16
2002a8f8:	5ac00404 	addi	r11,r11,16
2002a8fc:	52800404 	addi	r10,r10,16
2002a900:	4a400404 	addi	r9,r9,16
2002a904:	1c3fef1e 	bne	r3,r16,2002a8c4 <__alt_data_end+0xfffea8c4>
2002a908:	89c00044 	addi	r7,r17,1
2002a90c:	380e913a 	slli	r7,r7,4
2002a910:	310003cc 	andi	r4,r6,15
2002a914:	02c000c4 	movi	r11,3
2002a918:	11c7883a 	add	r3,r2,r7
2002a91c:	29cb883a 	add	r5,r5,r7
2002a920:	5900212e 	bgeu	r11,r4,2002a9a8 <memcpy+0x140>
2002a924:	1813883a 	mov	r9,r3
2002a928:	2811883a 	mov	r8,r5
2002a92c:	200f883a 	mov	r7,r4
2002a930:	42800017 	ldw	r10,0(r8)
2002a934:	4a400104 	addi	r9,r9,4
2002a938:	39ffff04 	addi	r7,r7,-4
2002a93c:	4abfff15 	stw	r10,-4(r9)
2002a940:	42000104 	addi	r8,r8,4
2002a944:	59fffa36 	bltu	r11,r7,2002a930 <__alt_data_end+0xfffea930>
2002a948:	213fff04 	addi	r4,r4,-4
2002a94c:	2008d0ba 	srli	r4,r4,2
2002a950:	318000cc 	andi	r6,r6,3
2002a954:	21000044 	addi	r4,r4,1
2002a958:	2109883a 	add	r4,r4,r4
2002a95c:	2109883a 	add	r4,r4,r4
2002a960:	1907883a 	add	r3,r3,r4
2002a964:	290b883a 	add	r5,r5,r4
2002a968:	30000626 	beq	r6,zero,2002a984 <memcpy+0x11c>
2002a96c:	198d883a 	add	r6,r3,r6
2002a970:	29c00003 	ldbu	r7,0(r5)
2002a974:	18c00044 	addi	r3,r3,1
2002a978:	29400044 	addi	r5,r5,1
2002a97c:	19ffffc5 	stb	r7,-1(r3)
2002a980:	19bffb1e 	bne	r3,r6,2002a970 <__alt_data_end+0xfffea970>
2002a984:	dfc00217 	ldw	ra,8(sp)
2002a988:	dc400117 	ldw	r17,4(sp)
2002a98c:	dc000017 	ldw	r16,0(sp)
2002a990:	dec00304 	addi	sp,sp,12
2002a994:	f800283a 	ret
2002a998:	2007883a 	mov	r3,r4
2002a99c:	003ff206 	br	2002a968 <__alt_data_end+0xfffea968>
2002a9a0:	2007883a 	mov	r3,r4
2002a9a4:	003ff106 	br	2002a96c <__alt_data_end+0xfffea96c>
2002a9a8:	200d883a 	mov	r6,r4
2002a9ac:	003fee06 	br	2002a968 <__alt_data_end+0xfffea968>

2002a9b0 <memset>:
2002a9b0:	20c000cc 	andi	r3,r4,3
2002a9b4:	2005883a 	mov	r2,r4
2002a9b8:	18004426 	beq	r3,zero,2002aacc <memset+0x11c>
2002a9bc:	31ffffc4 	addi	r7,r6,-1
2002a9c0:	30004026 	beq	r6,zero,2002aac4 <memset+0x114>
2002a9c4:	2813883a 	mov	r9,r5
2002a9c8:	200d883a 	mov	r6,r4
2002a9cc:	2007883a 	mov	r3,r4
2002a9d0:	00000406 	br	2002a9e4 <memset+0x34>
2002a9d4:	3a3fffc4 	addi	r8,r7,-1
2002a9d8:	31800044 	addi	r6,r6,1
2002a9dc:	38003926 	beq	r7,zero,2002aac4 <memset+0x114>
2002a9e0:	400f883a 	mov	r7,r8
2002a9e4:	18c00044 	addi	r3,r3,1
2002a9e8:	32400005 	stb	r9,0(r6)
2002a9ec:	1a0000cc 	andi	r8,r3,3
2002a9f0:	403ff81e 	bne	r8,zero,2002a9d4 <__alt_data_end+0xfffea9d4>
2002a9f4:	010000c4 	movi	r4,3
2002a9f8:	21c02d2e 	bgeu	r4,r7,2002aab0 <memset+0x100>
2002a9fc:	29003fcc 	andi	r4,r5,255
2002aa00:	200c923a 	slli	r6,r4,8
2002aa04:	3108b03a 	or	r4,r6,r4
2002aa08:	200c943a 	slli	r6,r4,16
2002aa0c:	218cb03a 	or	r6,r4,r6
2002aa10:	010003c4 	movi	r4,15
2002aa14:	21c0182e 	bgeu	r4,r7,2002aa78 <memset+0xc8>
2002aa18:	3b3ffc04 	addi	r12,r7,-16
2002aa1c:	6018d13a 	srli	r12,r12,4
2002aa20:	1a000104 	addi	r8,r3,4
2002aa24:	1ac00204 	addi	r11,r3,8
2002aa28:	6008913a 	slli	r4,r12,4
2002aa2c:	1a800304 	addi	r10,r3,12
2002aa30:	1813883a 	mov	r9,r3
2002aa34:	21000504 	addi	r4,r4,20
2002aa38:	1909883a 	add	r4,r3,r4
2002aa3c:	49800015 	stw	r6,0(r9)
2002aa40:	41800015 	stw	r6,0(r8)
2002aa44:	59800015 	stw	r6,0(r11)
2002aa48:	51800015 	stw	r6,0(r10)
2002aa4c:	42000404 	addi	r8,r8,16
2002aa50:	4a400404 	addi	r9,r9,16
2002aa54:	5ac00404 	addi	r11,r11,16
2002aa58:	52800404 	addi	r10,r10,16
2002aa5c:	413ff71e 	bne	r8,r4,2002aa3c <__alt_data_end+0xfffeaa3c>
2002aa60:	63000044 	addi	r12,r12,1
2002aa64:	6018913a 	slli	r12,r12,4
2002aa68:	39c003cc 	andi	r7,r7,15
2002aa6c:	010000c4 	movi	r4,3
2002aa70:	1b07883a 	add	r3,r3,r12
2002aa74:	21c00e2e 	bgeu	r4,r7,2002aab0 <memset+0x100>
2002aa78:	1813883a 	mov	r9,r3
2002aa7c:	3811883a 	mov	r8,r7
2002aa80:	010000c4 	movi	r4,3
2002aa84:	49800015 	stw	r6,0(r9)
2002aa88:	423fff04 	addi	r8,r8,-4
2002aa8c:	4a400104 	addi	r9,r9,4
2002aa90:	223ffc36 	bltu	r4,r8,2002aa84 <__alt_data_end+0xfffeaa84>
2002aa94:	393fff04 	addi	r4,r7,-4
2002aa98:	2008d0ba 	srli	r4,r4,2
2002aa9c:	39c000cc 	andi	r7,r7,3
2002aaa0:	21000044 	addi	r4,r4,1
2002aaa4:	2109883a 	add	r4,r4,r4
2002aaa8:	2109883a 	add	r4,r4,r4
2002aaac:	1907883a 	add	r3,r3,r4
2002aab0:	38000526 	beq	r7,zero,2002aac8 <memset+0x118>
2002aab4:	19cf883a 	add	r7,r3,r7
2002aab8:	19400005 	stb	r5,0(r3)
2002aabc:	18c00044 	addi	r3,r3,1
2002aac0:	38fffd1e 	bne	r7,r3,2002aab8 <__alt_data_end+0xfffeaab8>
2002aac4:	f800283a 	ret
2002aac8:	f800283a 	ret
2002aacc:	2007883a 	mov	r3,r4
2002aad0:	300f883a 	mov	r7,r6
2002aad4:	003fc706 	br	2002a9f4 <__alt_data_end+0xfffea9f4>

2002aad8 <strlen>:
2002aad8:	208000cc 	andi	r2,r4,3
2002aadc:	10002026 	beq	r2,zero,2002ab60 <strlen+0x88>
2002aae0:	20800007 	ldb	r2,0(r4)
2002aae4:	10002026 	beq	r2,zero,2002ab68 <strlen+0x90>
2002aae8:	2005883a 	mov	r2,r4
2002aaec:	00000206 	br	2002aaf8 <strlen+0x20>
2002aaf0:	10c00007 	ldb	r3,0(r2)
2002aaf4:	18001826 	beq	r3,zero,2002ab58 <strlen+0x80>
2002aaf8:	10800044 	addi	r2,r2,1
2002aafc:	10c000cc 	andi	r3,r2,3
2002ab00:	183ffb1e 	bne	r3,zero,2002aaf0 <__alt_data_end+0xfffeaaf0>
2002ab04:	10c00017 	ldw	r3,0(r2)
2002ab08:	01ffbff4 	movhi	r7,65279
2002ab0c:	39ffbfc4 	addi	r7,r7,-257
2002ab10:	00ca303a 	nor	r5,zero,r3
2002ab14:	01a02074 	movhi	r6,32897
2002ab18:	19c7883a 	add	r3,r3,r7
2002ab1c:	31a02004 	addi	r6,r6,-32640
2002ab20:	1946703a 	and	r3,r3,r5
2002ab24:	1986703a 	and	r3,r3,r6
2002ab28:	1800091e 	bne	r3,zero,2002ab50 <strlen+0x78>
2002ab2c:	10800104 	addi	r2,r2,4
2002ab30:	10c00017 	ldw	r3,0(r2)
2002ab34:	19cb883a 	add	r5,r3,r7
2002ab38:	00c6303a 	nor	r3,zero,r3
2002ab3c:	28c6703a 	and	r3,r5,r3
2002ab40:	1986703a 	and	r3,r3,r6
2002ab44:	183ff926 	beq	r3,zero,2002ab2c <__alt_data_end+0xfffeab2c>
2002ab48:	00000106 	br	2002ab50 <strlen+0x78>
2002ab4c:	10800044 	addi	r2,r2,1
2002ab50:	10c00007 	ldb	r3,0(r2)
2002ab54:	183ffd1e 	bne	r3,zero,2002ab4c <__alt_data_end+0xfffeab4c>
2002ab58:	1105c83a 	sub	r2,r2,r4
2002ab5c:	f800283a 	ret
2002ab60:	2005883a 	mov	r2,r4
2002ab64:	003fe706 	br	2002ab04 <__alt_data_end+0xfffeab04>
2002ab68:	0005883a 	mov	r2,zero
2002ab6c:	f800283a 	ret

2002ab70 <__register_exitproc>:
2002ab70:	defffa04 	addi	sp,sp,-24
2002ab74:	dc000315 	stw	r16,12(sp)
2002ab78:	040800f4 	movhi	r16,8195
2002ab7c:	84321c04 	addi	r16,r16,-14224
2002ab80:	80c00017 	ldw	r3,0(r16)
2002ab84:	dc400415 	stw	r17,16(sp)
2002ab88:	dfc00515 	stw	ra,20(sp)
2002ab8c:	18805217 	ldw	r2,328(r3)
2002ab90:	2023883a 	mov	r17,r4
2002ab94:	10003726 	beq	r2,zero,2002ac74 <__register_exitproc+0x104>
2002ab98:	10c00117 	ldw	r3,4(r2)
2002ab9c:	010007c4 	movi	r4,31
2002aba0:	20c00e16 	blt	r4,r3,2002abdc <__register_exitproc+0x6c>
2002aba4:	1a000044 	addi	r8,r3,1
2002aba8:	8800221e 	bne	r17,zero,2002ac34 <__register_exitproc+0xc4>
2002abac:	18c00084 	addi	r3,r3,2
2002abb0:	18c7883a 	add	r3,r3,r3
2002abb4:	18c7883a 	add	r3,r3,r3
2002abb8:	12000115 	stw	r8,4(r2)
2002abbc:	10c7883a 	add	r3,r2,r3
2002abc0:	19400015 	stw	r5,0(r3)
2002abc4:	0005883a 	mov	r2,zero
2002abc8:	dfc00517 	ldw	ra,20(sp)
2002abcc:	dc400417 	ldw	r17,16(sp)
2002abd0:	dc000317 	ldw	r16,12(sp)
2002abd4:	dec00604 	addi	sp,sp,24
2002abd8:	f800283a 	ret
2002abdc:	00800034 	movhi	r2,0
2002abe0:	10800004 	addi	r2,r2,0
2002abe4:	10002626 	beq	r2,zero,2002ac80 <__register_exitproc+0x110>
2002abe8:	01006404 	movi	r4,400
2002abec:	d9400015 	stw	r5,0(sp)
2002abf0:	d9800115 	stw	r6,4(sp)
2002abf4:	d9c00215 	stw	r7,8(sp)
2002abf8:	00000000 	call	20000000 <__alt_mem_sdram_controller+0x10000000>
2002abfc:	d9400017 	ldw	r5,0(sp)
2002ac00:	d9800117 	ldw	r6,4(sp)
2002ac04:	d9c00217 	ldw	r7,8(sp)
2002ac08:	10001d26 	beq	r2,zero,2002ac80 <__register_exitproc+0x110>
2002ac0c:	81000017 	ldw	r4,0(r16)
2002ac10:	10000115 	stw	zero,4(r2)
2002ac14:	02000044 	movi	r8,1
2002ac18:	22405217 	ldw	r9,328(r4)
2002ac1c:	0007883a 	mov	r3,zero
2002ac20:	12400015 	stw	r9,0(r2)
2002ac24:	20805215 	stw	r2,328(r4)
2002ac28:	10006215 	stw	zero,392(r2)
2002ac2c:	10006315 	stw	zero,396(r2)
2002ac30:	883fde26 	beq	r17,zero,2002abac <__alt_data_end+0xfffeabac>
2002ac34:	18c9883a 	add	r4,r3,r3
2002ac38:	2109883a 	add	r4,r4,r4
2002ac3c:	1109883a 	add	r4,r2,r4
2002ac40:	21802215 	stw	r6,136(r4)
2002ac44:	01800044 	movi	r6,1
2002ac48:	12406217 	ldw	r9,392(r2)
2002ac4c:	30cc983a 	sll	r6,r6,r3
2002ac50:	4992b03a 	or	r9,r9,r6
2002ac54:	12406215 	stw	r9,392(r2)
2002ac58:	21c04215 	stw	r7,264(r4)
2002ac5c:	01000084 	movi	r4,2
2002ac60:	893fd21e 	bne	r17,r4,2002abac <__alt_data_end+0xfffeabac>
2002ac64:	11006317 	ldw	r4,396(r2)
2002ac68:	218cb03a 	or	r6,r4,r6
2002ac6c:	11806315 	stw	r6,396(r2)
2002ac70:	003fce06 	br	2002abac <__alt_data_end+0xfffeabac>
2002ac74:	18805304 	addi	r2,r3,332
2002ac78:	18805215 	stw	r2,328(r3)
2002ac7c:	003fc606 	br	2002ab98 <__alt_data_end+0xfffeab98>
2002ac80:	00bfffc4 	movi	r2,-1
2002ac84:	003fd006 	br	2002abc8 <__alt_data_end+0xfffeabc8>

2002ac88 <__call_exitprocs>:
2002ac88:	defff504 	addi	sp,sp,-44
2002ac8c:	df000915 	stw	fp,36(sp)
2002ac90:	dd400615 	stw	r21,24(sp)
2002ac94:	dc800315 	stw	r18,12(sp)
2002ac98:	dfc00a15 	stw	ra,40(sp)
2002ac9c:	ddc00815 	stw	r23,32(sp)
2002aca0:	dd800715 	stw	r22,28(sp)
2002aca4:	dd000515 	stw	r20,20(sp)
2002aca8:	dcc00415 	stw	r19,16(sp)
2002acac:	dc400215 	stw	r17,8(sp)
2002acb0:	dc000115 	stw	r16,4(sp)
2002acb4:	d9000015 	stw	r4,0(sp)
2002acb8:	2839883a 	mov	fp,r5
2002acbc:	04800044 	movi	r18,1
2002acc0:	057fffc4 	movi	r21,-1
2002acc4:	008800f4 	movhi	r2,8195
2002acc8:	10b21c04 	addi	r2,r2,-14224
2002accc:	12000017 	ldw	r8,0(r2)
2002acd0:	45005217 	ldw	r20,328(r8)
2002acd4:	44c05204 	addi	r19,r8,328
2002acd8:	a0001c26 	beq	r20,zero,2002ad4c <__call_exitprocs+0xc4>
2002acdc:	a0800117 	ldw	r2,4(r20)
2002ace0:	15ffffc4 	addi	r23,r2,-1
2002ace4:	b8000d16 	blt	r23,zero,2002ad1c <__call_exitprocs+0x94>
2002ace8:	14000044 	addi	r16,r2,1
2002acec:	8421883a 	add	r16,r16,r16
2002acf0:	8421883a 	add	r16,r16,r16
2002acf4:	84402004 	addi	r17,r16,128
2002acf8:	a463883a 	add	r17,r20,r17
2002acfc:	a421883a 	add	r16,r20,r16
2002ad00:	e0001e26 	beq	fp,zero,2002ad7c <__call_exitprocs+0xf4>
2002ad04:	80804017 	ldw	r2,256(r16)
2002ad08:	e0801c26 	beq	fp,r2,2002ad7c <__call_exitprocs+0xf4>
2002ad0c:	bdffffc4 	addi	r23,r23,-1
2002ad10:	843fff04 	addi	r16,r16,-4
2002ad14:	8c7fff04 	addi	r17,r17,-4
2002ad18:	bd7ff91e 	bne	r23,r21,2002ad00 <__alt_data_end+0xfffead00>
2002ad1c:	00800034 	movhi	r2,0
2002ad20:	10800004 	addi	r2,r2,0
2002ad24:	10000926 	beq	r2,zero,2002ad4c <__call_exitprocs+0xc4>
2002ad28:	a0800117 	ldw	r2,4(r20)
2002ad2c:	1000301e 	bne	r2,zero,2002adf0 <__call_exitprocs+0x168>
2002ad30:	a0800017 	ldw	r2,0(r20)
2002ad34:	10003226 	beq	r2,zero,2002ae00 <__call_exitprocs+0x178>
2002ad38:	a009883a 	mov	r4,r20
2002ad3c:	98800015 	stw	r2,0(r19)
2002ad40:	00000000 	call	20000000 <__alt_mem_sdram_controller+0x10000000>
2002ad44:	9d000017 	ldw	r20,0(r19)
2002ad48:	a03fe41e 	bne	r20,zero,2002acdc <__alt_data_end+0xfffeacdc>
2002ad4c:	dfc00a17 	ldw	ra,40(sp)
2002ad50:	df000917 	ldw	fp,36(sp)
2002ad54:	ddc00817 	ldw	r23,32(sp)
2002ad58:	dd800717 	ldw	r22,28(sp)
2002ad5c:	dd400617 	ldw	r21,24(sp)
2002ad60:	dd000517 	ldw	r20,20(sp)
2002ad64:	dcc00417 	ldw	r19,16(sp)
2002ad68:	dc800317 	ldw	r18,12(sp)
2002ad6c:	dc400217 	ldw	r17,8(sp)
2002ad70:	dc000117 	ldw	r16,4(sp)
2002ad74:	dec00b04 	addi	sp,sp,44
2002ad78:	f800283a 	ret
2002ad7c:	a0800117 	ldw	r2,4(r20)
2002ad80:	80c00017 	ldw	r3,0(r16)
2002ad84:	10bfffc4 	addi	r2,r2,-1
2002ad88:	15c01426 	beq	r2,r23,2002addc <__call_exitprocs+0x154>
2002ad8c:	80000015 	stw	zero,0(r16)
2002ad90:	183fde26 	beq	r3,zero,2002ad0c <__alt_data_end+0xfffead0c>
2002ad94:	95c8983a 	sll	r4,r18,r23
2002ad98:	a0806217 	ldw	r2,392(r20)
2002ad9c:	a5800117 	ldw	r22,4(r20)
2002ada0:	2084703a 	and	r2,r4,r2
2002ada4:	10000b26 	beq	r2,zero,2002add4 <__call_exitprocs+0x14c>
2002ada8:	a0806317 	ldw	r2,396(r20)
2002adac:	2088703a 	and	r4,r4,r2
2002adb0:	20000c1e 	bne	r4,zero,2002ade4 <__call_exitprocs+0x15c>
2002adb4:	89400017 	ldw	r5,0(r17)
2002adb8:	d9000017 	ldw	r4,0(sp)
2002adbc:	183ee83a 	callr	r3
2002adc0:	a0800117 	ldw	r2,4(r20)
2002adc4:	15bfbf1e 	bne	r2,r22,2002acc4 <__alt_data_end+0xfffeacc4>
2002adc8:	98800017 	ldw	r2,0(r19)
2002adcc:	153fcf26 	beq	r2,r20,2002ad0c <__alt_data_end+0xfffead0c>
2002add0:	003fbc06 	br	2002acc4 <__alt_data_end+0xfffeacc4>
2002add4:	183ee83a 	callr	r3
2002add8:	003ff906 	br	2002adc0 <__alt_data_end+0xfffeadc0>
2002addc:	a5c00115 	stw	r23,4(r20)
2002ade0:	003feb06 	br	2002ad90 <__alt_data_end+0xfffead90>
2002ade4:	89000017 	ldw	r4,0(r17)
2002ade8:	183ee83a 	callr	r3
2002adec:	003ff406 	br	2002adc0 <__alt_data_end+0xfffeadc0>
2002adf0:	a0800017 	ldw	r2,0(r20)
2002adf4:	a027883a 	mov	r19,r20
2002adf8:	1029883a 	mov	r20,r2
2002adfc:	003fb606 	br	2002acd8 <__alt_data_end+0xfffeacd8>
2002ae00:	0005883a 	mov	r2,zero
2002ae04:	003ffb06 	br	2002adf4 <__alt_data_end+0xfffeadf4>

2002ae08 <__divsi3>:
2002ae08:	20001b16 	blt	r4,zero,2002ae78 <__divsi3+0x70>
2002ae0c:	000f883a 	mov	r7,zero
2002ae10:	28001616 	blt	r5,zero,2002ae6c <__divsi3+0x64>
2002ae14:	200d883a 	mov	r6,r4
2002ae18:	29001a2e 	bgeu	r5,r4,2002ae84 <__divsi3+0x7c>
2002ae1c:	00800804 	movi	r2,32
2002ae20:	00c00044 	movi	r3,1
2002ae24:	00000106 	br	2002ae2c <__divsi3+0x24>
2002ae28:	10000d26 	beq	r2,zero,2002ae60 <__divsi3+0x58>
2002ae2c:	294b883a 	add	r5,r5,r5
2002ae30:	10bfffc4 	addi	r2,r2,-1
2002ae34:	18c7883a 	add	r3,r3,r3
2002ae38:	293ffb36 	bltu	r5,r4,2002ae28 <__alt_data_end+0xfffeae28>
2002ae3c:	0005883a 	mov	r2,zero
2002ae40:	18000726 	beq	r3,zero,2002ae60 <__divsi3+0x58>
2002ae44:	0005883a 	mov	r2,zero
2002ae48:	31400236 	bltu	r6,r5,2002ae54 <__divsi3+0x4c>
2002ae4c:	314dc83a 	sub	r6,r6,r5
2002ae50:	10c4b03a 	or	r2,r2,r3
2002ae54:	1806d07a 	srli	r3,r3,1
2002ae58:	280ad07a 	srli	r5,r5,1
2002ae5c:	183ffa1e 	bne	r3,zero,2002ae48 <__alt_data_end+0xfffeae48>
2002ae60:	38000126 	beq	r7,zero,2002ae68 <__divsi3+0x60>
2002ae64:	0085c83a 	sub	r2,zero,r2
2002ae68:	f800283a 	ret
2002ae6c:	014bc83a 	sub	r5,zero,r5
2002ae70:	39c0005c 	xori	r7,r7,1
2002ae74:	003fe706 	br	2002ae14 <__alt_data_end+0xfffeae14>
2002ae78:	0109c83a 	sub	r4,zero,r4
2002ae7c:	01c00044 	movi	r7,1
2002ae80:	003fe306 	br	2002ae10 <__alt_data_end+0xfffeae10>
2002ae84:	00c00044 	movi	r3,1
2002ae88:	003fee06 	br	2002ae44 <__alt_data_end+0xfffeae44>

2002ae8c <__modsi3>:
2002ae8c:	20001716 	blt	r4,zero,2002aeec <__modsi3+0x60>
2002ae90:	000f883a 	mov	r7,zero
2002ae94:	2005883a 	mov	r2,r4
2002ae98:	28001216 	blt	r5,zero,2002aee4 <__modsi3+0x58>
2002ae9c:	2900162e 	bgeu	r5,r4,2002aef8 <__modsi3+0x6c>
2002aea0:	01800804 	movi	r6,32
2002aea4:	00c00044 	movi	r3,1
2002aea8:	00000106 	br	2002aeb0 <__modsi3+0x24>
2002aeac:	30000a26 	beq	r6,zero,2002aed8 <__modsi3+0x4c>
2002aeb0:	294b883a 	add	r5,r5,r5
2002aeb4:	31bfffc4 	addi	r6,r6,-1
2002aeb8:	18c7883a 	add	r3,r3,r3
2002aebc:	293ffb36 	bltu	r5,r4,2002aeac <__alt_data_end+0xfffeaeac>
2002aec0:	18000526 	beq	r3,zero,2002aed8 <__modsi3+0x4c>
2002aec4:	1806d07a 	srli	r3,r3,1
2002aec8:	11400136 	bltu	r2,r5,2002aed0 <__modsi3+0x44>
2002aecc:	1145c83a 	sub	r2,r2,r5
2002aed0:	280ad07a 	srli	r5,r5,1
2002aed4:	183ffb1e 	bne	r3,zero,2002aec4 <__alt_data_end+0xfffeaec4>
2002aed8:	38000126 	beq	r7,zero,2002aee0 <__modsi3+0x54>
2002aedc:	0085c83a 	sub	r2,zero,r2
2002aee0:	f800283a 	ret
2002aee4:	014bc83a 	sub	r5,zero,r5
2002aee8:	003fec06 	br	2002ae9c <__alt_data_end+0xfffeae9c>
2002aeec:	0109c83a 	sub	r4,zero,r4
2002aef0:	01c00044 	movi	r7,1
2002aef4:	003fe706 	br	2002ae94 <__alt_data_end+0xfffeae94>
2002aef8:	00c00044 	movi	r3,1
2002aefc:	003ff106 	br	2002aec4 <__alt_data_end+0xfffeaec4>

2002af00 <__udivsi3>:
2002af00:	200d883a 	mov	r6,r4
2002af04:	2900152e 	bgeu	r5,r4,2002af5c <__udivsi3+0x5c>
2002af08:	28001416 	blt	r5,zero,2002af5c <__udivsi3+0x5c>
2002af0c:	00800804 	movi	r2,32
2002af10:	00c00044 	movi	r3,1
2002af14:	00000206 	br	2002af20 <__udivsi3+0x20>
2002af18:	10000e26 	beq	r2,zero,2002af54 <__udivsi3+0x54>
2002af1c:	28000516 	blt	r5,zero,2002af34 <__udivsi3+0x34>
2002af20:	294b883a 	add	r5,r5,r5
2002af24:	10bfffc4 	addi	r2,r2,-1
2002af28:	18c7883a 	add	r3,r3,r3
2002af2c:	293ffa36 	bltu	r5,r4,2002af18 <__alt_data_end+0xfffeaf18>
2002af30:	18000826 	beq	r3,zero,2002af54 <__udivsi3+0x54>
2002af34:	0005883a 	mov	r2,zero
2002af38:	31400236 	bltu	r6,r5,2002af44 <__udivsi3+0x44>
2002af3c:	314dc83a 	sub	r6,r6,r5
2002af40:	10c4b03a 	or	r2,r2,r3
2002af44:	1806d07a 	srli	r3,r3,1
2002af48:	280ad07a 	srli	r5,r5,1
2002af4c:	183ffa1e 	bne	r3,zero,2002af38 <__alt_data_end+0xfffeaf38>
2002af50:	f800283a 	ret
2002af54:	0005883a 	mov	r2,zero
2002af58:	f800283a 	ret
2002af5c:	00c00044 	movi	r3,1
2002af60:	003ff406 	br	2002af34 <__alt_data_end+0xfffeaf34>

2002af64 <__umodsi3>:
2002af64:	2005883a 	mov	r2,r4
2002af68:	2900122e 	bgeu	r5,r4,2002afb4 <__umodsi3+0x50>
2002af6c:	28001116 	blt	r5,zero,2002afb4 <__umodsi3+0x50>
2002af70:	01800804 	movi	r6,32
2002af74:	00c00044 	movi	r3,1
2002af78:	00000206 	br	2002af84 <__umodsi3+0x20>
2002af7c:	30000c26 	beq	r6,zero,2002afb0 <__umodsi3+0x4c>
2002af80:	28000516 	blt	r5,zero,2002af98 <__umodsi3+0x34>
2002af84:	294b883a 	add	r5,r5,r5
2002af88:	31bfffc4 	addi	r6,r6,-1
2002af8c:	18c7883a 	add	r3,r3,r3
2002af90:	293ffa36 	bltu	r5,r4,2002af7c <__alt_data_end+0xfffeaf7c>
2002af94:	18000626 	beq	r3,zero,2002afb0 <__umodsi3+0x4c>
2002af98:	1806d07a 	srli	r3,r3,1
2002af9c:	11400136 	bltu	r2,r5,2002afa4 <__umodsi3+0x40>
2002afa0:	1145c83a 	sub	r2,r2,r5
2002afa4:	280ad07a 	srli	r5,r5,1
2002afa8:	183ffb1e 	bne	r3,zero,2002af98 <__alt_data_end+0xfffeaf98>
2002afac:	f800283a 	ret
2002afb0:	f800283a 	ret
2002afb4:	00c00044 	movi	r3,1
2002afb8:	003ff706 	br	2002af98 <__alt_data_end+0xfffeaf98>

2002afbc <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
2002afbc:	defffd04 	addi	sp,sp,-12
2002afc0:	df000215 	stw	fp,8(sp)
2002afc4:	df000204 	addi	fp,sp,8
2002afc8:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
2002afcc:	d025f645 	stb	zero,-26663(gp)
2002afd0:	e0bfff17 	ldw	r2,-4(fp)
2002afd4:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
2002afd8:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
2002afdc:	10000226 	beq	r2,zero,2002afe8 <_exit+0x2c>
    ALT_SIM_FAIL();
2002afe0:	002af070 	cmpltui	zero,zero,43969
2002afe4:	00000106 	br	2002afec <_exit+0x30>
  } else {
    ALT_SIM_PASS();
2002afe8:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
2002afec:	003fff06 	br	2002afec <__alt_data_end+0xfffeafec>
